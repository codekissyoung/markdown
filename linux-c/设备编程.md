# 设备文件
- linux将设备也抽象成文件 : 文件包含数据，具有属性，通过目录中的名字被标识，可以从一个设备文件中读数据，也可以写数据
- 每个设备都被当做一个文件 : 有一个文件名，一个`i-node`,一个文件所有者，一个权限位的集合 和 最近修改时间
- 通常表示设备的文件存放在 `/dev` 目录中
- 设备文件支持所有文件相关的系统调用 : `open` `read` `write` `lseek` `close` `stat`
```c
# 从磁带读取数据
int fd = open("/dev/tape",O_RDONLY);
lseek(fd,(long)4096,SEEK_SET);
n = read(fd,buf,buflen);
close(fd);
```
- 但是也要考虑实际情况: `/dev/mouse`不支持所有`write`系统调用，终端`/dev/pts/3`支持`read`和`write`,但不支持`lseek`
- `tty` 命令 : 打印用户所在终端对应的 设备文件名
```bash
➜  ~ tty
/dev/pts/6
➜  ~ who > /dev/pts/6
cky      pts/0        2018-04-11 10:24 (183.15.176.171)
zj       pts/1        2017-08-12 19:16 (tmux(21653).%1)
cky      pts/2        2018-01-12 16:59 (tmux(8156).%0)
cky      pts/3        2018-04-11 10:24 (183.15.176.171)
cky      pts/4        2018-04-11 10:58 (183.15.176.171)
➜  pts ls -alhi /dev/pts
总用量 0
 1 drwxr-xr-x  2 root  root       0 12月 12  2016 .
 2 drwxr-xr-x 19 root  root    4.8K 4月  17  2017 ..
 3 crw--w----  1 cky   tty  136,  0 4月  11 14:42 0
 4 crw--w----  1 zj    tty  136,  1 8月  12  2017 1
14 crw--w----  1 zj    tty  136, 11 4月  11 14:47 11
 5 crw--w----  1 cky   tty  136,  2 4月  10 14:43 2
 6 crw--w----  1 cky   tty  136,  3 4月  11 10:58 3
 7 crw--w----  1 cky   tty  136,  4 4月  11 11:00 4
 8 crw--w----  1 meizi tty  136,  5 8月  19  2017 5
 9 crw--w----  1 cky   tty  136,  6 4月  11 14:58 6
11 crw--w----  1 zj    tty  136,  8 8月  11  2017 8
12 crw--w----  1 zj    tty  136,  9 10月  8  2017 9
 2 c---------  1 root  root   5,  2 12月 12  2016 ptmx
```

- 设备文件是链接,设备的`i-node`存的是指向内核子程序的指针，而不是文件的属性和存储列表，从终端进行数据传输的代码是在设备进程表中编号为`136`的子程序,该子程序接受一个整形参数，在`/dev/pts/2`中参数是2,`136`和`2`被称为主设备号和从设备号, 主设备号 确定处理该设备实际的子程序，从设备号则作为参数传入该子程序

- 设备文件的权限位 : 写权限意味着允许向设备发送数据。读权限就是从设备获得数据

- 目录并不能区分哪些文件名 是 磁盘文件 和 设备文件。文件类型的区别提醒在`i-node`上。文件的类型被记录在`i-node`的`stat`成员变量`st_mode`中
    - 磁盘文件的`i-节点`包含指向数据块的指针列表
    - 设备文件的`i-节点`包含指向内核中设备驱动器的指针 ，主设备号用于告知从设备中读取数据的那部分代码的位置

- `read()`工作: 内核首先找到文件描述符的`i-node`,判断该文件的类型。
    - 如果是磁盘文件，则访问块分配表来读取数据。
    - 如果是设备文件，则调用该设备驱动程序的`read`部分来读取数据。

- 磁盘文件的连接 与 终端的链接不同
    - 磁盘文件的链接有缓冲区，从进程到磁盘的字节先被缓冲到内核缓冲区，然后才从内核被发送出去。
    ```c
    // 关闭磁盘缓冲
    #include <fcntl.h>
    int s = fcntl(fd,F_GETFL); // 获取设置
    s |= O_SYNC;  // 修改设置
    result = fcntl(fd, F_SYNC, s); // 存储设置

    // 设置自动添加模式
    s = fcntl(fd,F_GETFL);
    s |= O_APPEND;
    result = fcntl(fd,F_SETFL,s);
    ```
    - 终端文件具有回显，波特率，编辑和换行会话,进程和外部设备间的数据流，需要经过内核子程序集合的处理，这个集合称为`终端驱动程序`或者`tty驱动程序`，驱动程序包含很多控制设备操作的设置，进程可以读，修改和重置这些驱动程序

```bash
➜  ~ stty --all   # 用于读取和修改终端驱动程序的设置
speed 9600 baud; rows 108; columns 131; line = 0;
intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = M-^?; eol2 = M-^?; swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z;
rprnt = ^R; werase = ^W; lnext = ^V; discard = ^O; min = 1; time = 0;
-parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts
-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc ixany imaxbel -iutf8
opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0
isig icanon iexten echo echoe -echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke -flusho -


$ stty srase X      # 将删除键改为 X
$ stty - echo       # 关闭按键回显，这样输密码就看不到了
$ stty erase @ echo # 将删除键设置为 @ , 同时开启回显模式
```

# 编写终端驱动程序 : 关于设置
- 输入: 处理从终端到进程的数据
- 输出: 处理从进程到终端的数据
- 控制: 字符如何被表示 : 位的个数 位的奇偶性 停止位
- 本地: **驱动程序如何处理来自驱动程序内部的字符**

# 改变终端驱动程序的设置
```c
#include <termios.h>
struct termios attribs;
tcgetattr(fd, &setting);    // 从驱动程序获得属性
setting.c_lflag |= ECHO;    // 修改属性
tcsetattr( fd, TCSANOW, &settings ); // 把属性写回驱动程序
```

# 非阻塞输入
- 当调用`read()`或者`getchar()`从文件描述符中读取输入时，这些调用通常都会一直等待用户输入，程序被`阻塞`在这个地方，直到用户输入完成，或者检测到了文件末尾。
- 使用`fcntl()`或者`open()`时为文件描述符设置成`非阻塞输入nonblock input`,在非阻塞状态下，`read()`调用
    - 如果能获得输入，则获得输入并返回获得的字符个数；
    - 如果没有输入字符，则`read()`返回0
- 非阻塞操作的内部实现: 每个文件都有一块保存未读取数据的地方，如果文件描述符设置了`O_NDELAY`位，并且那块空间是空的，`read()`调用返回0.

# 终端驱动程序产生信号
- 用户输入`Ctrl + C`, `终端驱动程序`收到字符，匹配`VINTR`和`ISIG`字符被开启，驱动程序调用信号系统，信号系统发送`SIGINT`到进程，进程收到`SIGINT`,进程消亡

# 处理信号
- 忽略信号 `signal( SIGINT, SIG_IGN )` 设置为 忽略中断信号
- 设置信号处理函数 `signal( SIGINT, ctrl_c_handler_func )`, 当信号发生时，调用`ctrl_c_handler_func`函数进行处理






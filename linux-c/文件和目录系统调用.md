# 目录系统调用
- 目录: 特殊的文件，内容是文件和子目录的名字
- 每个目录包含两个特殊的项目: `.` 和 `..`
- `open` `read` `close`这些函数，可以把一个目录当做文件来打开，但是这并不是很好的方法，因为 linux目录类型非常多，例如`Apple HFS` `ISO9660` `VFAT` `NFS`等，如果以`read`来读，则需要了解不同类型目录各自的结构细节
- `int mkdir(const char *path, mode_t mode);` 创建目录，在创建时设置权限需要使用`umask(0)`取消权限掩码限制，否则只能使用系统默认属性创建
- `DIR* opendir( const char* path )` 打开目录 `path`
- `struct dirent * readdir( DIR* dir )` 获取一次当前目录中的文件信息
- `int remove(char * filename);` 删除指定文件或者空目录
- `int rmdir(const char *pathname);` 删除空目录
- `int unlink(const char *pathname);` 删除文件
- `int  closedir(DIR * dir);` 关闭之前打开的dir目录
- `int rename(const char *oldname, const char *newwname) ;` 文件或者目录更换名字
- `char *getcwd(char *buf, size_t size);` 得到当前目录的完整路径
- `int chdir(const char *pathname);` 改变当前目录
- 由于删除目录比较麻烦需要遍历挨个删除，可以使用`system("rm -rf /dir")`

```c
struct __dirstream  
{  
    void *__fd; /* `struct hurd_fd' pointer for descriptor.   */  
    char *__data; /* Directory block.   */  
    int __entry_data; /* Entry number `__data' corresponds to.   */  
    char *__ptr; /* Current pointer into the block.   */  
    int __entry_ptr; /* Entry number `__ptr' corresponds to.   */  
    size_t __allocation; /* Space allocated for the block.   */  
    size_t __size; /* Total valid data in the block.   */  
    __libc_lock_define (, __lock) /* Mutex lock for this structure.   */  
};
typedef struct __dirstream DIR;

struct dirent  
{  
    long d_ino; /* inode number 索引节点号 */  
    off_t d_off; /* offset to this dirent 在目录文件中的偏移 */  
    unsigned short d_reclen; /* length of this d_name 文件名长 */  
    unsigned char d_type; /* the type of d_name 文件类型 */  
    char d_name [NAME_MAX+1]; /* file name (null-terminated) 文件名，最长255字符 */  
}

# d_type 定义
enum  
{   
    DT_UNKNOWN = 0,   
    # define DT_UNKNOWN DT_UNKNOWN //未知文件  
    DT_FIFO = 1,   
    # define DT_FIFO DT_FIFO //FIFO有名管道文件  
    DT_CHR = 2,   
    # define DT_CHR DT_CHR //字符设备文件  
    DT_DIR = 4,   
    # define DT_DIR DT_DIR //目录文件  
    DT_BLK = 6,   
    # define DT_BLK DT_BLK //块设备文件  
    DT_REG = 8,   
    # define DT_REG DT_REG //普通文件  
    DT_LNK = 10,   
    # define DT_LNK DT_LNK //链接文件  
    DT_SOCK = 12,   
    # define DT_SOCK DT_SOCK //socket文件  
    DT_WHT = 14   
    # define DT_WHT DT_WHT //whiteout-base文件  
};   
```

# 文件类型和许可权限
- 使用了16位二进制数来存储文件类型和许可权限信息
- 分别是: 文件类型(四位),`set-user-ID位`,`set-group-ID位`,`sticky位`,所有者权限(3位),所有组权限(3位),其他人权限(3位)
- 可执行文件的`set-user-ID位`可以设置为1,意思是运行该程序的时候，认为是由文件所有者在运行这个程序,比如`-rwsr-xr-x 1 root root 54256 5月  17  2017 /usr/bin/passwd` 的所有者是root,用户运行`passwd`设置自己密码时，`passwd`的运行用户实际是`root`,所以能修改密码文件`-rw-r--r-- 1 root root 1848 10月 13 11:35 /etc/passwd`
- `set-group-ID位`设置程序运行时，是否使用程序本身所属的用户组，设置为1 : 意思是用户运行程序时，就像是程序所属组里的某个用户在运行程序一样
- `sticky位`也称为`粘着位`
    - 对于可执行文件来说，设置了`sticky位`就意味着该可执行程序即使没在运行，也需要被放置在`交换空间`中；
    - 对于目录来说，`sticky位`的含义则是：该目录下谁都可以创建文件，但是文件只能被文件的所有者删除

# 设置文件类型和许可权限
- 文件类型是在创建文件时就确立的，一经创建，无法修改
- `set-user-ID位`,`set-group-ID位`,`sticky位` 和9个权限位，在创建的时候由`int creat(path,0766)`和`umask( 022 )`两者确定
- `umask( 022 )` 设置`新建文件掩码`,目的为屏蔽新建文件的某些权限，例如：要防止程序创建出能同时被同组用户和其他用户修改的文件，掩码就是`022`(八进制) 即 `000 010 010`( 二进制 )，取反就是`111 101 101`, 与 `0766` 即 `000 111 110 110` 进行 `&` 运算得到 `000 111 100 100` 即 `--- rwx r-- r--` 就是新建文件的最终权限
- `chmod(path,mod)` 可以直接修改文件的权限，并且不受`新建文件掩码`影响


```c
#include <sys/types.h>
#include <sys/stat.h>
// 取得文件信息
int stat(const char *pathname, struct stat *buf);
int fstat (int fd,struct stat *buf);
 // lstat函数类似于stat,但是当命名的文件是一个符号连接时,lstat返回该符号连接的有关信息,而不是由该符号连接引用的文件的信息
int lstat(const char *pathname, struct stat *buf);

struct stat
{
    mode_t    st_mode;    文件类型，文件权限
    ino_t     st_ino;        i节点号
    dev_t    st_dev;        
    dev_t    st_rdev;    设备文件序号
    nlink_t    st_nlink;    链接
    uid_t    st_uid;
    gid_t     st_gid;        用户ID
    off_t    st_size;    文件大小,此字段只对普通文件、目录文件和符号连接有意义。
    time_t    st_atime;    最后存取时间
    time_t    st_mtime;    文件内容的最后修改时间
    time_t    st_ctime;    文件状态的最后修改时间
    long    st_blksize;    
    long     st_blocks;
};
```

# 判断文件权限
```c
#include <unistd.h>
// mode 说 明 : R_OK 测试读许可权 W_OK 测试写许可权 X_OK 测试执行许可权 F_OK 测试文件是否存在
int access (const char *name, int mode) ;
```

# 修改文件权限
```c
#include <sys/types.h>
#include <sys/stat.h>
int chmod(const char *pathname, mode_t mode);
int fchmod(int fd, mode_t mode);
```

# 更改文件的用户 ID和组ID
```c
#include <sys/types.h>
#include <unistd.h>
int chown(const char *pathname,uid_t owner,gid_t group);
int fchown(int fd, uid_t owner, gid_t group);
int lchown(const char *pathname, uid_t owner, gid_t group);
```

# 创建一个硬连接
```c
#include <unistd.h>
// 只有超级用户进程可以创建指向一个目录的新连接
int link(const char＊oldpath, const char *newpath) ;
```

# 创建一个软连接
```c
#include <unistd.h>
int symlink(const char *oldpath, const char *sympath) ;
// 因为open函数跟随符号连接,所以需要有一种方法打开该连接本身,并读该连接中的名字
int readlink(const char ＊pathname, char ＊buf, int bufsize) ;
```

# 文件时间
- 文件时间: 最后修改时间 最后访问时间 属性最后修改时间
- 当文件被操作时，内核会自动地修改这些时间
- 可以通过系统调用来修改 最后修改时间 和 最后访问时间
```c
#include <sys/time.h>
#include <utime.h>
#include <sys/types.h>
int utime( char* path, struct utimbuf *new_time );
```

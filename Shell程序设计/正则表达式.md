# 正则表达式

我对于正则表达式的理解，正则表达式是文本之间的游戏。

## 匹配 or 不匹配?

给定了一段文本 `"*****"`，长度未知，内容未知。现在，要去这段文本里面找一东西。

首先，第一个问题，我们如何描绘要找的东西?

比如，这东西是数字 `1` ?

- 我们用 `1` 表示这东西

如果，这东西是数字 `1 3 5 7` 其中1个 ?

- 我们用 `[1357]` 表示

如果，它是数字 0 到 9 其中 1 个 ?

- `[0-9]`

如果，它可能是数字 0 到 9，还可能是字母 a 到 z ，A 到 Z，还可能是 `? _ . !` 这几个字符?

- `[0-9a-zA-Z_!.?]`

如果，我知道它不是数字，其他字符都可能是?

- `[^0-9]`

它就是一个字符，是什么字符无所谓?

- `.`

如果，它有3字符，第1个已经确定了是字母`a`,第2个是一个数字，第3个是字母`z`?

- `a[0-9]z`

好，现在我们开始寻找，`"*****"` 假设为 `dda2zxxxnxc8ef93a9z`，能找到么?

- 能找到，而且找到两个 `a2z` 与 `a9z`。这种至少找到一个描述的东西的情况，我们一般称 “匹配了”，如果未找到，就是“不匹配”。

ok，我们继续，假如我们要找的东西为 `a[0-9]z`，并且限定 这东西 只能在开头找，怎么表示这种“限定”?

- `^a[0-9]z`

在开头能找到么?

- 不能，所以“不匹配”

如果，限定这 东西 只能在尾巴找，怎么表示？能找到么？

- `a[0-9]z$` ，能找到一个`a9z`，所以 “匹配”

## 量词

如果，我们要找到东西为100个`a`字符，难道要写100遍么?

- 不是，可以使用量词 `a{100}`

```bash
{n}         # 必须出现 n 次
{m,n}       # 最少出现 m 次，最多出现 n 次
{m,}        # 最少 m 次，无上限
*           # 等价 {0,}
+           # 等价 {1,}
?           # 等价 {0,1}
```

## 分组

### 基本匹配规则

- `|` 的意思是或，`gr[ea]y`可以使用`gr(e|a)y` 或者 `grey|gray` 来代替
- `^(From|Subject|Date):` 匹配的是，行开头是From 或者Subject或者Date,接着是一个: 。区分`^From|Subject|Date:` 它后面的:只在Date分支里
- `<hr( +size *= *[0-9]+)? *>`,使用`()?`将子表达式变成了一个可选项，用以匹配`<hr>` `<hr >`这样的情况

### 简记法

```bash
\t 制表符  \n 换行符 \r 回车符
\s 任何空白字符;     \S 取反
\w 等价[0-9a-zA-Z_]; \W 取反
\d 等价[0-9]         \D 取反
\b 匹配单词起始和结束
```
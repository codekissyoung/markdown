# Bash命令

我积累的 Bash 命令。

## 常识

#### 通配符

```bash
*                     代表任意字符串
?                     代表一个字符
[abcd]                代表从a, b, c, d选字符
[!abcd]               代表除这些字符串之外任意字符
[1-9]                 匹配1到9
[a-z]                 表示a到z
ls my_{finger,toe}s   匹配 my_fingers my_toes
```

#### 终端快捷健

```bash
[Tab] 自动补充
[Ctrl] + a 到正在输入的命令行的头部
[Ctrl] + e 到正在输入的命令行的尾部
[Ctrl] + c 终止当前进程
[Ctrl] + k 删除光标后的所有字符
```

#### 终端设置

```bash
stty -a           # 以容易阅读的方式打印当前的所有配置
stty -echo        # 设置终端不要回显
stty echo         # 终端恢复回显
stty iuclc        # 禁止大写  -iuclc 恢复
stty olcuc        # 禁止小写  -olcuc 恢复
stty size         #  打印出终端的行数和列数
stty eof "string" # 系统默认是Ctrl+D来表示文件的结束，而通过这种方法，可以改变！
stty igncr        # 忽略回车符 -igncr 恢复
```

#### 命令别名

在脚本中默认不开启，所以不可以使用别名。

```bash
# `./xxx.sh`运行shell脚本,，alias别名无效，`source`和`.`方式是起有效的，因为是在当前shell运行
alias ls='ls --color=auto';
alias rm='rm() { mv $@ ~/backup/; };rm' # 配合函数，使用alias命令,将危险的rm命令，替换成mv命令
```

#### 搜索

```bash
$ whereis gcc                   
$ sudo updatedb && locate gcc
```




## 文件

### 文件权限

```bash
chmod  [-R] 777             /var/home/www # 改变文件/目录权限 -R是递归
chown  [-R] caokaiyan       /var/home/www # 改变文件所有者
chown  [-R] caokaiyan:admin /var/home/www # 同时改变文件所有者和用户组
chgrp  [-R] admin           /var/home/www # 改变用户组
ls  -aldh  /root                  # 显示/root下所有文件
pwd                               # 显示当前目录
umask                             # 查看当前值
umask 022                         # 设置值
touch  test.c                     # 创建一个新文件  默认权限 666 - umask 值 比如 666 - 022 = 644
mkdir -p    /var/www/advanced     # 递归创建目录    默认权限 777 - umask 值
rm    -rf    /mydir               # 强制删除/mydir目录和里面的文件
cp  test.c   /root/test.c         # 复制文件
cp  -r /var/www/abc  /var/www/dcf # 复制目录 -a 是复制文件与原文件一模一样
mv  test.c  /root/test1.c         # 移动文件  (移动和复制都是有改名的效果的)
mv  /var/www/abc/  /root/def/     # 移动目录
more  Myfile                      # 分页查看文件内容，空格：下一页，enter：下一行，q：退出
tail -f debug.log                 # 动态监看日志
ln source.txt  /var/target.txt      # 创建硬链接
ln -s source.txt  /var/target.txt   # 创建软连接
sleep 1                             # 休眠 1 s
date +%s                            # 返回时间戳
date +%Y_%m_%d_%H_%M_%S             # 返回 年_月_日_时_分_秒
```

### cat 拼接输入以及文件

```bash
cat file1 file2 file3                       # 拼接输出多个文件
echo 'text through stdin' | cat - file.txt  # 将输入stdin和file.txt拼接起来， - 是stdin文本的文件名
cat -s multi_blanks.txt                     # 压缩相邻的空行
cat -n lines.txt                            # 为每一行加上行号后输出
```

### xargs 将输入转化为命令行参数

- 有些命令只能以命令行参数的形式接受收据，而无法通过stdin接受数据流。在这种情况下，我们没法用管道来提供那些只有通过命令行参数才能提供的数据, xargs擅长将标准输入数据转换成命令行参数
- -d 选项，指明定界符, 默认将空格作为定界符,xargs没有指定参数时，默认能将换行符替换成空格, `-0` 将 null 作为界定符
- -n 选项，指明每行最大的参数数量
- -I 指定替换字符串
- 很多文件名中都可能会包含空格符，而xargs很可能会误认为它们是定界符(例如，hell text.txt会被xargs误认为hell和text.txt)
- xargs 不能为多组命令提供参数

#### 基础

```bash
cat xargs.txt
12 22 3 3 56
32 23 45 6

cat xargs.txt  | xargs  # 输出 12 22 3 3 56 32 23 45 6

cat xargs.txt  | xargs -n3
12 22 3
3 56 32
23 45 6

echo "splitXsplitXsplitXsplit" | xargs -d X # 输出 split split split split

echo "splitXsplitXsplitXsplit" | xargs -d X -n2
split split
split split
```

#### 高级用法

```bash
$ cat cecho.sh
#!/bin/bash
echo '处理' $*

$ cecho.sh aaa bbb ccc
处理 aaa bbb ccc

cat args.txt
aaa
bbb
ccc

$ cat args.txt | xargs -n1 cecho.sh
处理 aaa
处理 bbb
处理 ccc

# 将找到的 txt 文件删除
find . -type f -name "*.txt" | xargs -0 rm -f

$ cat args.txt | xargs -I {} cecho.sh -p {} -l
处理 -p aaa -l
处理 -p bbb -l
处理 -p ccc -l

# 将找到的 sh 文件 拷贝到 sh_dir 文件夹中
find . -name '*.sh' | xargs -I {} cp {} sh_dir

# 统计 c 代码行数
find . -type f -name "*.c" | xargs -0 wc -l

# 利用子shell, 下句等价 cat files.txt | xargs -I {} cat {}
cat files.txt | (while read arg;do cat $arg;done)
cmd0 | (cmd1;cmd2;cmd3) | cmd4
```

## caller

- 将caller 命令放到函数中,将会在stdout 上打印出函数调用者的信息.
- caller 命令也可以返回在一个脚本中被source的另一个脚本的信息.象函数一样,这是一个， "子例程调用",你会发现这个命令在调试的时候特别有用.
- ture一个返回成功(就是返回0)退出码的命令flase一个返回失败(非0)退出码的命令

```bash
#!/bin/bash
# cky.sh
bar(){
  echo 'bar called';
  caller 0 # 显示调用者信息
}
call_function(){
  bar;
}
call_function;
```

```bash
#!/bin/bash
# cky_call.sh
. cky.sh
```

```bash
./cky_call.sh
bar called
15 call_function cky.sh
```

```bash
dirs          # 显示当前目录
disown -h %2  # 将后台作业[Ctrl + z生成的],屏蔽HUB信号
enable 启用
eval
exec 用指定命令替换shell进程
fc 从历史记录中选择一条命令
fg %2 恢复后台作业到前台
getopts
hash 内置hash表，建立到PATH路径下面的路径的直接链接
history 显示命令历史记录
jobs  查看后台作业
kill -n PID 向进程发送信号
let 计算数学表达式
local 在函数中申明一个局部变量，只能在函数中访问到
logout 退出shell登录
popd 从目录栈中删除记录
printf 格式化打印
pushd 向目录栈添加记录
readonly 声明只读变量
set 设置/显示环境变量　和 shell特性
shift 将参数位置前移一位
shopt 打开/关闭shell可选行为的变量值
suspend 暂停shell的执行，直到收到SIGCONT
times 显示累计的用户时间和系统时间
trap 如果收到了指定的系统信号，执行指定的命令
type 查看命令类型
ulimit 给用户指定的资源设置上限
unalias 删除别名
unset 删除变量
wait 等待指定进程完成，并返回退出状态码
```

## 文件查找与文件列表

```bash
find                                  # 在当前目录，寻找所有的子目录/文件
find /etc                             # 在/etc 目录，寻找所有的子目录/文件
find /etc -name "*.log"               # 通配符匹配目录名和文件名; -iname是忽略大小写
find /etc ! -name "*.txt"             # ! 取反，表示查找所有不以 .txt 结尾的文件
find /etc -path '*/linux/*'           # 拿整个路径进行匹配,使用的是通配符
find /etc -regex ".*\(\.py | \.sh\)$" # 拿整个路径进行匹配,使用正则表达式匹配, -iregex 让正则表达式忽略大小写

# 遍历深度
find /etc -maxdepth 1 -name 'f*'      # 最大遍历深度，到当前子目录，不再往下遍历
find /etc -mindepth 2 -name 'f*'      # 最小遍历深度，从子目录的子目录开始遍历

# 过滤出指定类型
find /etc -type d                     # 过滤出目录 -type f普通文件 -type l; -type c; -type s套接字 -type FIFO管道

# 过滤出时间范围
# 按天计数 : -atime 最近被访问的时间 -ctime 是最后权限变更 -mtime 是最后内容改变时间
# -amin -mmin -cmin 是以分钟计数的
find /etc -mtime -10                  # 查找10天内修改的文件; +10 就是十天前

# 过滤用户
find /etc -user cky                   # 查找指定用户的文件，-nouser 查找没有所有者的文件

# 过滤大小
find /etc -size -25k                  # 查找小于 25k 的文件; +25k 是大于; 单位 c 字节 k M G
find /etc -size +20k -a -size -50k    # -a 同 && : 找20k到50k之间到文件
find /etc -size -20k -o -size +50k    # -o 同 || : 找到小于20k 或者 大于50k的

# 其他过滤
find /etc -inum 345232                # 通过inode节点查找文件
find /etc -perm 644                   # 查出权限为644的文件

# 对查找到的文件执行操作
find . -type f -name"*.swp" -delete   # 将找到的文件全部删除

# {} 会替换成相应的文件名
find . -name '*.sh' -exec cat {} \;               # 找到 .sh 文件，然后将这些文件作为 cat 的输入
find . -name '*.sh' -exec cp {} copy.sh \;        # 将查询到的所有文件都拷贝到 copy.sh 中
find . -name '*.sh' -exec commond.sh {} \;        # 使用 commond.sh 处理每个匹配到的文件
find . -type f -user root -exec chown cky {} \;   # 将匹配的文件，修改它们用户名为 cky

# find 跳过指定的路径
find . \( -name '.git' -prune \) -o \( -type f \) -print # 跳过 .git 目录
```

## 加密 解密

### md5sum 和 sha1sum 单向散列加密

```bash
md5sum cky.sh > cky.md5 # 将校验值存入文件
md5sum -c cky.md5       # 检验文件是否完整
cky.sh: 成功
```

### md5deep

```bash
sudo apt install hashdeep # 安装
mkdir md5_dir
touch md5_dir/aaa.txt
touch md5_dir/bbb.txt
echo "asdf bb cc" > md5_dir/ccc.txt
md5deep -r1 md5_dir > md5_dir.md5

md5deep -rl md5_dir > md5_dir.md5
cat md5_dir.md5
d41d8cd98f00b204e9800998ecf8427e  md5_dir/aaa.txt
d41d8cd98f00b204e9800998ecf8427e  md5_dir/bbb.txt
ae7a125ed9b9ea27e7d299386c48e816  md5_dir/ccc.txt

md5sum -c md5_dir.md5   # 计算校验和
md5_dir/aaa.txt: 成功
md5_dir/bbb.txt: 成功
md5_dir/ccc.txt: 成功
```

### crypt 加密

```bash
crypt cky951010 < cky.sh > cky_crypt
程序“crypt”尚未安装 您可以使用以下命令安装：
sudo apt install mcrypt
sudo apt-get install mcrypt

crypt cky951010 < cky.sh > cky_crypt # 使用口令给文件内容加密，加密后的文件是密文
crypt cky951010 -d <cky_crypt >cky_crypt_coutput.txt # 解密
```

### gpg 生成签名

```bash
gpg -c cky.sh # 生成签名，采用交互式读取口令
ls |grep gpg
cky.sh.gpg

gpg cky.sh.gpg
gpg: AES 加密过的数据
gpg: 以 1 个密码加密
File 'cky.sh' exists. 是否覆盖？(y/N) y
```

### base64

```bash
base64 cky.sh > cky.sh.base64   # base64 加密
base64 -d cky.sh.base64         # base64 解密
```

## 压缩 解压

```bash
bzip2 -k cky              # 压缩cky文件为.bz2文件，-k 保留源文件
bunzip2 cky.bz2           # 解压文件

gzip cky                  # 压缩cky文件为.gz文件
gzip -d cky.gz            # 解压文件

zip -r src.zip src/       # 递归压缩 src/ 目录下的文件 为 src.zip
unzip src.zip             # 解压

tar -zcvf cky.tar.gz cky  # 归档压缩
tar -zxvf cky.tar.gz      # 解压到当前目录
```



## 网络通信命令

`ping    + ip地址/URL`
发送数据包，看看能不能得到包的返回ping    自己机器ip地址：如果能通，说明自己的网络设置是没问题的！
`ping    127.0.0.1(回环地址)` 检测自己机器安装了tip/ip 协议 么
`ping   + 6000    www.baidu.com`
发送 6000    block 大小的一个包，来测试网络连接时延
`ifconfig -a `
查看网卡信息；eth0是第一块网卡  lo 是回环网卡；
`netstat -anp`
监控网络状态，端口号，哪个进程监听的这个端口啊，等等！
`traceroute  +域名/主机 IP `
追踪路由route -n：显示本机路由表
`dig domain`  获取domain的DNS信息
`dig -x host`  逆向查询host
`wget file`  下载file
`wget -c file`  断点续传file


## 挂载命令

- `mount` 直接回车 显示当前已经挂载的盘

```bash
/dev/sda3 on / type ext4 (rw)
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
devpts on /dev/pts type devpts (rw,gid=5,mode=620)
tmpfs on /dev/shm type tmpfs (rw,rootcontext="system_u:object_r:tmpfs_t:s0")
/dev/sda1 on /boot type ext4 (rw)
none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)
```

- `mount -a` 将`/etc/fstab`自动挂载设备再挂载一遍
- `mount [-t] [-o] 设备文件名 挂载点`
- -t 文件系统 ext3 ext4 iso9660
- -o 特殊选项

```bash
# 开机自动挂载
[cky@localhost ~]$ cat /etc/fstab

UUID=a9555e9b-6dbc-446b-b919-3ae2ba3a36c9 /                       ext4    defaults        1 1
UUID=1b581ee5-8dbd-4da0-8ea5-6d69e7936e58 /boot                   ext4    defaults        1 2
UUID=c56751cf-0688-4cdc-9304-749c886af943 swap                    swap    defaults        0 0
tmpfs                   /dev/shm                tmpfs   defaults        0 0
devpts                  /dev/pts                devpts  gid=5,mode=620  0 0
sysfs                   /sys                    sysfs   defaults        0 0
proc                    /proc                   proc    defaults        0 0
```

### 查询某个文件的所有git提交记录详情

```bash
git log mcs_db_install.sql | grep commit | awk '{print "git show " $2}' | sh >> mcs_db_install-git-show-log
```

### 统计某个文件夹下所有.php文件中代码行数

```bash
find ./ -name "*.php"|xargs cat|grep -v ^$|wc -l
```

### 删除windows系统编辑文本产生的不可见字符`^M`

```bash
touch love_tmp.c
sed 's/^M//' $1 > love_tmp.c
mv love_tmp.c $1
```
操作符	说明	举例

`^M` 的输入方法为 `Ctrl + v` 再加上 `Ctrl + m`
`cat -v love.c` 可用来查看一个文件，特殊字符也会显示出来

# tail
```bash
#  动态显示文件的倒数20行 默认是10行 用于监视日志文件挺好的
tail -n20 -f php_errors.log 
```

# mount
``` bash
shell git:(master)mount  查看系统的挂载情况
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=4005816k,nr_inodes=1001454,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=805652k,mode=755)
/dev/sda2 on / type ext4 (rw,relatime,errors=remount-ro,data=ordered)
```
- `mount -t vfat /dev/sdb1  /media/disk` , 挂载u盘`/dev/sdb1`到 `/media/disk`,并且以`vfat`文件系统格式读取
- `mount -t iso9660 -o loop  MEPIS-KDE4-LIVE-DVD_32.iso   mnt` 直接将一个iso文件挂载到`mnt`路径下面


# umount
- `umount [directory | device]` 卸载已经挂载的设备
- `lsof [directory | device]` 卸载之前看看有没有文件被进程占用，有的话要先关闭该进程

## 临时文件与目录

```bash
tempname=`mktemp` # 创建一个临时文件在 /tmp 里，这里的文件在系统重启后会被自动删除
echo $tempname
/tmp/tmp.pRnrAkX65n

tempdir=`mktemp -d` # 创建一个临时目录
echo $tempdir
/tmp/tmp.qjWG3jW1VT
```

## 将文件切成小块

```bash
split -b 2k data.file                     # 给它切成 2k 一个的大小
split -b 3k data.file -d -a 4 splite_file # 指定前缀是splite_file, 编码是 4位整数，如 splite_file0000
split -l 1000 data.file                   # 切成 1000 行的块
```

# dd
```bash
# 生成固定大小填充的文件
cky@cky-pc:~/workspace/shell/dd$ dd if=/dev/zero of=junk.data bs=1M count=1
记录了1+0 的读入
记录了1+0 的写出
1048576 bytes (1.0 MB, 1.0 MiB) copied, 0.00211968 s, 495 MB/s

cky@cky-pc:~/workspace/shell/dd$ ls -lhi
总用量 1.0M
20191053 -rw-r--r-- 1 cky cky 1.0M 7月   2 12:35 junk.data

# if 不指定，默认从stdin读入
# of 不指定，默认输出到stdout
# bs blocksize 块大小
# count 块个数
# 文件大小 = bs x count
```

# comm 比较两个文件
```bash
cky@cky-pc:~/workspace/shell/comm$ cat A.txt 
apple
gold
iron
orange
silver
steel

cky@cky-pc:~/workspace/shell/comm$ cat B.txt 
carrot
cookies
gold
orange

cky@cky-pc:~/workspace/shell/comm$ comm A.txt B.txt # 第1列为A文件 第二列为B文件 第三列为两者相同的行
apple
	carrot
	cookies
		gold
iron
		orange
silver
steel

cky@cky-pc:~/workspace/shell/comm$ comm A.txt B.txt -1 -2 # 不输出第1列，第2列
gold
orange

# 通过改变输出的列来 或取两个文件之间的 并集 ，交集，差集
cky@cky-pc:~/workspace/shell/comm$ comm A.txt B.txt | sed 's/^\t*//' #　并集
apple
carrot
cookies
gold
iron
orange
silver
steel

cky@cky-pc:~/workspace/shell/comm$ comm A.txt B.txt -1 -2 | sed 's/^\t*//' # 交集
gold
orange

cky@cky-pc:~/workspace/shell/comm$ comm A.txt B.txt -1 -3 | sed 's/^\t*//' # B - A
carrot
cookies

cky@cky-pc:~/workspace/shell/comm$ comm A.txt B.txt -2 -3 | sed 's/^\t*//' # A - B
apple
iron
silver
steel
```

# 开启启动服务
- 标准启动运行级别 3
- 开心图形化界面的运行级别 5
- ubuntu 开机启动脚本在 /etc/rcX.d/目录下， X 是运行级别, 标准Linux 在 /etc/inittab 文件中
```bash
ls -alh /etc/rc5.d
总用量 16K
drwxr-xr-x   2 root root 4.0K 5月  28 15:38 .
drwxr-xr-x 147 root root  12K 6月  12 17:07 ..
lrwxrwxrwx   1 root root   15 1月  14 23:39 S01acpid -> ../init.d/acpid
lrwxrwxrwx   1 root root   17 1月  14 23:39 S01anacron -> ../init.d/anacron
lrwxrwxrwx   1 root root   16 1月  14 23:39 S01apport -> ../init.d/apport
lrwxrwxrwx   1 root root   22 1月  14 23:39 S01avahi-daemon -> ../init.d/avahi-daemon
...
```

# 硬件设备管理
- 字符型设备文件，调制解调器，终端
- 块设备文件,硬盘
- 网络设备文件,采用数据包发送和接受数据的设备，比如各种网卡和特殊的回环设备
```bash
cd /dev
/dev ls -alh sda* tty*
                     主设备号 次设备号
brw-rw---- 1 root disk    8,  0 6月  11 14:09 sda  块设备
brw-rw---- 1 root disk    8,  1 6月  11 14:09 sda1
brw-rw---- 1 root disk    8,  2 6月  11 14:09 sda2
brw-rw---- 1 root disk    8,  3 6月  11 14:09 sda3
crw-rw-rw- 1 root tty     5,  0 6月  14 14:24 tty 字符设备
crw--w---- 1 root tty     4,  0 6月  11 14:09 tty0
crw--w---- 1 root tty     4,  1 6月  11 14:09 tty1
...
```

# 终端模拟器
- 哑终端--->Linux控制台--->终端模拟包--->
- 字符集：将二进制字符代码转化成字符发送给显示器显示，ascii ios unicode
- 控制码: 控制光标在显示器上的显示位置，如回车 换行 水平制表符 方向键 翻页键 清空控制台
- 块模式图形:
- 矢量图形:
- 显示缓冲: 1.滚动缓冲 2.替代缓冲
- 色彩:
- 键盘: 终端模拟包需要实现键盘模拟, 中断 ，滚动锁定 ， 重复 ，返回 ， 删除 ，方向键 ，功能键
- terminfo数据库: 是一组文件，标识了各种可以用在linux系统上的终端的特性，常见路径`/usr/share/terminfo` `/etc/terminfo` `/lib/terminfo`

```bash
cd /lib/terminfo/v
v ls
vt100  vt102  vt220  vt52
v infocmp vt100  列出终端定义的功能，以及用来模拟每个功能的控制码
#	Reconstructed via infocmp from file: /lib/terminfo/v/vt100
vt100|vt100-am|dec vt100 (w/advanced video),
	am, mc5i, msgr, xenl, xon,
	cols#80, it#8, lines#24, vt#3,
	acsc=``aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,
...
```

- 查看shell会话使用哪个终端模拟设置
- 虚拟控制台: 现代Linux启动时，会自动创建几个虚拟控制台，它是Linux内存中的终端会话，`Ctrl + Alt + [F1~F8]`来切换各个虚拟控制台
- X Window 终端模拟包: Xterm Konsole Gnome-Terminal

```bash
echo $TERM
xterm-256color   说明终端类型设置为了 terminfo 数据库中的xterm条目
```

## yes

`yes "hscripts"`
上述命令将重复的显示hscripts直到按下热键终止它(CTRL+C)
当删除文件需要确认时，不用按键就删除文件:
`yes | rm -i *.txt`
在上述示例中，yes命令与带着rm命令管道运行 通常rm -i命令提示你删除文件, 你必须敲入y（是）或n（不）来删除文件 当与 yes 管道运行时， yes 的默认值将显示yes和所有将被自动删除的文件，因此你不需要对每个txt文件敲入y来删除它
`yes n | rm -i *.txt`
在上述示例中，当 rm -i 确认删除文件的时候，敲入n代表not不删除文件

# updatedb

- 更新内置数据库 `/var/lib/mlocate`
- `locate  host`  基于内置文件数据库查找带有host字符的文件 遵循配置文件规则

```bash
# /etc/updatedb.conf
PRUNE_BIND_MOUNTS_ = "yes" # 开启搜索限制
PRUNEFS = # 搜索时 不搜索的文件系统
PRUNENAMES = # 搜索时 不搜索的文件类型
PRUNEPATHS = # 搜索时 不搜索的文件路径
```


## 文件相关命令

```bash
file main.c     # 查看文件类型
stat file.txt   # 查看一个文件的详细情况
objdump -x cky  # 打印 ELF 文件的基本段信息
objdump -sd cky # 16进制打印并且将包含指令的段反汇编
size cky        # 查看代码段 数据段 和 BSS段 的长度
readelf -h cky  # 查看 ELF 文件头
readelf -S cky  # 查看段表
nm cky          # 查看 ELF 文件的符号表
readelf -s cky  # 查看 ELF 文件的符号表
readelf -l cky  # 查看程序被装载时 可执行文件与进程虚拟空间映射关系
hexdump -C cky  # 十六进制输出文件
```
# Bash命令

我积累的 Bash 命令。

## 常识

#### 通配符

```bash
*                     代表任意字符串
?                     代表一个字符
[abcd]                代表从a, b, c, d选字符
[!abcd]               代表除这些字符串之外任意字符
[1-9]                 匹配1到9
[a-z]                 表示a到z
ls my_{finger,toe}s   匹配 my_fingers my_toes
```

#### 终端快捷健

```bash
Tab 自动补充
Ctrl + a 到正在输入的命令行的头部
Ctrl + e 到正在输入的命令行的尾部
Ctrl + c 终止当前进程
Ctrl + k 删除光标后的所有字符
```

#### 信号

```bash
Ctrl + z        # HUP 挂起当前进程
Ctrl + c        # INT 中断当前进程
$ kill -l       # 列出所有信号
kill -9 PID     # 给 PID 进程发送信号 9 KILL 
kill -QUIT PID  # QUIT信号、TERM 软件终止信号
```

#### 终端设置

```bash
stty -a           # 以容易阅读的方式打印当前的所有配置
stty -echo        # 设置终端不要回显
stty echo         # 终端恢复回显
stty iuclc        # 禁止大写  -iuclc 恢复
stty olcuc        # 禁止小写  -olcuc 恢复
stty size         #  打印出终端的行数和列数
stty eof "string" # 系统默认是Ctrl+D来表示文件的结束，而通过这种方法，可以改变！
stty igncr        # 忽略回车符 -igncr 恢复
```

#### 命令别名

在脚本中默认不开启，所以不可以使用别名。

```bash
# `./xxx.sh`运行shell脚本,，alias别名无效，`source`和`.`方式是起有效的，因为是在当前shell运行
alias ls='ls --color=auto';
alias rm='rm() { mv $@ ~/backup/; };rm' # 配合函数，使用alias命令,将危险的rm命令，替换成mv命令
```

#### 搜索

```bash
$ whereis gcc                   
$ sudo updatedb && locate gcc
```

## 文件

### 文件权限

```bash
chmod  [-R] 777             /var/home/www # 改变文件/目录权限 -R是递归
chown  [-R] caokaiyan       /var/home/www # 改变文件所有者
chown  [-R] caokaiyan:admin /var/home/www # 同时改变文件所有者和用户组
chgrp  [-R] admin           /var/home/www # 改变用户组
ls  -aldh  /root                  # 显示/root下所有文件
pwd                               # 显示当前目录
umask                             # 查看当前值
umask 022                         # 设置值
touch  test.c                     # 创建新文件  默认权限 666 - umask 值 比如 666 - 022 = 644
mkdir -p    /var/www/advanced     # 递归创建目录    默认权限 777 - umask 值
rm    -rf    /mydir               # 强制删除/mydir目录和里面的文件
cp  test.c   /root/test.c         # 复制文件
cp  -r /var/www/abc  /var/www/dcf # 复制目录 -a 是复制文件与原文件一模一样
mv  test.c  /root/test1.c         # 移动文件  (移动和复制都是有改名的效果的)
mv  /var/www/abc/  /root/def/     # 移动目录
more  Myfile                      # 分页查看文件内容，空格：下一页，enter：下一行，q：退出
tail -f debug.log                 # 动态监看日志
ln source.txt  /var/target.txt      # 创建硬链接
ln -s source.txt  /var/target.txt   # 创建软连接
sleep 1                             # 休眠 1 s
date +%s                            # 返回时间戳
date +%Y_%m_%d_%H_%M_%S             # 返回 年_月_日_时_分_秒
```

### cat 拼接输入以及文件

```bash
cat file1 file2 file3                       # 拼接输出多个文件
echo 'text through stdin' | cat - file.txt  # 将输入stdin和file.txt拼接起来， - 是stdin文本的文件名
cat -s multi_blanks.txt                     # 压缩相邻的空行
cat -n lines.txt                            # 为每一行加上行号后输出
```

### xargs 将输入转化为命令行参数

- 有些命令只能以命令行参数的形式接受收据，而无法通过stdin接受数据流。在这种情况下，我们没法用管道来提供那些只有通过命令行参数才能提供的数据, xargs擅长将标准输入数据转换成命令行参数
- -d 选项，指明定界符, 默认将空格作为定界符,xargs没有指定参数时，默认能将换行符替换成空格, `-0` 将 null 作为界定符
- -n 选项，指明每行最大的参数数量
- -I 指定替换字符串
- 很多文件名中都可能会包含空格符，而xargs很可能会误认为它们是定界符(例如，hell text.txt会被xargs误认为hell和text.txt)
- xargs 不能为多组命令提供参数

#### 基础

```bash
echo "splitXsplitXsplitXsplit" | xargs -dX -n2
split split
split split
```

```bash
#!/bin/bash
echo '处理' $*
```

```
$ echo "aaa bbb ccc" | xargs -n1 cecho.sh
处理 aaa
处理 bbb
处理 ccc
```

```bash
find . -type f -name "*.txt" | xargs -0 rm -f   # 将找到的 txt 文件删除

$ cat args.txt | xargs -I{} cecho.sh -p {} -l
处理 -p aaa -l
处理 -p bbb -l
处理 -p ccc -l

# 将找到的 sh 文件 拷贝到 sh_dir 文件夹中
find . -name '*.sh' | xargs -I {} cp {} sh_dir

# 统计 c 代码行数
find . -type f -name "*.c" | xargs -0 wc -l
```

```bash
dirs          # 显示当前目录
enable 启用
eval
exec 用指定命令替换shell进程
fc 从历史记录中选择一条命令
fg %2 恢复后台作业到前台
getopts
hash 内置hash表，建立到PATH路径下面的路径的直接链接
history 显示命令历史记录
kill -n PID 向进程发送信号
let 计算数学表达式
logout 退出shell登录
popd 从目录栈中删除记录
pushd 向目录栈添加记录
set 设置/显示环境变量　和 shell特性
shift 将参数位置前移一位
shopt 打开/关闭shell可选行为的变量值
suspend 暂停shell的执行，直到收到SIGCONT
times 显示累计的用户时间和系统时间
trap 如果收到了指定的系统信号，执行指定的命令
type 查看命令类型
ulimit 给用户指定的资源设置上限
unset 删除变量
wait 等待指定进程完成，并返回退出状态码
```

## 文件查找与文件列表

```bash
find 目录 选项                                   

find /etc                                # 列出 /etc 下所有路径
find /etc -iname "*.log"                 # 通配符     过滤出符合条件的路径
find /etc -iregex ".*\(\.py | \.sh\)$"   # 正则表达式 过滤出符合条件的路径
find /etc -maxdepth 1 -name 'f*'         # 遍历深度，到当前子目录，不再往下遍历
find /etc -mtime -10                     # 10天内修改；   +10 十天前修改
find /etc -min -30                       # 30分钟内修改； +30 30分钟前修改
find /etc -user cky                      # 指定用户
find /etc -type f                        # 指定 路径为 普通文件类型，d 目录类型
find /etc -size +20M -a -size -50M       # -a : and , 20M ~ 50M 之间的文件
find /etc -size -20k -o -size +50k       # -o : or  , 小于 20k 或 大于 50k
find /etc -perm 644                      # 指定权限644
find . \( -name '.git' -prune \) -o -type f  # 跳过 .git 目录, 过滤出普通文件

# 对找到的每一条路径 都 执行操作，{} 指代路径名
find . -name "*.swp" -exec rm {} \;          # 将找到的文件全部删除
find . -user root    -exec chown cky {} \;   # 将匹配的文件，修改它们用户名为 cky
find . -name '*.sh'  -exec cp {} copy.sh \;  # 将查询到的所有文件都拷贝到 copy.sh 中
```

## 加密 解密

### md5sum 和 sha1sum 单向散列加密

```bash
md5sum cky.sh > cky.md5 # 将校验值存入文件
md5sum -c cky.md5       # 检验文件是否完整
cky.sh: 成功
```

### md5deep

```bash
sudo apt install hashdeep # 安装
mkdir md5_dir
touch md5_dir/aaa.txt
touch md5_dir/bbb.txt
echo "asdf bb cc" > md5_dir/ccc.txt
md5deep -r1 md5_dir > md5_dir.md5

md5deep -rl md5_dir > md5_dir.md5
cat md5_dir.md5
d41d8cd98f00b204e9800998ecf8427e  md5_dir/aaa.txt
d41d8cd98f00b204e9800998ecf8427e  md5_dir/bbb.txt
ae7a125ed9b9ea27e7d299386c48e816  md5_dir/ccc.txt

md5sum -c md5_dir.md5   # 计算校验和
md5_dir/aaa.txt: 成功
md5_dir/bbb.txt: 成功
md5_dir/ccc.txt: 成功
```

### crypt 加密

```bash
crypt cky951010 < cky.sh > cky_crypt
程序“crypt”尚未安装 您可以使用以下命令安装：
sudo apt install mcrypt
sudo apt-get install mcrypt

crypt cky951010 < cky.sh > cky_crypt # 使用口令给文件内容加密，加密后的文件是密文
crypt cky951010 -d <cky_crypt >cky_crypt_coutput.txt # 解密
```

### gpg 生成签名

```bash
gpg -c cky.sh # 生成签名，采用交互式读取口令
ls |grep gpg
cky.sh.gpg

gpg cky.sh.gpg
gpg: AES 加密过的数据
gpg: 以 1 个密码加密
File 'cky.sh' exists. 是否覆盖？(y/N) y
```

### base64

```bash
base64 cky.sh > cky.sh.base64   # base64 加密
base64 -d cky.sh.base64         # base64 解密
```

## 压缩 解压

```bash
bzip2 -k cky              # 压缩cky文件为.bz2文件，-k 保留源文件
bunzip2 cky.bz2           # 解压文件

gzip cky                  # 压缩cky文件为.gz文件
gzip -d cky.gz            # 解压文件

zip -r src.zip src/       # 递归压缩 src/ 目录下的文件 为 src.zip
unzip src.zip             # 解压

tar -zcvf cky.tar.gz cky  # 归档压缩
tar -zxvf cky.tar.gz      # 解压到当前目录
```

## 网络通信命令

```bash
ping blog.codekissyoung.com     # 坚持网络连通性
ping 127.0.0.1                  # 检测自己机器安装了tip/ip 协议
ifconfig -a                     # 查看网卡信息
traceroute www.baidu.com        # 追踪本机到目标的路由
netstat [-anp | -nat]           # 查看本机端口监听情况
route -n                        # 显示本机路由表
dig www.codekissyoung.com       # 获取域名的 DNS 信息
dig -x 101.200.144.41           # 逆向查询 host 信息
wget -c                         # 下载 file 断点续传
```


### 查询某个文件的所有git提交记录详情

```bash
git log mcs_db_install.sql | grep commit | awk '{print "git show " $2}' | sh >> mcs_db_install-git-show-log
```

### 统计某个文件夹下所有.php文件中代码行数

```bash
find ./ -name "*.php"|xargs cat|grep -v ^$|wc -l
```

### 删除windows系统编辑文本产生的不可见字符`^M`

```bash
touch love_tmp.c
sed 's/^M//' $1 > love_tmp.c
mv love_tmp.c $1
```
操作符	说明	举例

`^M` 的输入方法为 `Ctrl + v` 再加上 `Ctrl + m`
`cat -v love.c` 可用来查看一个文件，特殊字符也会显示出来

# tail
```bash
tail -n20 -f php_errors.log  # 动态显示文件的倒数20行 默认是10行 用于监视日志文件挺好的
```

``` bash
$ mount [-t] [-o] 设备文件名 挂载点
$ mount                                          # 查看系统的挂载情况
$ cat /etc/fstab                                 # 查看开机自动挂载的项
$ mount -t vfat /dev/sdb1  /media/disk           # 以vfat 格式 挂载u盘/dev/sdb1 到 /media/disk
$ mount -t iso9660 -o loop  LIVE-DVD_32.iso mnt  # 将一个iso文件挂载到 mnt 路径下面
$ umount [directory | device]                    # 卸载已经挂载的设备
$ lsof [directory | device]                      # 卸载之前看看有没有文件被进程占用，有的话要先关闭该进程
```

## 临时文件与目录

```bash
tempname=$(mktemp)      # 创建一个临时文件在 /tmp 里，这里的文件在系统重启后会被自动删除
tempdir=$(mktemp -d)    # 创建一个临时目录
```

## 将文件切成小块

```bash
split -b 2k data.file                     # 给它切成 2k 一个的大小
split -b 3k data.file -d -a 4 splite_file # 指定前缀是splite_file, 编码是 4位整数，如 splite_file0000
split -l 1000 data.file                   # 切成 1000 行的块
```

# dd
```bash
$ dd if=/dev/zero of=file.txt bs=1M count=1 # 生成固定大小填充的文件 
```

# comm 比较两个文件
```bash
cky@cky-pc:~/workspace/shell/comm$ cat A.txt 
apple
gold
iron
orange
silver
steel

cky@cky-pc:~/workspace/shell/comm$ cat B.txt 
carrot
cookies
gold
orange

cky@cky-pc:~/workspace/shell/comm$ comm A.txt B.txt # 第1列为A文件 第二列为B文件 第三列为两者相同的行
apple
	carrot
	cookies
		gold
iron
		orange
silver
steel

cky@cky-pc:~/workspace/shell/comm$ comm A.txt B.txt -1 -2 # 不输出第1列，第2列
gold
orange

# 通过改变输出的列来 或取两个文件之间的 并集 ，交集，差集
cky@cky-pc:~/workspace/shell/comm$ comm A.txt B.txt | sed 's/^\t*//' #　并集
apple
carrot
cookies
gold
iron
orange
silver
steel

cky@cky-pc:~/workspace/shell/comm$ comm A.txt B.txt -1 -2 | sed 's/^\t*//' # 交集
gold
orange

cky@cky-pc:~/workspace/shell/comm$ comm A.txt B.txt -1 -3 | sed 's/^\t*//' # B - A
carrot
cookies

cky@cky-pc:~/workspace/shell/comm$ comm A.txt B.txt -2 -3 | sed 's/^\t*//' # A - B
apple
iron
silver
steel
```

## yes

`yes "hscripts"`
上述命令将重复的显示hscripts直到按下热键终止它(CTRL+C)
当删除文件需要确认时，不用按键就删除文件:
`yes | rm -i *.txt`
在上述示例中，yes命令与带着rm命令管道运行 通常rm -i命令提示你删除文件, 你必须敲入y（是）或n（不）来删除文件 当与 yes 管道运行时， yes 的默认值将显示yes和所有将被自动删除的文件，因此你不需要对每个txt文件敲入y来删除它
`yes n | rm -i *.txt`
在上述示例中，当 rm -i 确认删除文件的时候，敲入n代表not不删除文件

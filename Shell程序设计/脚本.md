# shell脚本教程

- 如果读取到一个Enter符号，就尝试执行该行命令
- 如果一行代码太多，可以用[enter]来进行扩展
- `#` 作为注释
- 在 shell 程序设计里，返回 0 表示执行成功

## 变量

- 声明/赋值: `变量=值`, `=` 两边绝对不能有空格,默认情况下，所有的变量都以字符串来存储，即使它是数值
- `${变量名}` 是引用变量的意思,`{}` 用来界定变量名的字符串范围, 推荐使用 `"${var}"` 格式来使用变量，以防止 `if [ ${var} = "yes" ]` 中, 变量为空时，语法报错
- `>` 作为大于号时要转义，否则默认作为重定向处理
- `read` 可以与用户交互，读取用户在shell里输入的字符串，存入变量中
- `declare` 是显式定义变量，但附带了很多可以选择的属性
- `${#var}` 获取变量的字符长度

```bash
testing=`date`                 # 声明或者赋值
declare [-aixr] var            # 声明变量类型 -a:数组，-i:整形，-x:效果同于export,-r:变量设置为readonly
read -p "请输入姓名 : " name   # 从外部读取用户输入

echo  "$testing"               # 输出 2018年 02月 13日 星期二 15:54:43 CST
echo  "当前时间:${testing} . " # 输出 当前时间是:2018年 02月 13日 星期二 15:54:43 CSTend
echo -e "您好 , ${name}"

unset testing                  # 删除该变量
```

### 环境变量

- 变量只能在当前shell使用，而使用`export var`可以提升为环境变量,供它的子shell使用
- `系统环境变量`是预定义在linux系统里的环境变量，每次运行shell的时候都可以直接访问和使用它们

```bash
# 将变量声明为环境变量 (全局变量)
export var

# 系统环境变量
echo "HOME : ${HOME}"; # 当前用户的家目录
echo "UID : ${UID}";  # 执行脚本的用户 UID
echo "USER : ${USER}"; # 执行脚本的用户的 用户名
echo "PS1 : ${PS1}"; # 命令提示符
echo "PS2 : ${PS2}"; # 命令二级提示符
echo "PATH : ${PATH}"; # 用以搜索命令的目录列表
echo "${SHELL}"            # 当前使用的 shell

export PATH="$PATH:/home/cky/bin" # 在PATH中添加一条新路径

# 检测 root 账号
if [ $UID -ne 0 ]; then
    echo "Root账号";
fi
```

### 特殊变量

- 执行一个脚本`./add 10 20`,在脚本里面, `$0`是脚本名, `$1` 是第一个参数 10，`$2`是第二个参数20,超过9的变量需要 `${10}` 这样子引用
- `$#` 是传递给脚本的参数个数 `$$` 是脚本运行的进程号
- `$*` 脚本所有参数，各个参数用`IFS`的第一个字符(一般是空格)分割开
- `$@` 该变量存全部参数作为一个字符串

```bash
# add
if [ -n "$1" ] && [ -n "$2" ] ;then
    echo $(( ${1} + ${2} )) # 这个是 shell 的算术计算 ，贼恶心
fi
```

### 用户输入 read

- -t 参数来限制用户的输入时间
- -s 无回显，常用于输入密码
- `read -p"提示语句"`
- `read -d ":" var` 以 `:` 作为输入行的结束

```bash
read -t3 -p"do you love me ? ( Y / N ) : " answer
```

### IFS 输入域分隔符

- IFS是系统环境变量,当shell读取输入时，`IFS`用来分隔单词的一组字符，它们通常是空格、制表符和换行符;它也是数组里的项分隔符

```bash
data="name,sex,rollno,location"
IFS.OLD=$IFS
IFS=,               # 将IFS 设置为 ,
for item in $data;
do
    echo "item : $item"
done;
IFS=$IFS.OLD        # 恢复原值
```

## 数组

### 普通数组

```bash
array_var=(1 3 4 5 6 7 8 9) # 初始化
echo ${array_var[2]}        # 4

array_var2[6]="test something";
array_var2[7]="haaaa";
echo ${array_var2[6]}       # 输出某项值
echo ${array_var2[*]}       # 以各项隔开的形式输出全部值,
echo ${array_var2[@]}       # 把各项连起来作为一个字符串输出
echo ${#array_var2[*]}      # 数组元素个数
```

### 关联数组

```bash
declare -A ass_arr;     # 定义关联数组
ass_arr=([apple]='1.00' [orange]='3.00'); # 初始化赋值
ass_arr[banana]='4.00';                   # 单项赋值
echo "the price of apple is ${ass_arr[apple]}"; # 使用某项
echo ${!ass_arr[*]} # 以分隔的形式打印数组的全部索引
echo ${!ass_arr[@]} # 全部索引合成一个字符串打印
```

## 条件分支

### 判断命令是否成功

```bash
# 测试命令是否执行成功，根据 $? 的值来判断,$? = 0 则为真
if command; then
    echo "命令执行成功";
fi

# grep 没有搜寻到用户 $? = 1
if grep codekissyoung /etc/passwd; then
    echo "用户codekissyoung存在";
fi
```

### 测试条件是否满足

```bash
# 测试命令,test 可以进行数值比较，字符串比较，文件比较
if test condition; then
    command;
fi
# 简写
if [ condition ]; then  # [] 两边的空格是必要的
    commands;
fi

# 判断数字大小 只限于整数 , -gt 大于，-lt 小于
a=10;b=10
if [ $a -eq $b ]; then
   echo "a 等于 b"
fi

# 字符串比较 采用双中括号 可以避开很多错误
if [[ "code" == "cky" ]]      # 判断字符串相等 记住是用一个 = 来判断是否相等
if [[ "$USER" != "root" ]]    # 判定两个字符不相等
if [[ $var1 > $var2 ]]        # 字符串比较大小 根据字典序来判断, > 连转义都不需要了，因为双中括号
if [[ -n $var ]]              # 非空字符串
if [[ -z $PS1 ]]              # 是空字符串
if [[ -d file ]]              # 目录存在
if [[ -f file ]]              # 文件存在
if [[ -e $var ]]              # 文件存在
if [[ -w file ]]              # -r -w -x 判断文件是否 可读 可写 可执行
if [[ -O file ]]              # 判断执行者是否是文件的属主
if [[ -L $var ]]              # 是符号链接
if [[ file1 -nt file2 ]]      # file1 是否比 file2 更新, 镜像: file1 -ot file2
```

### && 与 || 组合条件

```bash
# 前面命令执行成功后，才执行后面命令
sudo service apache2  stop && sudo  service apache2  start
# 前面命令执行失败后，后面命令才执行
service apache2 restart || sudo service apache2 restart

if [[ -d $HOME ]] && [[ -w "$HOME" ]]; then
    echo "$HOME 存在并且可读";
fi
```

### 多分支 case

```bash
#!/bin/bash
read -p"is it morning? Please answer yes or not : " answer;
case "${answer}" in
    yes | y | Y | YES )
        echo "Good morning!";
        echo "Up bright and early this morning";
        ;;
    [nN]* )
        echo "Good Afternoon";
        echo "or night?";
        ;;
    * )
        echo "Wrong Answer, Please write yes or not ";
        exit 1;
        ;;
esac
```

## 循环

- 对于`for`循环中的`list`的字符串的解析，借助的是`$IFS`，而我们可以通过暂时修改`IFS`的值来改变我们的解析规则

```bash
# 格式
for var in list; do
    commands
done

# 普通字符串
list="abc bcd cdf"
for var in $list ; do
    echo "var : $var"
done

# 接命令
for var in `cat /etc/passwd`; do
    echo "$var";
done

# 接目录，遍历文件 in 后面可以跟多个目录,它们是通配符，空格隔开就好
for script in /etc/*.d /etc/*.conf; do
    echo $script
done

# c 语言形式的for , 使用 (( ))
for (( i=0; i<10; i++ ))
{
    commands;
}

# while 循环，条件符合就执行，[ condition; ] 逻辑与 条件分支 if 一样
while [ condition; ];do
    commands
done

# 跟while相反，条件符合才停止
until [ condition; ];do
    commands
done

# 跳出循环 都可以使用 break;
# 跳过这次循环 使用 continue;
# for while until 都可以使用
while [ condition; ];do
    if [ condition; ];then
        break; # 或者 continue
    fi
    commands;
done;

# 循环的重定向
for var in $lists; do
    commands;
done > output.txt # 可以选择将循环里面的输出的内容重定向到文件，

for var in $lists;do
    commands;
done | sort -nr   # 或者通过管道传递给其他命令

# 生成序列
for i in {a..z};do
    echo ${i}; # 输出 a b c d e f g h i j k l m n o p q r s t u v w x y z
done;
for i in {1..10};do
    echo ${i}; # 输出 1 2 3 4 5 6 7 8 9 10
done;
```

## 退出脚本

- 退出码 , `0` 是正常退出,错误码 `1 - 255`
- `echo $?` 输出上一个程序执行后的退出码

```bash
if [ "$i" -ne 1 ];then
    : # 该命令什么都不做，但执行后会返回一个正确的退出代码，即exit 0
else
    echo "$i is equal 1"
fi
exit 0
```

## 数学运算

### 简单的let

```bash
foo=4
bar=5
let result=foo+bar    # 加法
let foo++; let bar--; # 自加 自减
let foo+=6;
```

### $[ nu1 + nu2 ] 与 $(( nu1 + nu2 ))

- 注意 `[` `]` 的里面要有空格与变量隔开

```bash
foo=4
bar=5
echo $[ foo + bar ]
echo $(( foo + 50 ))
echo $[ $foo * ($bar - $foo) ]
```

### expr 计算器

```bash
#!/bin/bash
echo `expr 3 + 4`     # 计算 3 + 4
echo $(expr 5 \* 2)   # 计算 5 x 2 , 其中 * 需要转义
```

### 浮点数运算 bc

```bash
#!/bin/bash
var1=100
var2=45
echo `echo "scale=4; $var1 / $var2" | bc` # scale=4; 设置精度4位小数
echo $(echo "obase=2;ibase=10;$var2" | bc);      # 将 10 进制数变成 2进制数
echo $(echo "sqrt(100)" | bc)                    # 平方根
echo $(echo "10^10" | bc)                        # 乘方
```

## 调试

### bash 调试选项

- `-x` 显示实际执行的命令和参数，`+x` 禁止调试
- `-v` 当命令进行输入读取时，显示实际读取到的数据，`+v` 禁止打印输入
- 也可以在脚本开头 `#!/bin/bash -xv` 启用调试

```bash
#!/bin/bash
arr=(23 34 56 测试 第五个值 67 76 54 35)
echo ${arr[0]}
index=4
echo ${arr[$index]};
echo ${arr[*]}
echo ${arr[@]}
echo ${#arr[*]}
```

- 以下是实际运行情况

```shell
$ bash -x arr.sh

+ arr=(23 34 56 测试 第五个值 67 76 54 35)  # 带 + 号的输出，就是shell实际执行的命令
+ echo 23
23
+ index=4
+ echo 第五个值
第五个值
+ echo 23 34 56 测试 第五个值 67 76 54 35
23 34 56 测试 第五个值 67 76 54 35
+ echo 23 34 56 测试 第五个值 67 76 54 35
23 34 56 测试 第五个值 67 76 54 35
+ echo 9
9
```

### 调试部分代码

```bash
#!/bin/bash
arr=(23 34 56 测试 第五个值 67 76 54 35)
echo ${arr[0]}
index=4
echo ${arr[$index]};
set -x              # 调试开始
echo ${arr[*]}
echo ${arr[@]}
set +x              # 调试结束
echo ${#arr[*]}
```

## 函数

- shell命令执行时首先从函数开始，如果自定义了一个与内建命令同名的函数，那么就执行这个函数而非真正的内建命令，可以通过`\\Command`来强制使用内置命令
- `:(){:|:&}:` 这个是fork炸弹, : 是函数名，递归在后台调用自身，不断的fork进程，直到拖垮系统

```bash
function printit()  # 定义函数，其实不用 function 声明也可以
{
    echo "$1,$2";       # 打印第一个参数, 第二个参数
    echo "$@";          # 以列表的形式打印出所有的参数
    echo "$*";          # 所有的参数作为单个实体
    return 0;           # 返回值 0 为成功， 非 0 为错误
}

# 调用函数
printit arg1 arg2

# 在调用函数后，马上使用 $? 获取函数 return 的值, 0 表示成功
if [ $? -eq 0 ];
then
    echo "printit 执行成功";
fi

export -f printit;     # 导出函数为全局函数， 这样在子进程中，也能使用该函数了
```



# () 与 {}
- {} 和()类似，也是将多个命令组合在一起
- ()是在产生的子shell下执行，当在()中赋值的变量，影响的只是自身的子shell，而不能将该值赋给父shell
- {}是在当前的shell下执行，在{}中赋值的变量，因为就在当前的shell执行的，所以就能改变原来变量的值
- ()里面两边可以不使用空格，{}里面两边必须使用空格，且最后一个命令也需要以“；”结尾
```bash
➜  shell git:(master) ✗ A=123
➜  shell git:(master) ✗ (A=code;echo $A);echo $A
code
123
➜  shell git:(master) ✗ B=123
➜  shell git:(master) ✗ {B=code;echo $B};echo $B
code
code
```

# (())
- 专门用来做数值运算
```bash
➜  shell git:(master) ✗ ((i=1+99));echo $i
100
➜  shell git:(master) ✗ i=99;((i++));echo $i
100
➜  shell git:(master) ✗ echo $((2**3))
8
```

# [[]]
- 相当于 [] 的升级版
```
数字测试： -eq -ne -lt -le -gt -ge，[[ ]]同 [ ]一致
文件测试： -r、-l、-w、-x、-f、-d、-s、-nt、-ot，[[ ]]同 [ ]一致
字符串测试： > < =(同==) != -n -z，不可使用“<=”和“>=”，[[ ]]同 [ ]一致，但在[]中，>和<必须使用\进行转义，即\>和\<
逻辑测试： []为 -a -o ! [[ ]] 为&& || !
数学运算： [] 不可以使用 [[ ]]可以使用+ - * / %
组合： 均可用各自逻辑符号连接的数字（运算）测试、文件测试、字符测试
```

# 普通数组
```bash
#!/bin/bash
arr=(23 34 56 测试 第五个值 67 76 54 35) 
echo ${arr[0]}
index=4
echo ${arr[$index]};
echo ${arr[*]}
echo ${arr[@]}
echo ${#arr[*]} # 数组个数
# 23
# 第五个值
# 23 34 56 测试 第五个值 67 76 54 35
# 23 34 56 测试 第五个值 67 76 54 35
# 9
```

# 关联数组 (Bash 4.0引入)
```bash
#!/bin/bash
declare -A ass_arr; # 定义
ass_arr=([apple]='1.00' [orange]='3.00'); # 初始化
ass_arr[banana]='4.00'; # 单个赋值
echo "the price of apple is ${ass_arr[apple]}"; # 使用索引数组
echo ${!ass_arr[*]} # 获取所有的索引
echo ${!ass_arr[@]} # 同上
# the price of apple is 1.00
# apple banana orange
# apple banana orange
```


# basename
- 从路径里面获取脚本名称
```bash
name=`basename $0`
echo $name # my_shell_script
```

# shift
- shift 命令将参数左移动，$1的原先的值丢弃，$2的值变为$1的值，依次类推
```bash
while [ -n "$1" ]; do
    commands;
    shift
done
```

# 依次处理每个参数
```bash
while [ -n "$1" ] ;do
    case "$1" in
    first)
        echo "first 参数";;
    second)
        echo "second 参数";;
    third)
        echo "third 参数";;
    *)
        echo "处理其他参数";;
    esac
    shift
done
```

# 依次处理每个带值的参数
```bash
while [ -n "$1" ] ;do
    case "$1" in
        cut)
            # 获取cut后面的值
            value="$2";
            echo "cut处理$2";
            shift;;
        add)
            echo "add 参数";;
        *)
            echo "其他参数";
    esac
    shift
done
```

# `$`符号
```bash
# eval 将字符串当做命令执行
```bash
cky@cky-pc:~/workspace/shell$ NAME=codekissyoung
cky@cky-pc:~/workspace/shell$ eval echo $NAME # 等价于 echo $NAME
```


# 变量类型
- 全局环境变量，在当前shell可用，子shell也会继承父shell的环境变量
- 当前shell局部变量,子shell不能访问到
- 函数局部变量，只在函数内部能访问到

# 常用的环境变量
```bash
PATH            决定了shell将到哪些目录中寻找命令或程序
ROOTPATH        这个变量的功能和PATH相同，但它只罗列出超级用户（root）键入命令时所需检查的目录。
HOME            当前用户主目录
USER            查看当前的用户
LOGNAME         查看当前用户的登录名。
UID             当前用户的识别字，取值是由数位构成的字串。
SHELL           是指当前用户用的是哪种Shell。
TERM            终端的类型。
PWD             当前工作目录的绝对路径名，该变量的取值随cd命令的使用而变化。
MAIL            是指当前用户的邮件存放目录。
HISTSIZE        是指保存历史命令记录的条数
HOSTNAME        是指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的。
PS1             是基本提示符，对于root用户是#，对于普通用户是$，也可以使用一些更复杂的值。
PS2             是附属提示符，默认是">"。可以通过修改此环境变量来修改当前的命令符
```

# printenv
- 打印出当前shell的全局环境变量
- 全局环境变量在当前shell会话的子进程中也是可见的，局部变量只在当前shell可见

```bash
➜  ~ printenv
XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat0
XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg
LC_TELEPHONE=zh_CN.UTF-8
LANG=zh_CN.UTF-8
...
➜  ~ echo $HOME  输出全局变量
/home/cky
```


# set
- 输出当前进程的所有变量
```bash
cky@cky-pc:~/workspace/shell$ set
BASH=/bin/bash
BASHOPTS=checkwinsize
...
```

# 设置局部变量
- 注意 等号两边都不能有空格，有空格的话，shell会把test当做命令来处理

```bash
➜  ~ test='设置局部变量'
➜  ~ echo $test
设置局部变量
```

# 设置全局变量
```bash
➜  shell git:(master) ✗ export test
➜  shell git:(master) ✗ cat echo_test
#!/bin/bash
echo $test
➜  shell git:(master) ✗ ./echo_test
设置局部变量
```

# 删除变量
- 局部变量删除就删除了，但是在子进程中删除全局变量，并不影响父进程中的该全局变量

```bash
➜  shell git:(master) ✗ unset test
➜  shell git:(master) ✗ echo $test

➜  shell git:(master) ✗
```

# 重定向
```bash
#!/bin/bash
# 在workspace目录下面查找 read.sh , 错误输出重定向到标准输出，然后再一起重定向到find.log
find /home/cky/workspace read.sh > find.log 2>&1
find /home/cky/workspace read.sh >& find.log　# 同上面功能一样　简写版
```



# 自定义文件描述符的使用
```bash
cky@cky-pc:~/workspace/shell$ exec 3<input.txt
-bash: input.txt: 没有那个文件或目录
cky@cky-pc:~/workspace/shell$ echo "test input" > input.txt
cky@cky-pc:~/workspace/shell$ exec 3<input.txt # 定义文件描述符3 (读取)
cky@cky-pc:~/workspace/shell$ cat <&3 # 使用
test input

cky@cky-pc:~/workspace/shell$ exec 4>output.txt  # 创建 截断写入模式 文件描述符
cky@cky-pc:~/workspace/shell$ echo "test file disc 4" >&4 # 使用
cky@cky-pc:~/workspace/shell$ cat output.txt
test file disc 4

cky@cky-pc:~/workspace/shell$ exec 5>> input.txt # 创建 追加写入模式 文件描述符
cky@cky-pc:~/workspace/shell$ echo "file disc 5 test" >&5 # 使用
cky@cky-pc:~/workspace/shell$ cat input.txt
test input
file disc 5 test
```

# `-` 作为stdin文本的文件名
```bash
cky@cky-pc:~/workspace/shell$ echo 'text from stdin' | cat hi.txt -
hi code!
text from stdin
```



# 交互输入自动化
```bash
cky@cky-pc:~/workspace/shell$ ./auto_input.sh
Enter your name:codekissyoung
Enter your age 22
your name is codekissyoung , you are 22 years old
cky@cky-pc:~/workspace/shell$ echo 'codekissyoung\n22\n' | ./auto_input.sh
your name is codekissyoungn22n , you are  years old

# 使用 expect
cky@cky-pc:~/workspace/shell$ sudo apt-get install expect

cky@cky-pc:~/workspace/shell$ cat ./expect.sh
#!/usr/bin/expect
spawn ./auto_input.sh; # 指定要自动化哪一个命令
expect "Enter your name:"; # 如果匹配这个提示，那就输入codekissyoung
send "codekissyoung\n"; # 发送给命令的信息
expect "Enter your age:" # 如果匹配这个提示，那就输入 22
send "22\n"
expect eof # 交互结束

cky@cky-pc:~/workspace/shell$ ./expect.sh
spawn ./auto_input.sh
Enter your name:codekissyoung
Enter your age:22
your name is codekissyoung , you are 22 years old
```





```bash
cky@cky-pc:~/workspace/shell$ ./arr.sh 
23
第五个值
+ echo 23 34 56 测试 第五个值 67 76 54 35
23 34 56 测试 第五个值 67 76 54 35
+ echo 23 34 56 测试 第五个值 67 76 54 35
23 34 56 测试 第五个值 67 76 54 35
+ set +x
9
```

# shell开头设置
```bash
#!/bin/bash -xv
```

# 判断root用户
```bash
#!/bin/bash
if [ $UID -ne 0 ]; then
	echo "not root user";
else 
	echo "Root User";
fi
```

# 字符串长度
```bash
➜  shell git:(master) var=122131213122sfsfsdfd
➜  shell git:(master) echo ${#var}
20
```

# 字符串比较
- `[[ $a==$b ]]`相等
- `[[ $a!=$b ]]`不等
- `[[ $a>$b ]]`字符序大
- `[[ $a>$b ]]`字符序小
- `[[ -z $a ]]`空字符串
- `[[ -n $a ]]`非空字符串
- `if [[ -z $a ]] && [[ -n $b ]]`将多个条件组合起来 

# 获取文件名 获取后缀名
```bash
file="example.jpg"
name=${file%%.*} # 获取文件名
ext=${file##*.} # 获取后缀名

URL="www.google.com"
echo ${URL%.*} # www.google
echo ${URL%%.*} # www
echo ${URL#*.} # google.com
echo ${URL##*.} # com
```
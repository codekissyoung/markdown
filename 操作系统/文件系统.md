# 文件系统

## 存储的抽象概念

### 硬件抽象:块

第一层抽象：从一块完整磁盘到分区，每个分区可视为一块磁盘

第二层抽象：每个分区切成等份的小块(512B or 4K),从0开始编号

![image-20220313174256725](https://img.codekissyoung.com/2022/03/13/73bf40712aaf24938463b86f9c057843.png)

第三层抽象: 对编号进行区域划分（文件系统决定的）,从这一步开始就是不同文件系统发挥了

- Ext2(Linux): superblock + inode table + data area
- FAT, NTFS(Windows): 略

![image-20220317203533056](https://img.codekissyoung.com/2022/03/17/7db341f2df00982125ab309b61a9958f.png)

### Linux存储抽象:文件

**superblock**：文件系统本身结构信息 ( file system type 、the size of each area )

**inode table**：单个文件的属性 (size、owner 、last modified time 、sequence of data area blocks)

> This is important：Each inode is identified by its position in the inode table. For example， inode 2 is the third struct in the inode table of the filesystem.

**data area**：data content

总结: Linux文件 = 文件系统类型 + inode (存储属性) + data(存储实际内容)

> Files are entries in the inode table with contents stored in the data region.

#### 大文件存储

每个inode结构的大小是固定的，它是如何做到存储有大量 data block 的文件的？

![image-20220319203231838](https://img.codekissyoung.com/2022/03/19/c8db8ae124e2f0c2921f7f8382b9e36b.png)

参考1: 三级间接存储法

### 管理抽象:目录

- 目录是一种特殊的文件，它的内容是其他文件和目录的列表
- the names in a directory refer to files and to other directories

![image-20220323155803485](https://img.codekissyoung.com/2022/03/23/a83abfa5729318784b9258c7c093e08f.png)

”文件在目录中“ 如何理解?

> Directories contain references to files. Each of these references is called `link` (contains a i-node number and a filename). it is a entry to the real file.

“目录包含子目录” 如何理解？

> It means that parent directory cantains a link to the inode for that subdirectory.

”.“ 如何理解？

> Every directory has an link `.` for its own inode. the kernel installs it when create a directory. 

“..” 如何理解? 

> Dotdot is a reserved link to subdirectory’s parent directory. the kernel installs it when create a directory. Root `/` directory‘s dotdot entry is a references to itself.  

Mutilple links , Harr link(硬连接), link counts

> If a file has 2 links, which one is the original file and which is the link to it?
>
> In the Unix directory structure , these two links are same. they are called `hard links` to the file. 
>
> The file is an inode and a bunch of data blocks; A link is a reference to an inode. 
>
> The kernel records the number of links which is called `link count` to a file in file’s inode struct.

Filename

> In the Unix file System , files actually do not have names. Files only have inode number. Links have names. 

#### Create File

1. Store Properties 属性
1. Store Data
1. Record Allocation 记录分配的块到属性
1. Add Filename to Directory

![image-20220317203533056](https://img.codekissyoung.com/2022/03/17/7db341f2df00982125ab309b61a9958f.png)

#### Read File

```
$ cat userlist
```

1. Search directory `.` find filename
1. get the i-node number and locate to it
1. get a list of data blocks’s number and check permission
1. read the data blocks one by one

![](https://img.codekissyoung.com/2022/03/19/fc4b34f26d258b19754867cffe4b5b78.png)

#### directory system call

```c
mkdir()  // create a directory
rmdir()  // delete a empty directory
unlink() // delete a file entry and update the link count
link()   // add a file entry and update the link count
rename() // update file entry name, mv command uses this
chdir()  // change the current directory of a process
```

> Each running process on Unix has a current directory. Internally , the process keeps a variable that stores the inode number of the current directory. When you say “change into a new directory” , it means you just change the value of that variable.

#### pwd

```bash
$ pwd                                                                
/home/link/workspace/md
```

Where is that long path `/home/link/workspace/md` stored ?

How does `pwd` know the current directory is called `md` ?

How does `pwd` know the parent of `md` is called `workspace` ?

> the answer is simple : Follow the links and read the directories `.` and `..` , `pwd` climbs up the tree , directory by directory. noting each step’s filename until it reachs the top of the tree.

How do we know when we reach the top of tree?

> In the root directory of a Unix file system. `.` and `..` point to the same inode.

### 文件系统抽象:文件树

#### File Tree

> In Unix , every file on the system is located somewhere in a single tree directories. There are no separate drivers or volumes. In fact, directories on physically separate disks and partitions are seamlessly subsumed (无缝融入) into this single root tree (单目录树/).
>
> so we only think about directories and files when writing programs. no partitions and volumes.

Directories are linked together into a tree.

- how does this tree work?
- how are directories linked together?


![image-20220317203019291](https://img.codekissyoung.com/2022/03/17/9463525c7bcd4c5c7bae2452f5bbfd1f.png)![image-20220317203315834](https://img.codekissyoung.com/2022/03/17/cb5b6efde8c24966fc217d94215fcf1e.png)

**path** : demodir/c/dl/xlink

Root Path : / , i-node : ?

#### How Directories are connected

#### Symbolic links

#### mount



![image-20220313212723786](https://img.codekissyoung.com/2022/03/13/dfdf0ea4dd189ca63f77d3f95c33e27c.png)

## 回顾和展望

1. 以上都是基于Linux经典文件系统Ext2的设计作为参考进行的分享
1. 更多一个分享可以从Ext2的进化，以及和其他的文件系统的设计区别这个方向

# 计算机网络

## 网络层次划分

### 物理层（Physical Layer）

- 激活、维持、关闭通信端点之间的机械特性,电气特性、功能特性以及过程特性
- 为上层协议提供了一个传输数据的可靠的物理媒体
- 设备: 中继器（Repeater，也叫放大器）和集线器

### 数据链路层（Data Link Layer）

- 如何将数据组合成`帧 frame`,控制它在物理信道上的传输，处理传输差错，调节发送速率与接收方匹配
- 在两个网络实体之间提供数据链路通路的建立，维持和释放，提供物理地址寻址，数据成帧，流量控制，数据检错，重发等功能
- 设备：网桥 交换机

### 网络层（Network Layer）

- 基本数据单位为 IP 数据报
- 路径选择 路由 以及 逻辑寻址
- 无链接数据报传输 数据报路由选择 和 差错控制
- 负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能
- 协议: IP ICMP 因特网控制报文协议, ARP 地址解析协议, RARP 逆地址解析协议
- 设备: 路由器

### 传输层

- 负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题
- 协议: TCP 传输控制协议、UDP 用户数据报协议
- 重要设备：网关

### 应用层

- 数据传输基本单位为报文
- 协议：FTP 文件传送协议、Telnet 远程登录协议、DNS 域名解析协议、SMTP 邮件传送协议，POP3 协议邮局协议，HTTP 协议

## IP 地址

- A 类地址: `0.0.0.0 ~ 127.255.255.255`, A 类私有地址: `10.0.0.0/8`, 回环地址:`127.0.0.1/8`表示本机地址
- B 类地址: `128.0.0.0 ~ 191.255.255.255`, B 类私有地址: `172.16.0.0/12`
- C 类地址: `192.0.0.0 ~ 223.255.255.255`, C 类私有地址: `192.168.0.0/16`
- D 类地址: `224.0.0.0 ~ 239.255.255.255` 作为组播地址（一对多的通信）
- E 类地址: `240.0.0.0 ~ 255.255.255.255` 保留地址，供以后使用。
- 只有 A,B,C 有网络号和主机号之分，D 类地址和 E 类地址没有划分网络号和主机号。
- 任意网段，其主机号为全 `1` 的的地址，称为这个网段的`广播地址`，向这个地址发包，所有该网段内的所有主机都会接收
- 任意网段，其主机号为全 `0` 的的地址，称为这个网段的`网络地址`，代表着这个网段

## 子网掩码 以及 网络划分

- 子网掩码是用来计算两个 IP 地址是否同属于一个子网的，也是 32 位二进制地址，其每一个为`1`代表该位是网络位，为`0`代表主机位
- 判定在同一个网段中: 两个 IP 地址在子网掩码的`&`的计算下所得结果相同，即表明它们共属于同一子网中
- `168.195.0.0` 划分成 27 个网段,其掩码是多少？ 分析: 1.它是 B 类地址 2. 划分子网就是利用主机位充当网络位,27 = 11011(二进制),故需要 5 位. 答案: `255.255.248.0`
- `168.195.0.0` 划分子网，每个子网有主机 700 台,求掩码? 700 = 1010111100， 其主机号需要 10 位来表示，所以掩码为: `11111111.11111111.11111100.00000000`
- 子网有 10 台主机，那么对于这个子网需要的 IP 地址是 `10＋1＋1＋1＝13` 个， 三个 1 分别是`网关地址`，`网络地址` 和 `广播地址`, 13 = 1101, 所以主机号需要 4 位, 其掩码为`255.255.255.224`

## ARP RARP 协议

### ARP 协议

- 根据 IP 地址获取物理地址的一个 TCP/IP 协议，主机发送信息时将包含目标 IP 地址的 ARP 请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址
- ARP 欺骗: 地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送 ARP 应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机 ARP 缓存；由此攻击者就可以向某一主机发送伪 ARP 应答报文，使其发送的信息无法到达预期的主机或到达错误的主机

- 主机 A 的 IP 地址为`192.168.1.1`，MAC 地址为`0A-11-22-33-44-01`,主机 B 的 IP 地址为`192.168.1.2`，MAC 地址为`0A-11-22-33-44-02` 当主机 A 要与主机 B 通信时，地址解析协议可以将主机 B 的 IP 地址解析成主机 B 的 MAC 地址，以下为工作流程：
  - 首先, A 得知道 B 的 IP 地址为`192.168.1.2`, 要构造 IP 报文发现没有 B 的 MAC 地址, 于是 A 查询本地 ARP 缓存中检查: 是否有该 IP 对应的 MAC 地址啊? 如果有就直接用了。
  - 但是主机 A 在 ARP 缓存中没有找到映射，所以 A 将 `ARP请求帧` **广播** 到本地网络上的所有主机。ARP 请求数据包括了: A 的 IP 地址和 MAC 地址 + B 的 IP 地址。
  - 本地网络上的每台主机都接收到 ARP 请求并且检查是否与自己的 IP 地址匹配。如果主机发现请求的 IP 地址与自己的 IP 地址不匹配，它将丢弃 ARP 请求。
  - 主机 B 确定 ARP 请求中的 IP 地址与自己的 IP 地址匹配，则将主机 A 的 IP 地址和 MAC 地址映射添加到本地 ARP 缓存中。
  - 主机 B 将包含其 MAC 地址的 `ARP回复消息` 直接发送回主机 A
  - 当主机 A 收到从主机 B 发来的 `ARP回复消息` 时，会用主机 B 的 IP 和 MAC 地址映射更新 ARP 缓存。主机 B 的 MAC 地址确定了，主机 A 就能向主机 B 发送 IP 数据报了。
  - 本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。

### RARP 协议

- 其将局域网中某个主机的物理地址转换为 IP 地址,比如局域网中有一台主机只知道自己的物理地址而不知道 IP 地址，那么可以通过 RARP 协议发出征求自身 IP 地址的广播请求，然后由 RARP 服务器负责回答；工作流程如下
  - 给主机发送一个本地的 RARP 广播，在此广播包中，声明自己的 MAC 地址并且请求任何收到此请求的 RARP 服务器分配一个 IP 地址；
  - 本地网段上的 RARP 服务器收到此请求后，检查其 RARP 列表，查找该 MAC 地址对应的 IP 地址；
  - 如果存在，RARP 服务器就给源主机发送一个响应数据包并将此 IP 地址提供给对方主机使用；
  - 如果不存在，RARP 服务器对此不做任何的响应；
  - 源主机收到从 RARP 服务器的响应信息，就利用得到的 IP 地址进行通讯；如果一直没有收到 RARP 服务器的响应信息，表示初始化失败。

## 路由选择协议

- RIP 协议 ：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是 15 跳，如果大于 15 跳，它就会丢弃数据包。
- OSPF 协议 ：Open Shortest Path First 开放式最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。

## TCP/IP 协议

- TCP 负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而 IP 是给因特网的每一台联网设备规定一个地址
- IP 数据包是不可靠的，因为 IP 并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP 数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）
- TCP 是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接
- TCP 提供的是一种可靠的数据流服务，采用“带重传的肯定确认”技术来实现传输的可靠性
- TCP 还采用一种称为 `滑动窗口` 的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度

- `SYN`: synchronize 请求同步包; `ACK`: acknowledge 确认标志包； `FIN`：Finally 结束包
- `LISTEN` 监听状态; `SYN-SEND` 已经发送`SYN`包状态; `SYN-RCVD` 已接受`SYN`包，并且已回复`SYN+ACK`包状态; `ESTABLISED` 链接已经建立,互相可以自由发送数据的状态;

- TCP 连接过程

  - 首先 Client 端发送连接请求报文
  - Server 段接受连接后回复 ACK 报文，并为这次连接分配资源
  - Client 端接收到 ACK 报文后也向 Server 段发生 ACK 报文，并分配资源，这样 TCP 连接就建立了

- TCP 断开过程
  - 假设 Client 端发起中断连接请求，也就是发送`FIN`报文，Client 进入`FIN-WAIT-1`状态
  - Server 端接到`FIN`报文后，知道 Client 端不再发数据了, 但是自己 **可能** 还有数据没发完, 所以先发一个 `ACK` 包给 Client, 告诉它: OK 知道了。Client 端收到`ACK`就进入`FIN-WAIT-2`状态，继续等待 Server 端的`FIN`报文
  - 与此同时, Server 继续发送数据, 发完后, 发送`FIN`包给 Client, 告知 Client: 我已经准备好关闭`Socket`了
  - Client 端收到`FIN`报文后，就知道可以关闭连接了,但是他还是不相信网络，怕 Server 端不知道要关闭，所以发送`ACK`后, 才进入`TIME_WAIT`状态
  - Server 收到`ACK`后，直接关闭`Socket`
  - Client 在`TIME_WAIT`状态等待了 2 分钟后，没收到回复了, 就知道 Server 已经关了，所以自己也就关闭 `Socket` 了, TCP 链接就这样关了

### 为什么要三次挥手？

- 在只有两次“握手”的情形下，假设 Client 想跟 Server 建立连接，但是却因为中途连接请求的数据报丢失了，故 Client 端不得不重新发送一遍；这个时候 Server 端仅收到一个连接请求，因此可以正常的建立连接。
- 但是，有时候 Client 端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下 Server 端将先后收到 2 次请求，并持续等待两个 Client 请求向他发送数据...问题就在这里，Cient 端实际上只有一次请求，而 Server 端却有 2 个响应
- 极端的情况可能由于 Client 端多次重新发送请求数据而导致 Server 端最后建立了 N 多个响应在等待，因而造成极大的资源浪费！所以，“三次握手”很有必要！

### 为什么要四次挥手？

- 试想一下，假如现在你是客户端你想断开跟 Server 的所有连接该怎么做？
- 第一步，你自己先停止向 Server 端发送数据，并等待 Server 的回复。但事情还没有完，虽然你自身不往 Server 发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；
- 故 Server 端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！

## UDP 协议

- UDP 用户数据报协议，是面向无连接的通讯协议，UDP 数据包括目的端口号和源端口号信息
- 由于通讯不需要连接，所以可以实现广播发送。
- UDP 通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。
- UDP 与 TCP 位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP 不被应用于那些使用虚电路的面向连接的服务，UDP 主要用于那些面向查询---应答的服务，例如 NFS。相对于 FTP 或 Telnet，这些服务需要交换的信息量较小。
- 每个 UDP 报文分 UDP 报头和 UDP 数据区两部分。报头由四个 16 位长（2 字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP 报头由 4 个域组成，其中每个域各占用 2 个字节，具体如下：
  - 源端口号；
  - 目标端口号；
  - 数据报长度；
  - 校验值。
- 使用 UDP 协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。
- TCP 与 UDP 的区别：TCP 是面向连接的，可靠的字节流服务；UDP 是面向无连接的，不可靠的数据报服务。

## DNS 协议

- DNS 是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，可以简单地理解为将 URL 转换为 IP 地址。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的 IP 地址，在 Internet 上域名与 IP 地址之间是一一对应的，DNS 就是进行域名解析的服务器。DNS 命名用于 Internet 等 TCP/IP 网络中，通过用户友好的名称查找计算机和服务。

## NAT 协议

NAT 网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法 IP 地址的转换技术，它被广泛应用于各种类型 Internet 接入方式和各种类型的网络中。原因很简单，NAT 不仅完美地解决了 iP 地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。

## DHCP 协议

DHCP 动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配 IP 地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段

## HTTP 协议

- GET：请求读取由 URL 所标志的信息。
- POST：给服务器添加信息（如注释）。
- PUT：在给定的 URL 下存储一个文档。
- DELETE：删除给定的 URL 所标志的资源。
- HTTP 中， POST 与 GET 的区别
  - Get 是从服务器上获取数据，Post 是向服务器传送数据。
  - Get 是把参数数据队列加到提交表单的 Action 属性所指向的 URL 中，值和表单内各个字段一一对应，在 URL 中可以看到。
  - Get 传送的数据量小，不能大于 2KB；Post 传送的数据量较大，一般被默认为不受限制。
  - 根据 HTTP 规范，GET 用于信息获取，而且应该是安全的和幂等的。
  - 所谓 安全的 意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。`幂等`的意味着对同一 URL 的多个请求应该返回同样的结果。

## 访问一个网站的过程

- 现在假设如果我们在客户端（客户端）浏览器中输入`http://www.baidu.com`
  - 客户端浏览器通过 DNS 解析到 www.baidu.com 的 IP 地址 220.181.27.48，通过这个 IP 地址找到客户端到服务器的路径。客户端浏览器发起一个 HTTP 会话到 220.161.27.48，然后通过 TCP 进行封装数据包，输入到网络层。
  - 在客户端的传输层，把 HTTP 会话请求分成报文段，添加源和目的端口，如服务器使用 80 端口监听客户端的请求，客户端由系统随机选择一个端口如 5000，与服务器进行交换，服务器把相应的请求返回给客户端的 5000 端口。然后使用 IP 层的 IP 地址查找目的端。
  - 客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。
  - 客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定 IP 地址的 MAC 地址，然后发送 ARP 请求查找目的地址，如果得到回应后就可以使用 ARP 的请求应答交换的 IP 数据包现在就可以传输了，然后发送 IP 数据包到达服务器的地址。

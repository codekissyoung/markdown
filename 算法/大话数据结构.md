# 《大话数据结构》

本文是《大话数据结构》的笔记。

## 第1章 数据结构绪论

![数据元素](https://img.codekissyoung.com/2019/05/30/48ca1834ba15d93dc2ebfe258c7fb979.png)

数据结构是相互之间存在一种或多种特定关系的数据元素的集合。

![结构差异](https://img.codekissyoung.com/2019/05/30/f0a313bd5794aa737c11c7d64e20b4cf.png)

**抽象数据类型ADT**：一个数学模型以及定义在该模型上的一组操作。它的定义仅仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。

![ADT](https://img.codekissyoung.com/2019/05/30/d426b17e5aa8d79dc1ed3879f36b1965.png)

## 第2章 算法

**算法**：解决特定问题求解步骤的描述，在计算机中表现为有限的指令序列。基本特征：输入、输出、有穷、确定、可行。

**时间复杂度**：语句总执行次数`T(n)`关于元素个数`n`的函数，分析`T(n)`的数量级，记做`O(T(n))`,称为算法的渐进时间复杂度。

从`T(n)`到`O(T(n))`的推导方法，以`2n^2 + 4n + 3`为例：

- 函数中，常数忽略不计，只保留最高项，去除`4n+3`
- 去除最高项的系数，去除`2`,所以结果为`O(n^2)`

常见算法的复杂度:

![常见时间复杂度](https://img.codekissyoung.com/2019/05/30/7d5249cd86a6b40e627dfe9128b849f4.png)

![常见时间复杂度比较](https://img.codekissyoung.com/2019/05/30/00ec1581b1dfbc78d1926a28b71e5076.png)

## 第3章 线性表

**线性表**：零个或多个数据元素的有限序列。

![线性表ADT](https://img.codekissyoung.com/2019/05/30/5d298ba32d3241dd99fd1e6358cbac6e.png)

### 顺序存储结构的线性表

使用顺序存储结构来实现线性表，即用一段连续的内存地址存储单元，依次存储线性表的数据元素：

顺序存储结构需要的三个属性:

- 存储空间的起始位置
- 线性表的最大存储元素个数
- 线性表当前存储元素个数

```c++
#define MAXSIZE 20          // 最大存储元素个数
typedef int ElemType;       // 元素类型视情况而定，这里暂时定为 int

typedef struct{
    ElemType data[MAXSIZE]; // data 即为存储空间的起始位置
    int length;             // 线性表当前存储元素个数
} SqList;
```

![使用顺序存储结构来实现线性表](https://img.codekissyoung.com/2019/05/30/1ee713816da3c77d5538092dfa3bd83f.png)

获取操作：获取第`n`个元素，`data + n`运算，`O(1)`性能，具有这一特性称为**随机存储结构**

插入操作：`O(n)`性能，要考虑存储已满，插入位置不在范围内等异常情况：

![插入操作](https://img.codekissyoung.com/2019/05/30/64fb93af7355aba3d1610803954cbc2f.png)

删除操作：`O(n)`性能，

![删除操作](https://img.codekissyoung.com/2019/05/30/4ff88129215d29ad07c8405f670a55e9.png)

顺序存储结构的缺点：插入和删除太慢，需要移动大量元素。

### 链式存储结构实现线性表

链式结构概念：节点、指针域、数据域。

![链式结构概念](https://img.codekissyoung.com/2019/05/30/8180aede35b0de3e086bb75d9ab14399.png)

链式结构：

![链式结构](https://img.codekissyoung.com/2019/05/30/a874f9b687f0843dcccd0c2ff2f75011.png)

通常对于单向链表，可能会设计一个头节点：它是为了操作的统一和方便设立，放在第一个元素之前，其数据域一般无意义（也可存入链表长度等信息），有了头结点，在第一个元素结点前插入结点 与 删除第一结点 的操作就与其他结点前的操作统一了

![头节点](https://img.codekissyoung.com/2019/05/30/7eb46ea1af708d97e91cb1ba0156a667.png)

```c++
// 定义结点
typedef struct Node{
    ElemType data;
    struct Node *next;
} Node;

// 定义链表
typedef struct Node* LinkList;
```

单链表的获取值为`val`的元素：只能从头开始，依次对比，`O(n)`性能。

单链表的插入:

![单链表的插入](https://img.codekissyoung.com/2019/05/30/b0faa9c805a555a2ec3839deddfbddb0.png)

单链表的删除：

![单链表的删除](https://img.codekissyoung.com/2019/05/30/a5339969f4135bf324acff36f30c8ff0.png)

如果是再在链表中某个值前后插入元素，或者是删除某个值为`val`的元素，都是要从头结点开始去查找的，性能`O(n)`,找到相应结点后，接下来只是简单的移动指针而已，不需要移动大量内存数据。所以如果我们预先知道，某个结点的位置，那么性能`O(1)`
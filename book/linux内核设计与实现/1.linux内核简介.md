# unix 历史
# linus 足迹
# 操作系统和内核简介
## 内核组成
- 响应中断的中断服务程序
- 管理多个进程,分享处理器时间的调度程序
- 负责管理进程地址空间的内存管理程序
- 进程间通信等系统服务程序

## 内核空间
- 对于提供保护机制的现代操作系统，它的部分内存空间和访问硬件设备的所有权限是需要受到保护的，它们只允许内核访问，这部分空间称为内核空间
- 内核独立于普通的应用程序

## 用户空间
- 应用程序只在用户空间执行，只能使用内核允许它们使用的系统资源和系统功能，不能直接访问硬件，不能相互访问各自的由内核划分的内存范围

## 内核空间与用户空间关系
- 内核运行在内核空间，当执行用户程序时，又要切换成用户空间，需要使用到内核功能时，又切换回内核空间
- 应用程序通过`系统调用`来与内核通信
- 应用程序调用库函数(比如 c标准库)，而库函数的实现部分依赖系统调用
- 当一个应用程序执行一条系统调用，我们说`内核正在代其执行命令 完成操作`，也可以认为，应用程序通过`系统调用`在内核空间运行，而内核可以理解为运行于`进程上下文`中

## 中断机制
- 硬件的体系结构都提供了中断机制
- 当硬件设备想和系统通信时，它发出一个异步的`中断信号`去打断cpu的执行，继而打断内核的执行
- 举例:敲击键盘--->键盘控制器发送`中断信号`--->内核调用该信号对应的`中断处理程序`--->中断被处理--->通知键盘可以继续输入数据
- `中断处理程序`不在进程上下文中运行，它们在一个与所有进程都无关的，专门的中断上下文中运行。这样做的目的是为了`中断处理程序`能在第一时间响应和处理中断请求，然后快速的退出。

## 处理器所有状态
- 运行于用户空间,执行用户进程
- 运行于内核空间，处于进程上下文，代表某个特定的进程执行
- 运行于内核空间，处于中断上下文，与任何进程无关，处理某个特定的中断

# linux内核和传统unix内核比较
- 单内核设计:内核从整体上作为一个单独的大过程来实现,运行在一个单独的地址空间上,内核以单个二进制文件的形式存放于磁盘中.因为所有内核服务都在这样一个大内核地址空间上运行，所以通信可以直接调用函数来实现。linux就是一个单内核设计。
- 微内核设计:内核的功能被划分为多个独立的过程，每个过程叫做一个服务器,所有的服务器都运行在各自独立的地址空间上,所以它们之间的通信不可能像单内核那样直接调用函数来实现，而是通过`消息传递`处理内核通信，消息传递采用的机制有`IPC`(进程间通信),因为`IPC`的开销多于函数调用，会涉及到内核空间与用户空间的上下文切换，所以`消息传递`需要一定的周期。所以在实际实现时，所有服务器都置于内核，运行在内核空间，不允许运行在用户空间，这样可以避免这一开销.Windows NT 和Mac OS X采用这样的设计

- linux单内核设计汲取了微内核设计的精华:模块化设计,动态转载内核模块,抢占式内核,支持内核线程,避免了微内核设计的缺陷,让内核的所有事情都运行在内核空间，直接调用函数，无需消息队列
- linux支持动态加载内核代码
- linux支持对称多处理机制(SMP)
- linux内核可以抢占(preemptive),在内核运行的任务，优先执行。
- linux并不区分线程和其他一般进程，对于linux内核来说，进程都一样，只不过其中的一些共享资源而已
- linux提供具有设备类的面向对象的设备模型，热插拔事件，以及用户空间的设备文件系统(sysfs)

# linux内核版本
2.6.26.1 : 主版本号.从版本号.修订版本号.稳定版本号

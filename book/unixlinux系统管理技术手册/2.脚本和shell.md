# 小论
- 运行效率不应该成为脚本编写的关注重点，清晰可读性才是重点
- shell脚步简单易用，linux标配，但是高端复杂的脚本的编写，使用Perl和Python会更加给力,但是缺点在于，建立它们的环境要麻烦些

# shell基础
- 设置编辑模式
    ```
    ➜  ~ set -o vi
    ```

## 管道和重定向
- 每个进程都有三个流,`stdin` `stdout` `stderr`,进程不在意这三个流来自哪里，又通向哪里，它们可能链接到一个终端，一个文件，一条网络链接，或者另一个进程的流
- 每个流的命名叫做`文件描述符`，它们依次是0,1,2
- 三个流的默认指向都是终端
- `>` `<` `>>` 是重定向，能改变流的指向
    ```
    ➜  ~ echo "this is a test message" > /tmp/mymessage /*重定向输出到文件*/
    ➜  ~ mail -s "Mail test" cky < /tmp/mymessage /*使用文件里内容发送邮件*/
    ```
- 将错误输出重定向
    ```
    ➜  ~ find / -name core /*没有重定向，stdout与stderr都输出在屏幕*/
    find: ‘/boot/efi’: 权限不够
    /dev/core

    ➜  ~ find / -name core > /tmp/test_output /*只将stdout重定向到文件,stderr还是输出到了屏幕*/
    find: ‘/boot/efi’: 权限不够

    ➜  ~ find / -name core > /tmp/test_output 2> /tmp/null  /*将stderr输出到黑洞，将stdout输出到屏幕*/
    /dev/core
    ```

- 将一条命令的stdout链接到另一条命令的stdin
    ```bash
    ➜  ~ ps -ef | grep ssh                
    cky       1324  1245  0 4月27 ?       00:00:00 /usr/bin/ssh-agent /usr/bin/sogou-session /usr/bin/im-launch /usr/lib/gnome-session/run-systemd-session ubuntu-session.target
    cky       1454  1183  0 4月27 ?       00:00:00 /usr/bin/gnome-keyring-daemon --start --components ssh
    cky      32116  3823  0 18:22 pts/0    00:00:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn ssh

    ➜  ~ cut -d: -f7 < /etc/passwd | sort -u
    /bin/bash
    /bin/false
    /bin/sync
    /usr/bin/zsh
    /usr/sbin/nologin
    ```
- && 与 ||
    ```
    ➜  workspace ls -alh && cat /tmp/t2 /*前一个命令执行成功，后面的命令才会执行*/
    总用量 28K
    drwxr-xr-x  7 cky cky 4.0K 4月  27 14:53 .
    drwxr-xr-x 32 cky cky 4.0K 4月  28 20:27 ..
    drwxr-xr-x  8 cky cky 4.0K 2月  22 22:24 blog
    ...
    hello world


    ➜  workspace ls -alh || cat /tmp/t2 /*前一个命令执行失败，后面的命令才会执行*/
    总用量 28K
    drwxr-xr-x  7 cky cky 4.0K 4月  27 14:53 .
    drwxr-xr-x 32 cky cky 4.0K 4月  28 20:27 ..
    drwxr-xr-x  8 cky cky 4.0K 2月  22 22:24 blog
    drwxr-xr-x  3 cky cky 4.0K 4月  27 12:07 cky
    drwxr-xr-x 26 cky cky 4.0K 4月  27 21:26 linux
    drwxr-xr-x  3 cky cky 4.0K 4月  20 18:59 note
    drwxr-xr-x  3 cky cky 4.0K 4月  14 16:28 sudoku
    ```

# 变量和引用
- 不要在变量两边留空白，否则shell会把变量当做命令
    ```
    ➜  ~ etcdir='/etc'
    ➜  ~ echo $etcdir
    /etc
    ```
- 使用`{}`拓展变量
    ```
    ➜  ~ rev=8
    ➜  ~ echo "the ${rev}th version of config.conf"
    the 8th version of config.conf
    ```

- `''`与`""`的区别 : `''`是不解析`{}$*?`的
    ```
    ➜  ~ myname="codekissyoung"
    ➜  ~ echo "i am ${myname}"
    i am codekissyoung
    ➜  ~ echo 'i am ${myname}'
    i am ${myname}
    ➜  ~ echo "there was `wc -l /etc/passwd` lines in passwd file" /* `` 可以被解析，它的意思是把里面的字符串执行，返回结果*/
    there was 45 /etc/passwd lines in passwd file
    ```


- 环境变量
    ```
    ➜  ~ export abc=123 /*声明一个环境变量*/
    ➜  ~ env /*输出所有环境变量*/
    XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat0
    XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg
    LC_TELEPHONE=zh_CN.UTF-8
    LANG=zh_CN.UTF-8
    DISPLAY=:0
    SHLVL=2
    LOGNAME=cky
    LANGUAGE=zh_CN:zh:en_US:en
    INVOCATION_ID=d1774be268ce4fcc816f39a929989c7f
    MANDATORY_PATH=/usr/share/gconf/ubuntu.mandatory.path
    PWD=/home/cky
    ... /*省略部分代码*/
    abc=123
    ```
用户登录终端时设置的那些环境变量都在`~/profile`和`~/.bash_profile`里，而像`PWD`这样的环境变量，由shell自动维护


# 过滤器命令
- 过滤器命令接受一个或者多个文件名输入，如果在一个文件名都没提供的时候，它们从`stdin`里读取数据
- sort排序
    ```
    -b 忽略开头空白
    -f 忽略大小写
    -t 设定分割符(默认空白)，将一行字符串分割
    -k 指定按某个分割的列排序
    -u 重复记录只输出一次
    -n 按数值大小比较，而不是ascii字符串
    -r 顺序反转，从大到小排序

    ➜  ~ sort -t: -n -k3,3 /etc/passwd
    root:x:0:0:root:/root:/bin/bash
    daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
    bin:x:2:2:bin:/bin:/usr/sbin/nologin
    sys:x:3:3:sys:/dev:/usr/sbin/nologin
    sync:x:4:65534:sync:/bin:/bin/sync

    ➜  ~ sort -t: -k3,3 /etc/passwd  
    root:x:0:0:root:/root:/bin/bash
    daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
    uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
    systemd-timesync:x:100:102:systemd Time Synchronization,,,:/run/systemd:/bin/false
    cky:x:1000:1000:cky,,,:/home/cky:/usr/bin/zsh
    ```
- cat
    ```
    -d 改变限定符(默认是[Tab]),该限定符将一行数据切割成几部分
    -f 指定输出里面包含那几个部分
    ```

- uniq 重复行只打印一次，通常这个命令接在sort命令后面运行
    ```
    -c 累计每行出现的次数
    -d 只显示重复行
    -u 只显示不重复行

    ➜  ~ cut -d: -f7 /etc/passwd|sort|uniq -c
          1 /bin/bash
         26 /bin/false
          1 /bin/sync
          1 /usr/bin/zsh
         16 /usr/sbin/nologin
    ```

- wc 统计行数，字数，字符数
    ```
    -l 只输出行数
    -w 只输出字数
    -c 只输出字节数

    ➜  ~ wc /etc/passwd
    45   76 2528 /etc/passwd
    ```

- tee 把输入复制到两个地方
    ```
    /* /dev/tty 表示本终端，整句意思是往本终端发一份，再给wc -l命令传一份*/
    ➜  ~ find /home/cky/workspace -name cky 2>/dev/null | tee /dev/tty|wc -l
    /home/cky/workspace/cky
    /home/cky/workspace/cky/cky
    2
    ```

- tail 读取文件
    ```
    -f 监控，命令不马上退出，而是等待着有新行被追加到文件末尾，然后打印它们
    ```

- grep 搜索文本
    ```
    -c 统计文件内有几处匹配到的
    -i 忽略大小写
    -v 打印不匹配行
    -l 只打印匹配到内容的文件的名字，而不是匹配的每一行
    -r 表示输入的路径是一个目录，匹配目录下的所有文件
    -n 输出匹配处在文件内的行数

    ➜  ~ grep -nr codekissyoung /home/cky/workspace/blog
    /home/cky/workspace/blog/function/common.php:32:			if($leaf == "codekissyoung.md"){
    /home/cky/workspace/blog/web/index.php:20:	$content = file_get_contents(MD_ROOT.'/codekissyoung.md');
    ...

    ➜  ~ grep -cr codekissyoung /home/cky/workspace/blog|sort -t: -k2,2 -nr
    /home/cky/workspace/blog/web/md/linux/unixlinux系统管理技术手册/2.脚本和shell.md:12
    /home/cky/workspace/blog/web/md/linux/docker.md:8
    /home/cky/workspace/blog/web/md/c/字符串.md:6
    ...
    ```

# bash 脚本编程
- hello 脚本
    ```shell
    #!/bin/bash
    echo "hello world!"
    ```
- 加可执行权限，运行
    ```
    chmod +x hello
    ./hello
    hello world!
    ```
- read
    ```shell
    #!/bin/bash
    # -n 消除了通常的换行符
    echo -n "enter your name:"
    read user_name
    # 判断user_name是否为空，注意if等指令与其他字符相邻，中间要加空格
    if [ -n "$user_name" ];then
    	echo $user_name;
    	exit 0
    else
    	echo "you do not enter username"
    	exit 1
    fi
    ```

- 命令行参数
    ```shell
    #!/bin/bash
    echo "脚本名字:$0"
    echo "第一个参数:$1"
    echo "总共的参数个数:$#"
    echo "全部参数:$*"

    ```
    ```shell
    ➜  shell ./params aa bb cc
    脚本名字:./params
    第一个参数:aa
    总共的参数个数:3
    全部参数:aa bb cc
    ```

- 函数和局部变量
    ```bash
    #!/bin/bash
    function localizer {
    	echo "全局变量的a是${a}"
        #声明局部变量
    	local a="local a"
    	echo "局部变量a是$a"
    }

    a="global a"

    #调用函数
    localizer
    echo "调用完函数后的a是$a"
    ```

    ```
    ➜  shell ./localizer
    全局变量的a是global a
    局部变量a是local a
    调用完函数后的a是global a
    ```

- 控制流程
    ```bash
    #!/bin/bash
    a=10
    b=10
    if [ $a == $b ] && [ -n $a ]
    then
       echo "a 等于 b"
    elif [ $a -gt $b ]
    then
       echo "a 大于 b"
    elif [ $a -lt $b ]
    then
       echo "a 小于 b"
    else
       echo "没有符合的条件"
    fi
    ```

    ```bash
    /bin/test命令,[]是调用test命令的一种快捷方式
    x -eq y : x=y
    x -ne y : x!=y
    x -lt y : x<y
    x -le y : x<=y
    x -gt y : x>y
    x -ge y : x>=y
    -n x : x 不为空
    -z x : x 为空
    -d file : file是目录
    -e file : file存在
    -f file : file存在且是普通文件
    -s file : file存在且不为空
    -r file : 用户有file文件的读权限
    -w file : 用户有file文件的写权限
    file1 -nt file2 : file1比file2新
    file1 -ot file2 : file1比file2旧
    ```

- case 语句
    ```bash
    #!/bin/bash
    a=1
    case $a in
    0)
    echo "就是0嘛"
    ;;
    1)
    echo "就是1嘛"
    echo "再输出一句"
    ;;
    *)
    echo "就是其他嘛"
    ;;
    esac
    ```

- for 循环，in后面是一个模式，它能匹配当前目录下能够匹配的文件列表，实际上，任何以空白分割的对象列表，包括一个变量的内容，都可以充当`for...in`语句的主体

    ```bash
    #!/bin/bash
    for script in *
    do
    	echo $script
    done
    ```

    ```
    ➜  shell ./while
    case
    ifelse
    localizer
    params
    perl
    python
    read
    while
    ```

- while

    ```bash
    #!/bin/bash
    exec 0<$1
    counter=1
    while read line
    do
    	echo "$counter : $line"
    	counter=`expr $counter + 1`
    done
    ```

    `exec 0<$1`将标准输入变成第一个参数，所以第一个参数必须是文件，否则会出错
    `read line`就是读取文件里的一行数据，进行处理,加上`while`就是依次读取了
    `expr $counter + 1` 是shell的算术处理方法

- 数组和算术
    - shell里`+`只是一个普通的字符，没有任何其他含义
    - shell里数组基本没啥用


# 正则表达式
- 正则表达式要区分于shell的通配符匹配
- 普通字符匹配
    ```
    i am codekissyoung
    ```
- 特殊字符匹配
    ```
    . 匹配任何字符
    [chars] 匹配任何给定字符集里面的字符
    [^chars] 匹配给定字符集之外的字符
    ^ 匹配行首
    $ 匹配行尾
    \w 匹配[A-Za-z0=9]
    \s 匹配空白 [\f\t\n\r]
    \d 匹配数组 [0-9]
    | 匹配左边或者右边的任何一个
    (expr) 限定范围，元素成组,从而可以捕获到匹配
    ```

- 数量匹配
    ```
    ? 匹配前面元素的 0 个或者 1个
    * 任意个
    + 1个或者多个
    {n} n 个
    {min,} min 个以上
    {min,max} min 到 max 之间个
    ```
- 示例
    ```
    i am (codekissyoung|caokaiyan)\.
    匹配：i am codekissyoung. 和 i am caokaiyan.
    (i am (codekissyoung|caokaiyan)\.){1,2}
    匹配：i am codekissyoung. 和 i am caokaiyan. 和 i am codekissyoung.i am caokaiyan. 和 i am codekissyoung.i am codekissyoung. 等
    ```

- 捕获
每个`()`里面内容的匹配称为捕获，是实现正则表达式的内部机理，不做过于深入

- 贪心 懒惰 和 灾难性的回溯
简单的说，贪心就是尽量多匹配几个字符，懒惰就是尽量少匹配几个

# Perl
虽然很牛逼，和有强大的正则表达式，但是...唉，没落了呀！

# Python 脚本
- 缩行代表逻辑块
    ```python
    #!/usr/bin/python
    #coding=utf-8
    import sys
    a = sys.argv[1]
    if a == "1":
    	print 'a is one'
    	print 'if 汉子'
    else:
    	print 'a is ',a
    	print "else"
    print "after if else"
    ```

# 脚本编程最佳实践
先留着，有经验了再看

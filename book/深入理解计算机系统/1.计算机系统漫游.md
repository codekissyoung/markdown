# 信息就是 位 + 上下文
- 计算机里所有的一切，数据，指令，文件等都是"101010101010"的位，唯一区分它们的办法就是上下文，上下文就是它的所处环境，解释环境。
- 同一段1010101010101010,可能会因为上下文的不同，而表达不同的意思

# 编译
人类可阅读的字符串程序，被翻译成机器能理解的指令序列

# 处理器 读取 并且解释储存在 存储器 中的指令
## 系统硬件构成
### 总线
- 在各个部件中传递信息，每次传递一个字(word),一般设计为与cpu的位数相同，32位的机器中，1 字 = 4 字节
### I/O设备
- 键盘/鼠标/显示器/磁盘
### 主存
- 一个临时存储设备，用于正在执行的程序存放数据
- 物理上来说，是DRAM芯片
- 逻辑上来说，是一个线性的字节数组,每个字节都有一个编号，从0开始
### cpu
- 用于解释执行存储在 主存 中的指令
- PC , 程序计数器,永远指向将运行的那条指令在 主存 中的地址
- cpu工作流程: 解释当前PC的指令，更新PC,解释PC的指令
- ALU 算术/逻辑单元
- 加载：从主存复制数据到寄存器
- 存储: 从寄存器复制数据到主存，覆盖主存中原来的值
- 操作: 复制数据到ALU,ALU做算术操作，结果放其中一个寄存器中
- 跳转: 复制数据到PC中，覆盖原来PC中的值
- DMA: 直接存储器存取技术,数据可以不通过处理器而直接从磁盘到达主存

# 高速缓存至关重要
- 数据从磁盘复制到主存,再从主存复制到处理器，这些复制就是开销，系统设计者应该的目标就是使这些复制操作尽快完成
- 在cpu和内存之间设立高速缓存，作为程序数据的暂时集结区域，能明显提高程序效率,这种高速缓存由SRAM(静态随机访问存储器)的硬件技术实现
## 储存设备形成层次结构


# 操作系统管理硬件
- 防止硬件被应用程序滥用
- 向应用层提供简单一致的接口来控制复杂而又通常混乱的低级硬件设备

## 进程
- 程序运行时，操作系统会提供一种假象: 这个进程独占cpu,主存，IO设备，指令依次运行
- 但实际上，多个进程是轮流执行的，操作系统保持和跟踪进程所有状态信息 (eg.PC的值，寄存器文件的值),当进程切换时，它将上一个进程的状态信息保存，然后执行下一个进程，下一个进程执行一会儿后，切换回上一个进程时，直接用保存好的进程状态信息就能恢复之前的执行状态
- 进程切换也称为上下文切换

## 线程
- 一个进程可以由多个称为线程的执行单元组成
- 每个线程都运行在进程的上下文中，并共享同样的代码和全局数据
- 使用多线程编程，比使用多进程编程来的高效,因为多线程之间的通信比多进程之间更容易共享数据
- 使用线程，我们可以在一个进程中执行多个控制流
- 超线程: 也称作同时多线程,正常cpu大约需要20000个时间周期做不同线程间的转换,而超线程的cpu可以在单个周期的基础上决定要执行哪一个线程。比如说，一个线程必须等到某些数据被装载到高速缓存中，那cpu就可以继续去执行另一个线程，intel core i7 就可以一个核执行两个线程,一个四核的系统实际上可以执行8个线程

### 虚拟存储器
- 虚拟存储器为进程提供了一个假象，即每个进程都在独占内存,每个进程看到的都是一样的存储器,称为虚拟地址空间
- 每个进程看到的虚拟地址空间由准确定义的区组成,每个区都有专门的功能
- 程序代码区:对所有进程来说，代码是从同一固定地址开始
- C全局变量区:紧邻着程序代码区，存储的的是初始化的数据
- 堆:紧邻着全局变量区,可以动态扩展使用的内存,使用malloc申请,free释放
- 共享库:存在虚拟地址空间中间,存放的是c标准库
- 栈:位于用户虚拟地址空间顶层(它的上面是内核虚拟地址空间，是不允许用户操作的),编译器使用它来实现函数调用，函数调用，栈增长，函数返回，栈消退
- 内核虚拟存储器:位于整个虚拟存储器顶部，是为内核保留的，不允许应用程序读写和直接调用内核代码定义的函数


## 文件
- unix/linux 里一切都是文件,包括I/O设备,磁盘,键盘,显示器,网络,而文件不过是字节序列，仅此而已
- 文件向应用程序提供了一个统一的视角，来看待系统中各式各样的设备,例如，处理磁盘文件内容，无需了解具体的磁盘文件，同一个程序就可以在使用不同磁盘技术的不同系统上运行

# 网络
- 网络可视为一个I/O设备,系统将一串字节复制到网络适配器时，数据流经网络到达另一台机器，另一台机器可以读取该数据，并把它复制到自己的主存上

# 计算机系统提供的一些抽象
![计算机系统提供的一些抽象](http://upload-images.jianshu.io/upload_images/1581984-2fbe5f6f3436fcce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



## cpu ##
```
用于计算的，不同类型的cpu拥有不同的指令集，这些指令集基本上代表了计算机的能力范围。
指令集是 01 的序列，映射成人类易于书写的语言便是汇编。汇编代码通过汇编器翻译成cpu
能理解的指令序列，也就是机器代码。

汇编器是可以跨 cpu 的，也就是说，同样的汇编代码，汇编器可以翻译成不同 cpu 能认识
的机器代码。
```
## 内存 ##
```
任何数据或者代码，只要被加载到内存里，才有作用，才可操作。内存只是一个暂时性的存储。
```
## BIOS与CMOS ##
```
cmos 记录计算机硬件信息。bios 是可以修改cmos 的程序，该程序为写死在硬件上，不可修改。
硬件开机，第一个执行的程序便是 bios ，然后再是操作系统的引导程序（MBR：主引导记录，
GRUB：统一引导加载器），然后是操作系统内核，再是内核上的操作系统。
```
## 研发的实质 ##
```
研发：参考底层提供的资源，构建新功能的过程
早期写程序是参考一大堆硬件参数，编程的主要目的是驱动这些硬件。后来这些程序后来汇集成一起，
构建成了操作系统内核，由内核统一驱动硬件。内核还提供驱动开发接口和系统调用，硬件厂商参考
驱动开发接口写驱动自家硬件的驱动程序；软件开发人员参考系统调用，写供用户使用的软件程序。

然而各厂商内核并不唯一(microsoft 内核，linux 内核，unix 内核，ios 内核，andriod 内核)，
内核不一样，系统调用自然无法兼容。为了解决这个问题，c 标准库出现了。

c 标准库屏蔽了系统调用，将系统调用封装成了它的函数库。从此开发人员写程序只要参照 c 函数库就好，
有些开发可能还要使用内核的系统调用。

然而，c 标准库虽然可以大致在所有操作系统上表现一致，然而各大操作系统却拥有一些只能在自己平台使用的库，
比如 microsoft 的 mfc ;各大库厂商的库各自为战，导致 c 语言的跨操作系统的特性变得不适用。所以 java 出现了。

java 是由一家公司垄断，使用内建的 jvm 屏蔽了所有操作系统的差异，java 代码运行在jvm 里面。
由 jvm 实现java 代码在各个操作系统上的表现一致性。不过 java 版本之间的差异性也是头疼的问题，应该说这是所有语言的通病。

类似于 java 这种不之间编译成机器代码。而是由厂商自己构建的 jvm 或着解释器 代为执行代码的语言开始兴起。

```


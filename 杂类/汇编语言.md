# 汇编语言

王爽写的那本《汇编语言》，本文是笔记。

## 环境搭建

[项目下载地址](https://github.com/codekissyoung/masm)

环境是`ubuntu 18.04`下的`doxbox 0.74`模拟器，另外需准备`DOS`系统下的编译调试工具`debug.exe`、`link.exe`和`masm.exe`。

```bash
sudo apt-get install dosbox     # 安装
vim ~/.dosbox/dosbox-0.74.conf  # 配置
```

```bash
# dosbox-0.74.conf
[autoexec]
mount c ~/workspace/masm/
c:
```

```bash
masm/               # 项目目录
├── debug.exe
├── LINK.EXE
└── MASM.EXE
```

## 1. 基础知识

在内存和磁盘上，指令和数据没有任何区别，都是二进制信息:

```bash
1000100111011000     -> 89D8H     (数据)
1000100111011000     -> mov ax,bx (指令)
```

计算机中专门有连接CPU和其他芯片的导线称为总线:

- 地址总线: CPU通过它来指定内存单元地址，`8086 CPU`的地址总线宽度为20,寻址范围为`0 ~ 2^20`
- 控制总线: CPU与内存或者其他器件之间的数据传送是通过数据总线来进行的，`8086 CPU`的数据总线宽度为16,可以一次性传送16`bit`数据
- 数据总线: 是一些不同控制线的集合，比如"读信号"控制线、"写信号"控制线

### 接口卡

直接控制显示器、音响、打印机(外设)工作的器件叫接口卡，`CPU`与接口卡通过总线相连，实现间接控制。

### 内存地址空间

`CPU`将系统中的各类存储器看作一个逻辑存储器，给每个物理存储器划分了内存地址范围。

![2019-09-10 16-23-04 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/55e616a938637790332a3e4c26422148.png)

`8086 CPU`的内存地址空间的分配情况:

```
00000 ~ 9FFFF  主存地址空间
A0000 ~ BFFFF  显存地址空间
C0000 ~ FFFFF  各类ROM地址空间
```

## 2. 寄存器

**通用寄存器**: `AX` `BX` `CX` `DX`，为16位寄存器，然后它们每个又可以分为两个寄存器,例如 `AH` 和 `AL`。

![2019-09-10 18-09-05 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/722d78f60a384bbecf6622c0a10232b1.png)

几条汇编指令

```asm
mov ax, 18    # ax = 18
add ax, 8     # ax = ax + 8
mov ax, bx    # ax = bx
add ax, bx    # ax = ax + bx
```

**地址寄存器**:  

- 段地址寄存器： `DS` `ES` `SS` `CS`
- 偏移地址寄存器: `SP` `BP` `SI` `DI` `IP` `BX`(有时候作为偏移地址寄存器使用)

`8086 CPU`的寄存器，数据总线等长度都是16位，也就是说能一次性处理的、传输、存储的信息为16位。那么该CPU如何生成20位的信息，供20位宽度的地址总线寻址使用呢？

答案是 : `物理地址 = 段地址 * 16 + 偏移地址`

![2019-09-10 18-16-21 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/f9a345d0de33a0faf8b1c7c2fdfddb6f.png)

![2019-09-10 18-16-42 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/c421eed8fac926efc6acdcc198ee1bf5.png)

关于段地址与偏移地址的一些结论:

- 可以用不同的段地址和偏移地址，形成同一个物理地址
- 给定一个段地址，只改变偏移地址，最多可以定位`64KB`(2^16)内存单元

在`8086 CPU`中，任意时刻，CPU都将`CS:IP`指向的内存地址处的二进制信息，当作指令来执行

![2019-09-10 18-26-00 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/8f4a260a2621506e114da563b8f7deb3.png)

读取一条完整指令后，`IP`中的值自动增加指令所占用的字节数，此时`CS:IP`指向`2000:0003`,即下一条指令开始位置。

![2019-09-10 18-27-36 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/0430b60fc5202d4eb08909806b68197d.png)

执行控制器将一条指令执行完毕后，`CPU`继续读取`CS:IP`指向的下一条指令，依次执行完所有指令。

![2019-09-10 19-51-29 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/51a19b312400ef6ba0488177fadaf840.png)

`8086 CPU`加电启动后，默认`CS=FFFFH IP=0000H`，即从`FFFF0H`开始读取指令执行，`FFFF0H`处的指令就是`8086 CPU`开机后执行的第一条指令。

指令是有长度的，一条指令可能占两个字节、三个字节。

**指令的执行过程**:

1. CPU 从 `CS:IP` 所指的内存单元中读取指令,暂存于`指令缓存器`
1. IP = IP + 指令长度,从而指向下一条指令
1. 执行`指令缓存器`中的指令，回到步骤1

![屏幕快照 2019-09-16 下午7.59.40.png](https://img.codekissyoung.com/2019/09/16/f1772f4e9e08d14ae3eab3c50cd5e815.png)

### CPU 如何区分指令与数据

在内存与磁盘中，指令和数据都是二进制信息，没有任何区别。只有在CPU工作时，才将有的信息当做指令，有的信息当做数据。那么它是依据什么来区分的呢？

> 答案是: `CPU`将`CS:IP`指向的内存单元看作指令，而将`DS:[偏移地址]`指向的内存单元当作数据，也就是说我们在内存中存入一段指令，只需要将`CS:IP`指向这段指令的起始地址，`CPU`就知道这里的二进制信息就是将要执行的指令了。

修改`CS` `IP`寄存器的汇编指令:

```asm
jmp 2AE3:3      # 执行后 CS = 2AE3H  IP = 0003H

mov ax,1000H    
jmp ax          # 执行后 CS 不变，IP = 1000H
```

### Debug 工具

`Debug`是`DOS`、`Windows`的实模式下程序的调试工具。使用它可以查看`CPU`中各种寄存器、内存以及在机器码级别跟踪程序的运行。

启动`dosbox`后，直接运行`debug`进入调试界面。

`-r`查看寄存器:

![2019-09-10 20-14-47 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/60ccebfbef77d339e33d6103cb186418.png)

`-r 寄存器`修改寄存器的值:

![2019-09-10 21-39-51 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/42882b50e3d4895f6ef815fbb1edd9f1.png)

`-d CS:IP`查看内存(`1000:0`处开始，128个字节的内存的值):

![2019-09-10 21-43-57 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/52eaf74828149e7d0af0c03da91a8e7b.png)

`-e CS:IP 数据`连续修改指定内存的值:

![2019-09-10 21-48-22 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/dc546dd775b8260fa22ced552da6ac5f.png)

`-u CS:IP`指定内存地址，按指令解释二进制信息:

![2019-09-10 22-42-25 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/3575e2840c498a1f32c86cc4fab80a32.png)

`-t`单步执行`CS:IP`指向的指令:

![2019-09-10 23-06-05 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/7c2095d8c223db5f3d332dbbf5ef9194.png)

`-a CS:IP`以汇编语言的方式写入机器指令到内存中

![2019-09-10 23-13-23 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/cc8abbc43a914608244c4b77b672b639.png)

## 3. 寄存器 内存访问

### 指令在内存中的存储

字节型数据: 存放在内存中，占单个字节。

字型数据: 存放在内存中，由两个连续的地址的内存单元组成:

- 高地址 内存单元 存放 字型数据 的 高位字节
- 低地址 内存单元 存放 字型数据 的 低位字节

![屏幕快照 2019-09-16 下午8.55.15.png](https://img.codekissyoung.com/2019/09/16/c04c81699ce4da33136d032b9bee705d.png)

`CPU`读写一个内存单元时，必须给出这个内存单元的地址，在`8086PC`中，内存地址由段地址和偏移地址组成。其中段地址由`DS`寄存器指定。比如读取`10000H`单元的内容:

```masm
mov bx,1000H
mov ds,bx      # 8086 不支持直接将数据送入段寄存器的操作，所以这里使用了 bx
mov al,[0]     # 传送一个 字节
mov cx,[0]     # 传送一个 字
mov [1],al
mov [1],cx
```

指令在计算或者移动数据时，最重要的就是确定数据的长度，而长度就是依据寄存器的类型来确定的。

### CPU 提供的栈机制

栈是一段连续的内存单元，也是一段连续的内存地址，它和普通内存单元区别在 访问方式 上。术语: 栈顶(`SS:SP`)、入栈(`PUSH`)、出栈(`POP`)。

`8086 CPU`提供的栈功能 ：

- 任意时刻，`SS:SP` 寄存器指向栈顶的内存地址
- 栈操作都是以字(16个字节)为单位
- 栈顶从高地址向低地址方向增长，它不保证我们对栈的操作不会越界 
- 用栈来暂存以后需要恢复的寄存器的内容时，寄存器出栈的顺序要和入栈的顺序相反。

```asm
push 寄存器      # 将一个寄存器中的数据入栈
pop  寄存器      # 将一个寄存器中的数据出栈
push [0]        # 将1000:0 处的字压入栈
pop  [2]        # 出栈，数据存入1000:2处
```

`PUSH AX` 入栈指令执行过程：
- `SP = SP - 2` ( 特别注意 ： 入栈，SP 是递减的 ) 
- 将 `AX` 中数据，存入`SS:SP`指向的内存中

![屏幕快照 2019-09-20 下午4.20.03.png](https://img.codekissyoung.com/2019/09/20/aad5903264863ec8ea556acc3c402550.png)

`POP BX` 出栈指令执行过程:
- 将`SP:SP`指向的内存中的内容，拷贝到`BX`中
- `SP = SP + 2`

### 栈在哪里？栈的大小?

栈的最大空间为：`64KB`，`SP`设置为`0x0000`时，栈的容量最大。当第一次`PUSH`时，`SP - 2` 等于 `0xFFFE`。可以推算出，可以存放 `65536 / 2 = 32768` 个字型数据。

栈的作用: 

- 临时性保存数据
- 用栈进行数据交换，比如 `PUSH AX; PUSH BX` 然后 `POP AX; POP BX`, 这样 `AX` 与 `BX` 的值就发生了交换



用一个段地址指示段，用偏移地址访问段内的存储单元，完全是我们自己的安排。

`数据段`: 只是编程时候的一种数据安排，段地址存于`DS`中。使用`mov`、`add`、`sub` 访问内存单元时，CPU将这个段里的二进制信息，当作数据来使用。

用一个段存放代码，称为`代码段`，段地址存于`CS`中。将段中第一条指令的偏移地址放在`IP`中，这样CPU就将执行我们定义的代码段中的命令。

用一个段当作栈，称为`栈段`,段地址存于`SS`中，将栈顶单元的偏移地址放在`SP`中，这样CPU在进行`push`、`pop`操作时，就将我们定义的栈段当作栈空间来用。

CPU将内存中的某段内容当作代码，只是因为`CS:IP`指向了那里;CPU将某段内存当作栈，只是因为`SS:IP`指向了那里。

DEBUG 的 `-t` 命令在执行修改寄存器 `SS` 的指令时，下一条指令也紧接着被执行。原因在于: **中断机制**。

## 4. 第一个程序

汇编语言发展至今，有以下3类指令构成:

- 汇编指令: 机器码的助记符，有对应的机器码
- 伪指令: 没有对应的机器码，由编译器执行，计算机并不执行
- 其他符号: 如 `+ - * /`,由编译器识别，没有对应的机器码

```asm
assume cs:codesg    ; 伪指令 假设 cs 寄存器 与 codesg 段关联

codesg segment      ; 伪指令 段开始

    mov ax,0123H    ; 汇编指令
    mov bx,0456H
    add ax,bx
    add ax,ax

    mov ax,4c00H    ; 退出程序指令，规定要写
    int 21H

codesg ends         ; codesg 段结束

end                 ; 伪指令 汇编代码结束
```

为了观察程序运行，我们使用`DEBUG` 工具将程序载入内存，设置`CS:IP`指向程序的入口，但`DEBUG`又不放弃对`CPU`的控制，这样我们就可以用`DEBUG`的相关命令来单步执行程序，查看每一条指令执行的结果。

DOS系统中`exe`程序加载过程:

![屏幕快照 2019-09-20 下午5.02.36.png](https://img.codekissyoung.com/2019/09/20/d82486f4a302a3714087d04098902351.png)

```asm
assume cs:codesg

codesg segment

	mov ax,2000H
	mov ss,ax
	mov sp,0
	add sp,10
	pop ax
	pop bx
	push ax
	push bx
	pop ax
	pop bx

	mov ax,4C00H
	int 21H
codesg ends
end
```

`PSP`的头两个字节是`CD 20`,用DEBUG调试上面程序，通过`-d ds:0`可以看到 `PSP`,通过`-d cs:0`可以查看程序段。


## 5. [BX]和loop指令

`loop`指令执行过程:

- `cx = cx - 1`
- 判断: 如果 `cx > 0` 跳转到某个指令处执行，如果`cx = 0`则继续向下执行 

编程完成乘法 : `123 * 236`

```
assume cs:code

code segment

    mov ax,0
    mov cx,236

mul: add ax,123
     loop mul

    mov ax,4C00H
	int 21H

code ends
end
```

PS: 汇编源程序中，数据不能以字母开头，例如`A000H` 要写成 `0A000H`。


## 6. 包含多个段的程序

随意地向内存中写入内容，如果不小心改变了系统存放在内存中的内容，会导致系统的奔溃。

所以我们需要一个操作系统来为每一个程序分配内存，方式有两种:

- 操作系统在加载程序时，就为程序分配好内存空间
- 程序在执行过程中，向操作系统申请内存

## 7. 更灵活地定位内存地址的方法

![屏幕快照 2019-09-20 下午6.42.59.png](https://img.codekissyoung.com/2019/09/20/3eb0856e482ad50b7f9436cfdb59b1e4.png)

## 8. 数据处理的两个基本问题

### 处理的数据在什么地方?



### 要处理的数据有多长?

8086CPU中，可以处理两种尺寸的数据`byte`和`word`，所以机器指令中要指明操作的是`byte`还是`word`。


第一种方式, 通过寄存器名称指明要处理数据的尺寸:

```asm
mov ax,1        ; 字操作
inc ax
add ds,ax

mov al,1        ; 字节操作
mov bl,al
inc al
```

第二种方式，没有寄存器名称时，要明确指明:

```asm
mov word ptr ds:[0],1       ; 字操作
inc word ptr [bx]
add word ptr [bx],2

mov byte ptr ds:[0],1       ; 字节操作
inc byte ptr [bx]
add byte ptr [bx],2
```

第三种方式，指令类型默认操作操作数据长度

`PUSH` `POP` 指定操作的数据就是`word`。

## 9. 转移指令的原理

8086CPU中转移指令分为以下几类:

- 无条件转移指令 `jmp`
- 条件转移指令
- 循环指令 `loop`
- 过程
- 中断

这些转移指令的前提条件可能不同，但是转移的原理都是相同的，这里只讨论学习`jmp`的实现原理。


## 10. CALL 和 RET 指令

## 11. 标志寄存器

标志寄存器作用:

- 用来存储相关指令执行后的 结果
- 用来为 CPU 执行相关指令提供 行为依据
- 用来控制 CPU 的相关工作方式

`8086CPU`的标志寄存器也是16位，其中存储的信息通常被称为程序状态字`PSW`,标志位的情况如下:

![屏幕快照 2019-09-20 下午7.07.26.png](https://img.codekissyoung.com/2019/09/20/fffd2756303356fe67f0246828e73935.png)

`ZF` 记录 指令执行结果 是否为`0`,如果为`0`,则`ZF = 1`。

`PF` 记录 指令执行结果 中，所有`bit`位中`1`的个数是否为偶数，如果是`PF = 1`。

`SF` 记录 指令执行结果 是否为负数，如果为负数，则`SF = 1`。

`CF` 记录 指令执行结果 中产生的进位，只对无符号数的运算有意义

`OF` 记录 指令执行结果 中的溢出，只对有符号数的运算有意义，比如`98 + 99` 超过了 `127`, 一个`byte`表示有符号数的话，没有对应的结果的表示方法，称为溢出。

## 12. 内中断

## 13. int 指令

## 14. 端口

## 15. 外中断

## 16. 直接定址表

## 17. 使用BIOS进行键盘输入和磁盘读写

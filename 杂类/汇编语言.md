# 汇编语言

王爽写的那本《汇编语言》，本文是笔记。

## 环境搭建

环境是`ubuntu 18.04`下的`doxbox 0.74`模拟器，另外需准备`DOS`系统下的编译调试工具`debug.exe`、`link.exe`和`masm.exe`。

安装设置如下:

```bash
# 安装
sudo apt-get install dosbox

# 配置
vim ~/.dosbox/dosbox-0.74.conf
```

```bash
[autoexec]
# Lines in this section will be run at startup.
# You can put your MOUNT lines here.
# 配置内容如下
mount c ~/workspace/masm/
c:
```

项目目录:

```bash
cky@ckypc:~/workspace$ tree masm/
masm/
├── debug.exe
├── LINK.EXE
└── MASM.EXE
```

项目地址: [github masm](https://github.com/codekissyoung/masm)

## 1. 基础知识

汇编语言发展至今，有以下3类指令构成:

- 汇编指令: 机器码的助记符，有对应的机器码
- 伪指令: 没有对应的机器码，由编译器执行，计算机并不执行
- 其他符号: 如 `+ - * /`,由编译器识别，没有对应的机器码

在内存和磁盘上，指令和数据没有任何区别，都是二进制信息。

```bash
1000100111011000     -> 89D8H     (数据)
1000100111011000     -> mov ax,bx (指令)
```

在计算机中专门有连接CPU和其他芯片的导线，通常称为总线:

- 地址总线: CPU通过它来指定内存单元地址，`8086 CPU`的地址总线宽度为20,寻址范围为`0 ~ 2^20`
- 控制总线: CPU与内存或者其他器件之间的数据传送是通过数据总线来进行的，`8086 CPU`的数据总线宽度为16,可以一次性传送16`bit`数据
- 数据总线: 是一些不同控制线的集合，比如"读信号"控制线、"写信号"控制线

存储器(内存)中的存储单元从零开始顺序编号，一个存储单元是8`bit`。

### 接口卡

直接控制显示器、音响、打印机(外设)工作的器件叫接口卡，`CPU`与接口卡通过总线相连，实现间接控制。

### 内存地址空间

`CPU`将系统中的各类存储器看作一个逻辑存储器，给每个物理存储器划分了内存地址范围。

![2019-09-10 16-23-04 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/55e616a938637790332a3e4c26422148.png)

`8086 CPU`的内存地址空间的分配情况:

![2019-09-10 17-08-04 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/039a634e1592d35c4db4576cbea8d04a.png)

## 2. 寄存器

在CPU中:

- 运算器进行信息处理
- 寄存器进行信息存储
- 控制器控制各种器件工作
- 内部总线连接各种器件，在它们之间进行数据传输

通用寄存器: `AX` `BX` `CX` `DX`，为16位寄存器，然后它们每个又可以分为两个寄存器,例如 `AH` 和 `AL`。

![2019-09-10 18-09-05 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/722d78f60a384bbecf6622c0a10232b1.png)

几条汇编指令

```asm
mov ax, 18    # ax = 18
add ax, 8     # ax = ax + 8
mov ax, bx    # ax = bx
add ax, bx    # ax = ax + bx
```

`8086 CPU`的寄存器，数据总线等长度都是16位，也就是说能一次性处理的、传输、存储的信息为16位。那么该CPU如何生成20位的信息，供20位宽度的地址总线寻址使用呢？

答案是 : `物理地址 = 段地址 * 16 + 偏移地址`

![2019-09-10 18-16-21 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/f9a345d0de33a0faf8b1c7c2fdfddb6f.png)

![2019-09-10 18-16-42 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/c421eed8fac926efc6acdcc198ee1bf5.png)

关于段地址与偏移地址的一些结论:

- 可以用不同的段地址和偏移地址，形成同一个物理地址
- 给定一个段地址，只改变偏移地址，最多可以定位`64KB`(2^16)内存单元。

段寄存器: `CS` `DS` `SS` `ES`。

指令指针寄存器: `IP`。

在`8086 CPU`中，任意时刻，CPU都将`CS:IP`指向的内存地址处的二进制信息，当作指令来执行。

![2019-09-10 18-26-00 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/8f4a260a2621506e114da563b8f7deb3.png)

读取一条完整指令后，`IP`中的值自动增加指令所占用的字节数，此时`CS:IP`指向`2000:0003`,即下一条指令开始位置。

![2019-09-10 18-27-36 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/0430b60fc5202d4eb08909806b68197d.png)

执行控制器将一条指令执行完毕后，`CPU`继续读取`CS:IP`指向的下一条指令，依次执行完所有指令。

![2019-09-10 19-51-29 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/51a19b312400ef6ba0488177fadaf840.png)

`8086 CPU`加电启动后，默认`CS=FFFFH IP=0000H`，即从`FFFF0H`开始读取指令执行，`FFFF0H`处的指令就是`8086 CPU`开机后执行的第一条指令。

在内存中，指令和数据都是二进制信息存储，没有任何区别。所以`CPU`在工作时，从内存中取二进制信息时，是如何区分指令与数据的呢？

答案就是`CPU`将`CS:IP`指向的内存单元看作指令，而将`DS`等地址寄存器指向的内存单元当作数据，也就是说我们在内存中存入一段指令，只需要将`CS:IP`指向这段指令的起始地址，`CPU`就知道这里的二进制信息就是将要执行的指令了。

修改`CS` `IP`寄存器的汇编指令:

```asm
jmp 2AE3:3      # 执行后 CS = 2AE3H  IP = 0003H
mov ax,1000H    
jmp ax          # 执行后 CS 不变，IP = 1000H
```

### Debug 工具

`Debug`是`DOS`、`Windows`的实模式下程序的调试工具。使用它可以查看`CPU`中各种寄存器、内存以及在机器码级别跟踪程序的运行。

启动`dosbox`后，直接运行`debug`进入调试界面。

`-r`查看寄存器:

![2019-09-10 20-14-47 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/60ccebfbef77d339e33d6103cb186418.png)

`-r 寄存器`修改寄存器的值:

![2019-09-10 21-39-51 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/42882b50e3d4895f6ef815fbb1edd9f1.png)

`-d CS:IP`查看内存(`1000:0`处开始，128个字节的内存的值):

![2019-09-10 21-43-57 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/52eaf74828149e7d0af0c03da91a8e7b.png)

`-e CS:IP 数据`连续修改指定内存的值:

![2019-09-10 21-48-22 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/dc546dd775b8260fa22ced552da6ac5f.png)

`-u CS:IP`指定内存地址，按指令解释二进制信息:

![2019-09-10 22-42-25 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/3575e2840c498a1f32c86cc4fab80a32.png)

`-t`单步执行`CS:IP`指向的指令:

![2019-09-10 23-06-05 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/7c2095d8c223db5f3d332dbbf5ef9194.png)

`-a CS:IP`以汇编语言的方式写入机器指令到内存中

![2019-09-10 23-13-23 的屏幕截图.png](https://img.codekissyoung.com/2019/09/10/cc8abbc43a914608244c4b77b672b639.png)

## 3. 寄存器 内存访问

`CPU`读写一个内存单元时，必须给出这个内存单元的地址，在`8086PC`中，内存地址由段地址和偏移地址组成。其中段地址由`DS`寄存器指定。比如读取`10000H`单元的内容:

```masm
mov bx,1000H
mov ds,bx      # 8086 不支持直接将数据送入段寄存器的操作，所以这里使用了 bx
mov al,[0]     # 传送一个 字节
mov cx,[0]     # 传送一个 字
```

### CPU 提供的栈机制

`8086 CPU`提供相关的指令，以栈的方式访问内存空间。

任意时刻，`SS:SP`寄存器指向栈顶元素。`8086CPU`中，栈顶从高地址向低地址方向增长，它不保证我们对栈的操作不会越界。栈操作都是以字为单位。用栈来暂存以后需要恢复的寄存器的内容时，寄存器出栈的顺序要和入栈的顺序相反。

```asm
push 寄存器      # 将一个寄存器中的数据入栈
pop  寄存器      # 将一个寄存器中的数据出栈
push [0]         # 将1000:0 处的字压入栈
pop [2]          # 出栈，数据存入1000:2处
```

`push`、`pop`指令执行后，只会递增或者`SP`的大小，栈空的时候,`SP=0`，一直压栈，栈满时，`SP=0`,如果再次压栈，将覆盖写入之前的栈。所以对于一个确定的`SS`地址，一个栈段的最大容量为`64KB`。

用一个段地址指示段，用偏移地址访问段内的存储单元，完全是我们自己的安排。

用一个段存放数据，称为`数据段`，段地址存于`DS`中。使用`mov`、`add`、`sub` 访问内存单元时，CPU将这个段里的二进制信息，当作数据来使用。

用一个段存放代码，称为`代码段`，段地址存于`CS`中。将段中第一条指令的偏移地址放在`IP`中，这样CPU就将执行我们定义的代码段中的命令。

用一个段当作栈，称为`栈段`,段地址存于`SS`中，将栈顶单元的偏移地址放在`SP`中，这样CPU在进行`push`、`pop`操作时，就将我们定义的栈段当作栈空间来用。

CPU将内存中的某段内容当作代码，只是因为`CS:IP`指向了那里;CPU将某段内存当作栈，只是因为`SS:IP`指向了那里。

## 4. 第一个程序

## 5. [BX]和loop指令

## 6. 包含多个段的程序

## 7. 更灵活地定位内存地址的方法

## 8. 数据处理的两个基本问题

- 处理的数据在什么地方?
- 要处理的数据有多长?

## 9. 转移指令的原理

## 10. CALL 和 RET 指令

## 11. 标志寄存器

## 12. 内中断

## 13. int 指令

## 14. 端口

## 15. 外中断

## 16. 直接定址表

## 17. 使用BIOS进行键盘输入和磁盘读写


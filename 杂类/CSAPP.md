# 深入理解计算机系统

《深入理解计算机系统》第3版笔记。

## 1. 系统漫游

#### 编译流程

![编译流程](https://img.codekissyoung.com/2019/10/07/1da6efa564b71d4b0d79bb3742020acb.png)

#### 系统硬件

![系统硬件](https://img.codekissyoung.com/2019/10/07/73e58c74a0eea7f9f53c1c4bdae601db.png)

#### 进程

系统保持跟踪进程运行所需的所有状态信息，这种状态称为“上下文”，它包括了程序计数器PC、各个寄存器、使用到的内存。在任一时刻，一个处理器只能执行一个进程的指令。

当系统决定将控制权从当前进程转移到另一个进程时，就会进行“上下文切换”，即保存当前进程的“上下文”，然后加载别的进程的“上下文”。

![进程切换](https://img.codekissyoung.com/2019/10/07/f0075e2ea7d34bba34ebd3ed9329c0af.png)

#### 文件

文件就是字节序列，仅此而已。每个IO设备，磁盘、键盘、显示器、网络，都可以看成是文件。

## 2. 信息的表示与处理

### 整数

对于整数，使用有限位来编码的方式进行表示。并且区分了两种编码：有符号编码、有符号编码。

```bash
自然数字            有符号编码          无符号编码
0                   0000 0000           0000 0000
-1                  1111 1111           无编码
-2                  1111 1110           无编码
1                   0000 0001           0000 0001
2                   0000 0010           0000 0010
130                 溢出错误            1000 0010            
```

有限的位只能表示有限的整数，所以当运算结果超出了表示范围，就会触发CPU产生溢出错误中断。

#### 移位运算

左移: 丢弃最高位，然后向左移动，不足位数补0。

右移:

- 无符号数: 丢弃最低位，然后向右移动，左边补0。(逻辑右移)
- 有符号数: **没有统一**，大多数编译器采用算术右移，即根据有符号数的正负来决定，左边是补0还是补1，极个别编译器采用逻辑右移

![移位运算](https://img.codekissyoung.com/2019/10/07/13f248f2c8b17769da076ee9e028940d.png)

#### 强制类型转换

同样位数的无符号数与有符号数相互转换：数值可能会改变，但是底层的二进制数不变。

![可能出现问题的比较](https://img.codekissyoung.com/2019/10/07/9fb9102bb8cbee56588919fa13b6c4e6.png)

#### 低位数向高位数转换

对于无符号数，直接补0。有符号数，如果是正数，补0; 如果是负数，补1。

```
自然数      char       ->   short
139         1000 1011       0000 0000 1000 1011     (无符号编码)
11          0000 1011       0000 0000 0000 1011     (有符号编码)
-81         1010 1111       1111 1111 1010 1111     (有符号编码)
```

#### 高位数向低位数转换

截断


> 除 C 语言外，很少有语言支持无符号整数，它带来的漏洞比它带来的好处(多了一倍可用的正数)更多。因此，Java 被设计成只支持有符号整数，并且规定底层使用补码来实现。>> 被定义成算术右移，>>> 被定义成逻辑右移。

### 浮点数

浮点数的编码与实现是与整数完全不同的。

它最大缺点在于精度有限，会带来一些计算错误，比如`(3.14 + 1e20) - 1e20`的计算结果是`0.0`,而`3.14 + (1e20 - 1e20)`的结果是`3.14`,正是由于精度问题，`1e20`是一个非常大的数，加上`3.14`也没有可以表示它们的位。


## 3. 机器代码

## 4. 指令体系结构

## 5. 优化程序性能

## 6. 存储器层次结构

## 7. 链接

## 8. 异常控制流

## 9. 虚拟内存

## 10. 系统级I/O

## 11. 网络编程

## 12. 并发编程
# 深入理解计算机系统

《深入理解计算机系统》第3版笔记。

## 1. 系统漫游

#### 编译流程

![编译流程](https://img.codekissyoung.com/2019/10/07/1da6efa564b71d4b0d79bb3742020acb.png)

#### 系统硬件

![系统硬件](https://img.codekissyoung.com/2019/10/07/73e58c74a0eea7f9f53c1c4bdae601db.png)

CMOS是一块芯片，记录计算机硬件信息。BIOS 是可以修改 CMOS 的程序，该程序为写死在硬件上，不可修改。硬件开机，第一个执行的程序便是 BIOS ，然后再是操作系统的引导程序（MBR：主引导记录，GRUB：统一引导加载器），然后是操作系统内核，再是内核上的操作系统。

#### 进程

系统保持跟踪进程运行所需的所有状态信息，这种状态称为“上下文”，它包括了程序计数器PC、各个寄存器、使用到的内存。在任一时刻，一个处理器只能执行一个进程的指令。

当系统决定将控制权从当前进程转移到另一个进程时，就会进行“上下文切换”，即保存当前进程的“上下文”，然后加载别的进程的“上下文”。

![进程切换](https://img.codekissyoung.com/2019/10/07/f0075e2ea7d34bba34ebd3ed9329c0af.png)

#### 虚拟内存

- 虚拟内存为进程提供了一个假象，即每个进程都在独占内存,每个进程看到的都是一样的存储器,称为虚拟地址空间
- 每个进程看到的虚拟地址空间由准确定义的区组成,每个区都有专门的功能
- 程序代码区:对所有进程来说，代码是从同一固定地址开始
- C全局变量区:紧邻着程序代码区，存储的的是初始化的数据
- 堆:紧邻着全局变量区,可以动态扩展使用的内存,使用malloc申请,free释放
- 共享库:存在虚拟地址空间中间,存放的是c标准库
- 栈:位于用户虚拟地址空间顶层(它的上面是内核虚拟地址空间，是不允许用户操作的),编译器使用它来实现函数调用，函数调用，栈增长，函数返回，栈消退
- 内核虚拟存储器:位于整个虚拟存储器顶部，是为内核保留的，不允许应用程序读写和直接调用内核代码定义的函数

#### 文件

文件就是字节序列，仅此而已。每个IO设备，磁盘、键盘、显示器、网络，都可以看成是文件。

文件向应用程序提供了一个统一的视角，来看待系统中各式各样的设备,例如，处理磁盘文件内容，无需了解具体的磁盘文件，同一个程序就可以在使用不同磁盘技术的不同系统上运行。

## 2. 信息的表示与处理

### 整数

对于整数，使用有限位来编码的方式进行表示。并且区分了两种编码：有符号编码、有符号编码。

```bash
自然数字            有符号编码          无符号编码
0                   0000 0000           0000 0000
-1                  1111 1111           无编码
-2                  1111 1110           无编码
1                   0000 0001           0000 0001
2                   0000 0010           0000 0010
130                 溢出错误            1000 0010            
```

有限的位只能表示有限的整数，所以当运算结果超出了表示范围，就会触发CPU产生溢出错误中断。

#### 移位运算

左移: 丢弃最高位，然后向左移动，不足位数补0。

右移:

- 无符号数: 丢弃最低位，然后向右移动，左边补0。(逻辑右移)
- 有符号数: **没有统一**，大多数编译器采用算术右移，即根据有符号数的正负来决定，左边是补0还是补1，极个别编译器采用逻辑右移

![移位运算](https://img.codekissyoung.com/2019/10/07/13f248f2c8b17769da076ee9e028940d.png)

#### 强制类型转换

同样位数的无符号数与有符号数相互转换：数值可能会改变，但是底层的二进制数不变。

![可能出现问题的比较](https://img.codekissyoung.com/2019/10/07/9fb9102bb8cbee56588919fa13b6c4e6.png)

#### 低位数向高位数转换

对于无符号数，直接补0。有符号数，如果是正数，补0; 如果是负数，补1。

```
自然数      char       ->   short
139         1000 1011       0000 0000 1000 1011     (无符号编码)
11          0000 1011       0000 0000 0000 1011     (有符号编码)
-81         1010 1111       1111 1111 1010 1111     (有符号编码)
```

#### 高位数向低位数转换

截断


> 除 C 语言外，很少有语言支持无符号整数，它带来的漏洞比它带来的好处(多了一倍可用的正数)更多。因此，Java 被设计成只支持有符号整数，并且规定底层使用补码来实现。>> 被定义成算术右移，>>> 被定义成逻辑右移。

### 浮点数

浮点数的编码与实现是与整数完全不同的。

它最大缺点在于精度有限，会带来一些计算错误，比如`(3.14 + 1e20) - 1e20`的计算结果是`0.0`,而`3.14 + (1e20 - 1e20)`的结果是`3.14`,正是由于精度问题，`1e20`是一个非常大的数，加上`3.14`也没有可以表示它们的位。


## 3. 机器代码

## 4. 指令体系结构

## 5. 优化程序性能

## 6. 存储器层次结构



## 7. 链接

## 8. 异常控制流

## 9. 虚拟内存

#### 程序直接使用存储器的缺点

- 进程太多,存储器不够程序使用的
- 进程间互相不小心篡改彼此的内存数据,进程可能崩溃

- 它将内存 看作是存储在磁盘上的地址空间的 **高速缓存**,在内存中只保留活动的进程,并且根据进程的切换在磁盘和内存之间来回交换数据
- 它为每个进程提供了一致的地址空间,从而简化了存储器管理
- 它保护了每个进程的地址不被其他进程破坏
- 可以创建或者销毁储存器片 chunk
- 可以将存储器片映射到磁盘文件的某个部分,比如你可以通过读写存储器来修改一个磁盘文件的内容,再比如可以不需要显示拷贝,就可以加载一个文件的内容到存储器中
- 进程之间也可以共享某块存储器片

#### 物理和虚拟寻址

- 物理地址:计算机内存被组织成一个连续的数组,每个字节都有一个唯一的物理地址
- 物理寻址:早期的PC是物理寻址的,cpu产生一个物理地址,通过存储器总线传递给主存,主存将该物理地址处的数据取出给CPU,CPU会把数据放在寄存器里
- 虚拟寻址:现在计算机cpu产生一个虚拟地址,这个虚拟地址经过cpu里面的 **存储器管理单元** (Memory Management Unit,MMU)专用硬件的翻译,变成物理地址,然后传给内存

#### 地址空间

- 地址空间: 非负整数的有序集合 {0,1,2,3,4,5...} , 2的n次方个元素,称为地址空间大小
- 虚拟地址空间: cpu从2的n次方的地址空间生成虚拟地址,称为虚拟地址空间
- 物理地址空间: 与系统物理存储器的内存大小对应,有多大的内存就有多大的地址空间
- 数据对象(字节)与地址的区别: 两者是不同的, 一个内存里的字节可以有多个地址与之对应,比如主存中每个字节都有一个虚拟地址空间的虚拟地址和一个物理地址与之对应


## 10. 系统级I/O

## 11. 网络编程

## 12. 并发编程
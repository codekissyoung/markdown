# shell基础
- 设置编辑模式
    ```
    ➜  ~ set -o vi
    ```

## 管道和重定向
- 每个进程都有三个流,`stdin` `stdout` `stderr`,进程不在意这三个流来自哪里，又通向哪里，它们可能链接到一个终端，一个文件，一条网络链接，或者另一个进程的流
- 每个流的命名叫做`文件描述符`，它们依次是0,1,2
- 三个流的默认指向都是终端
- `>` `<` `>>` 是重定向，能改变流的指向
    ```
    ➜  ~ echo "this is a test message" > /tmp/mymessage /*重定向输出到文件*/
    ➜  ~ mail -s "Mail test" cky < /tmp/mymessage /*使用文件里内容发送邮件*/
    ```
- 将错误输出重定向
    ```
    ➜  ~ find / -name core /*没有重定向，stdout与stderr都输出在屏幕*/
    find: ‘/boot/efi’: 权限不够
    /dev/core

    ➜  ~ find / -name core > /tmp/test_output /*只将stdout重定向到文件,stderr还是输出到了屏幕*/
    find: ‘/boot/efi’: 权限不够

    ➜  ~ find / -name core > /tmp/test_output 2> /tmp/null  /*将stderr输出到黑洞，将stdout输出到屏幕*/
    /dev/core
    ```

- 将一条命令的stdout链接到另一条命令的stdin
    ```bash
    ➜  ~ ps -ef | grep ssh                
    cky       1324  1245  0 4月27 ?       00:00:00 /usr/bin/ssh-agent /usr/bin/sogou-session /usr/bin/im-launch /usr/lib/gnome-session/run-systemd-session ubuntu-session.target
    cky       1454  1183  0 4月27 ?       00:00:00 /usr/bin/gnome-keyring-daemon --start --components ssh
    cky      32116  3823  0 18:22 pts/0    00:00:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn ssh

    ➜  ~ cut -d: -f7 < /etc/passwd | sort -u
    /bin/bash
    /bin/false
    /bin/sync
    /usr/bin/zsh
    /usr/sbin/nologin
    ```
- && 与 ||
    ```
    ➜  workspace ls -alh && cat /tmp/t2 /*前一个命令执行成功，后面的命令才会执行*/
    总用量 28K
    drwxr-xr-x  7 cky cky 4.0K 4月  27 14:53 .
    drwxr-xr-x 32 cky cky 4.0K 4月  28 20:27 ..
    drwxr-xr-x  8 cky cky 4.0K 2月  22 22:24 blog
    ...
    hello world


    ➜  workspace ls -alh || cat /tmp/t2 /*前一个命令执行失败，后面的命令才会执行*/
    总用量 28K
    drwxr-xr-x  7 cky cky 4.0K 4月  27 14:53 .
    drwxr-xr-x 32 cky cky 4.0K 4月  28 20:27 ..
    drwxr-xr-x  8 cky cky 4.0K 2月  22 22:24 blog
    drwxr-xr-x  3 cky cky 4.0K 4月  27 12:07 cky
    drwxr-xr-x 26 cky cky 4.0K 4月  27 21:26 linux
    drwxr-xr-x  3 cky cky 4.0K 4月  20 18:59 note
    drwxr-xr-x  3 cky cky 4.0K 4月  14 16:28 sudoku
    ```

# 变量和引用
- 不要在变量两边留空白，否则shell会把变量当做命令
    ```
    ➜  ~ etcdir='/etc'
    ➜  ~ echo $etcdir
    /etc
    ```
- 使用`{}`拓展变量
    ```
    ➜  ~ rev=8
    ➜  ~ echo "the ${rev}th version of config.conf"
    the 8th version of config.conf
    ```

- `''`与`""`的区别 : `''`是不解析`{}$*?`的
    ```
    ➜  ~ myname="codekissyoung"
    ➜  ~ echo "i am ${myname}"
    i am codekissyoung
    ➜  ~ echo 'i am ${myname}'
    i am ${myname}
    ➜  ~ echo "there was `wc -l /etc/passwd` lines in passwd file" /* `` 可以被解析，它的意思是把里面的字符串执行，返回结果*/
    there was 45 /etc/passwd lines in passwd file
    ```


- 环境变量
    ```
    ➜  ~ export abc=123 /*声明一个环境变量*/
    ➜  ~ env /*输出所有环境变量*/
    XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat0
    XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg
    LC_TELEPHONE=zh_CN.UTF-8
    LANG=zh_CN.UTF-8
    DISPLAY=:0
    SHLVL=2
    LOGNAME=cky
    LANGUAGE=zh_CN:zh:en_US:en
    INVOCATION_ID=d1774be268ce4fcc816f39a929989c7f
    MANDATORY_PATH=/usr/share/gconf/ubuntu.mandatory.path
    PWD=/home/cky
    ... /*省略部分代码*/
    abc=123
    ```
用户登录终端时设置的那些环境变量都在`~/profile`和`~/.bash_profile`里，而像`PWD`这样的环境变量，由shell自动维护

# bash 脚本编程

- read
    ```shell
    #!/bin/bash
    # -n 消除了通常的换行符
    echo -n "enter your name:"
    read user_name
    # 判断user_name是否为空，注意if等指令与其他字符相邻，中间要加空格
    if [ -n "$user_name" ];then
    	echo $user_name;
    	exit 0
    else
    	echo "you do not enter username"
    	exit 1
    fi
    ```

- 命令行参数
    ```shell
    #!/bin/bash
    echo "脚本名字:$0"
    echo "第一个参数:$1"
    echo "总共的参数个数:$#"
    echo "全部参数:$*"

    ```
    ```shell
    ➜  shell ./params aa bb cc
    脚本名字:./params
    第一个参数:aa
    总共的参数个数:3
    全部参数:aa bb cc
    ```

- 函数和局部变量
    ```bash
    #!/bin/bash
    function localizer {
    	echo "全局变量的a是${a}"
        #声明局部变量
    	local a="local a"
    	echo "局部变量a是$a"
    }

    a="global a"

    #调用函数
    localizer
    echo "调用完函数后的a是$a"
    ```

    ```
    ➜  shell ./localizer
    全局变量的a是global a
    局部变量a是local a
    调用完函数后的a是global a
    ```

- 控制流程
    ```bash
    #!/bin/bash
    a=10
    b=10
    if [ $a == $b ] && [ -n $a ]
    then
       echo "a 等于 b"
    elif [ $a -gt $b ]
    then
       echo "a 大于 b"
    elif [ $a -lt $b ]
    then
       echo "a 小于 b"
    else
       echo "没有符合的条件"
    fi
    ```

    ```bash
    /bin/test命令,[]是调用test命令的一种快捷方式
    x -eq y : x=y
    x -ne y : x!=y
    x -lt y : x<y
    x -le y : x<=y
    x -gt y : x>y
    x -ge y : x>=y
    -n x : x 不为空
    -z x : x 为空
    -d file : file是目录
    -e file : file存在
    -f file : file存在且是普通文件
    -s file : file存在且不为空
    -r file : 用户有file文件的读权限
    -w file : 用户有file文件的写权限
    file1 -nt file2 : file1比file2新
    file1 -ot file2 : file1比file2旧
    ```

- case 语句
    ```bash
    #!/bin/bash
    a=1
    case $a in
    0)
    echo "就是0嘛"
    ;;
    1)
    echo "就是1嘛"
    echo "再输出一句"
    ;;
    *)
    echo "就是其他嘛"
    ;;
    esac
    ```

- for 循环，in后面是一个模式，它能匹配当前目录下能够匹配的文件列表，实际上，任何以空白分割的对象列表，包括一个变量的内容，都可以充当`for...in`语句的主体

    ```bash
    #!/bin/bash
    for script in *
    do
    	echo $script
    done
    ```

    ```
    ➜  shell ./while
    case
    ifelse
    localizer
    params
    perl
    python
    read
    while
    ```

- while

    ```bash
    #!/bin/bash
    exec 0<$1
    counter=1
    while read line
    do
    	echo "$counter : $line"
    	counter=`expr $counter + 1`
    done
    ```

    `exec 0<$1`将标准输入变成第一个参数，所以第一个参数必须是文件，否则会出错
    `read line`就是读取文件里的一行数据，进行处理,加上`while`就是依次读取了
    `expr $counter + 1` 是shell的算术处理方法

- 数组和算术
    - shell里`+`只是一个普通的字符，没有任何其他含义
    - shell里数组基本没啥用


# 正则表达式
- 正则表达式要区分于shell的通配符匹配
- 普通字符匹配
    ```
    i am codekissyoung
    ```
- 特殊字符匹配
    ```
    . 匹配任何字符
    [chars] 匹配任何给定字符集里面的字符
    [^chars] 匹配给定字符集之外的字符
    ^ 匹配行首
    $ 匹配行尾
    \w 匹配[A-Za-z0=9]
    \s 匹配空白 [\f\t\n\r]
    \d 匹配数组 [0-9]
    | 匹配左边或者右边的任何一个
    (expr) 限定范围，元素成组,从而可以捕获到匹配
    ```

- 数量匹配
    ```
    ? 匹配前面元素的 0 个或者 1个
    * 任意个
    + 1个或者多个
    {n} n 个
    {min,} min 个以上
    {min,max} min 到 max 之间个
    ```
- 示例
    ```
    i am (codekissyoung|caokaiyan)\.
    匹配：i am codekissyoung. 和 i am caokaiyan.
    (i am (codekissyoung|caokaiyan)\.){1,2}
    匹配：i am codekissyoung. 和 i am caokaiyan. 和 i am codekissyoung.i am caokaiyan. 和 i am codekissyoung.i am codekissyoung. 等
    ```

- 捕获
每个`()`里面内容的匹配称为捕获，是实现正则表达式的内部机理，不做过于深入

- 贪心 懒惰 和 灾难性的回溯
简单的说，贪心就是尽量多匹配几个字符，懒惰就是尽量少匹配几个

# Python 脚本
- 缩行代表逻辑块
    ```python
    #!/usr/bin/python
    #coding=utf-8
    import sys
    a = sys.argv[1]
    if a == "1":
    	print 'a is one'
    	print 'if 汉子'
    else:
    	print 'a is ',a
    	print "else"
    print "after if else"
    ```

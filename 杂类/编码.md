# 编码 隐匿在计算机软硬件背后的语言

《编码 隐匿在计算机软硬件背后的语言》一书的笔记。

## 1. 手电筒通信

`... --- ...`是字母`SOS`的莫斯编码。

## 2. 编码与组合

通过一张`.`与`-`的树形图，译码过程更直观方便:

![莫斯编码图](https://img.codekissyoung.com/2019/08/12/dd541a9b02e95d4308f319ec03e84923.png)

## 3. 布莱叶盲文与二进制编码

![布莱叶盲文](https://img.codekissyoung.com/2019/08/12/a4deae14350d7cf9b78c10a683a46dc4.png)

二进制码:编码的组成元素只有两个，比如`.`和`-`、`0`和`1`。

## 4. 手电筒的原理

讲了物理学上对电的一些认识。

## 5. 双向莫斯电码系统

下图，包含的元素包括:电压、开关、灯泡、接地。开关合上后，电压与接地形成电子通路，电子流经灯泡，使灯泡发光。

![双向莫斯电码系统](https://img.codekissyoung.com/2019/08/12/3825ac249478b845dd7c1cc843a0d75f.png)

## 6. 电报机与继电器

1844年，第一条电报线路在华盛顿假设完成，传输了第一条消息`What hath God wrought`。下图是电报机的原理，一端电报按键控制另一端的电磁铁。

![电报机](https://img.codekissyoung.com/2019/08/12/1e4f7e9d82bf58c8a7ace2da9097fa14.png)

为了解决长距离电线，电阻增大，信号衰退的问题，设计出了继电器，原理如下。

![继电器](https://img.codekissyoung.com/2019/08/12/3795868e228621cafe2a3e7e2f58003e.png)

## 7. 十进制计数法

阿拉伯数字系统，符号（0123456789ABCDEF等） + 位置（个位、十位、百位）组合表示一个数字。 

![十进制数](https://img.codekissyoung.com/2019/08/13/c746c8026b66e2d08d676e9c77fea98e.png)

## ８．十进制的替代品 其他进制数

### 八进制

![深度截图_选择区域_20190813160728.png](https://img.codekissyoung.com/2019/08/13/dc2c7ac86c55f621d7020f47484ad20a.png)

八进制乘法表:

![深度截图_选择区域_20190813155057.png](https://img.codekissyoung.com/2019/08/13/48772321f4538ab9a5d011094e7f43cc.png)

### 四进制

![深度截图_选择区域_20190813160403.png](https://img.codekissyoung.com/2019/08/13/d2a9fccd8b992c2a4ceb7d397c98d62a.png)

### 二进制

二进制加法:

![深度截图_选择区域_20190813161051.png](https://img.codekissyoung.com/2019/08/13/dd79a6c390b0f5b47f1e8d25ef2e1a4d.png)

二进制乘法:

![深度截图_选择区域_20190813161143.png](https://img.codekissyoung.com/2019/08/13/d9296b1bfc3f59032b4ae023ad9edbf6.png)

## 9.二进制数

![深度截图_选择区域_20190813173414.png](https://img.codekissyoung.com/2019/08/13/bd78fb067dd3ad9805ffb23ee0af325a.png)

![深度截图_选择区域_20190813175740.png](https://img.codekissyoung.com/2019/08/13/8f180956ca0ae338e78a19a5dc7d3f7f.png)

商品的条形码:

- 扫码时，要么正向扫，依据编码表得到`0 51000 01251 7` 这串数字
- 逆向扫，依据逆向的编码表得到:`7 15210 00015 0`这串数字

## 10. 逻辑与开关

![深度截图_选择区域_20190813193931.png](https://img.codekissyoung.com/2019/08/13/53e57280f28ec44f21d1d6c2a82e0646.png)

## 11. 门电路

与门:

![深度截图_选择区域_20190813193259.png](https://img.codekissyoung.com/2019/08/13/408c93c05019b054865d2fb37d1e715b.png)

![深度截图_选择区域_20190813193419.png](https://img.codekissyoung.com/2019/08/13/1adbe1dd849f2f5abf22cd1856b01715.png)

或门:

![深度截图_选择区域_20190813194544.png](https://img.codekissyoung.com/2019/08/13/8c18c10c3ea8be397546920bbce412de.png)

![深度截图_选择区域_20190813194655.png](https://img.codekissyoung.com/2019/08/13/ba7666457f17b5665f98b4bb68f6d4b1.png)

非门:

![深度截图_选择区域_20190813193707.png](https://img.codekissyoung.com/2019/08/13/460d1eccab82dfb352b49cae060f53f2.png)

或非门:

![深度截图_选择区域_20190815153945.png](https://img.codekissyoung.com/2019/08/15/23ea35e700edebadd3e3a28777a6961e.png)

与非门:

![深度截图_选择区域_20190815154221.png](https://img.codekissyoung.com/2019/08/15/942679e7aee5d372298a367493f3f27d.png)

异或门:

![深度截图_选择区域_20190815154433.png](https://img.codekissyoung.com/2019/08/15/a547377b66cd6b13a11dc21aa9fbd29e.png)


## 12. 二进制加法器

加法计算是计算机需要实现的唯一工作。如果可以实现加法器，那么就可以利用加法器来实现减法、乘法和除法计算。

二进制的加法表:

![深度截图_选择区域_20190815152953.png](https://img.codekissyoung.com/2019/08/15/83a05f3e44e148234cd7c1ba7fce484a.png)

用逻辑电路来实现上述加法表:

![深度截图_选择区域_20190815153241.png](https://img.codekissyoung.com/2019/08/15/390b42fe6be59520ef6bd5cb6a17bbcc.png)

就构成了一个半加器，它只能用来算1位二进制数的，也就是说，它只能计算出两个任意二进制数的最低位。

![深度截图_选择区域_20190815154722.png](https://img.codekissyoung.com/2019/08/15/9637920298f5d1d3a040e7e2ad6de71b.png)

对于上图二进制加法，右数第二位的相加后，还需要与低位产生的进位再次相加，才能得到结果，所以设计出了全加器:

![深度截图_选择区域_20190815155304.png](https://img.codekissyoung.com/2019/08/15/9b64528f15a45b3db94ff4683f5abb8c.png)

### 一个8位的二进制加法器

操作界面图:

上面的开关是人操作的，用于输入两个二进制数，确定两个二进制数后，下面的指示灯的明灭代表输出的二进制数的`0`和`1`。

![深度截图_选择区域_20190815155521.png](https://img.codekissyoung.com/2019/08/15/dc248d474903dba7d062de50b123a845.png)

实现:

最低位:没有进位，所以进位输入接地，表示`0`

![深度截图_选择区域_20190815160054.png](https://img.codekissyoung.com/2019/08/15/644986b76298376094b4f122e7e49c68.png)

中间位数:全加器依次相联

![深度截图_选择区域_20190815160208.png](https://img.codekissyoung.com/2019/08/15/2309aefb8f1778a43cb9872dea478a57.png)

最高位:进位接灯泡

![深度截图_选择区域_20190815160253.png](https://img.codekissyoung.com/2019/08/15/b4eddf698996460d26c50ce3422a1c94.png)

合在一起就是:

![深度截图_选择区域_20190815160405.png](https://img.codekissyoung.com/2019/08/15/adbe4ceb5ba63af272106cf6722a8c0f.png)

8位加法器简化:

![深度截图_选择区域_20190815160803.png](https://img.codekissyoung.com/2019/08/15/c5e2447bff078d8901627e251658e7d9.png)

再次简化:

![深度截图_选择区域_20190815160844.png](https://img.codekissyoung.com/2019/08/15/251dd970a3f39970fe6d4ad3b54b1b4f.png)

因此我们可以很容易画出16位加法器的设计图:

![深度截图_选择区域_20190815160950.png](https://img.codekissyoung.com/2019/08/15/4e402c31c02a8b66a67f9dcdd6c0f6f0.png)

## 13. 如何实现减法

理论上来说可以参考加法器的设计方法和思路，设计出一个减法器。但是这样子的话，计算机的运算器实现里面就有两种电路的存在，一种加法器电路，一个减法器电路。这样的实现必定是浪费材料和空间的。那么能不能找到一种方法，让减法也可以通过加法器完成。

在自然数学中，`16 - 8 = 8`可以写成`16 + (-8) = 8`，`23 - 87 = -64`可以写成`23 + (-87) = -64`，那么参考加法器的构造:

![深度截图_选择区域_20190815160844.png](https://img.codekissyoung.com/2019/08/15/251dd970a3f39970fe6d4ad3b54b1b4f.png)

于是，我们有了:

```
0001 0000(16)   - ?(-8) = 0000 1000(8)
0001 0111(23)   - ?(-87) = ?(-64)
```

加法器的B输入是一个负数，那么这个负数的二进制表示是什么，才能够使上述等式成立，并且输出的数据，我们通过8位加法器的灯也能读懂。

我们可以先来考虑一个简单的:

```
0000 0001(1) + ?(-1) = 0000 0000(0) 
```

同时我们也知道，加法器中:
```
0000 0001(1) + 1111 1111(255) = 1 0000 0000(256)
```

上面式子中的`1`是进位，如果我们不看进位的值，即将进位舍去，那么我们使用`1111 1111`这个二进制数作为`-1`的二进制表示:

```
0000 0001(1) + 1111 1111(-1) = 1 0000 0000(0) 
```

同理，我们可以:

```
0000 1000(8) + ?(-8) = 1 0000 0000(0)  
```

推算可知，能够符合加法器运算的，`-8`的二进制是`1111 1000`。

观察下，该二进制也可以写成`1111 0111 + 0000 0001`，也就是`8`的二进制数的每一位取反后，再加上`1`。

根据以上讨论，我们可以得出下表:
```
二进制数      表示的十进制数
1000 0000    -128
1000 0001    -127
1000 0010    -126
...
1111 1101    -3
1111 1110    -2
1111 1111    -1
0000 0000    0
0000 0001    1
0000 0010    2
0000 0011    3
...
0111 1110    126
0111 1111    127
```
可以验证下，上表的二进制数，可以通过加法器的运算正确的表示8进制加减法。当执行`126 + 125`或者`-123 - 78`这样的运算时，8位加法器的进位的值为`1`，表示这个算式产生的结果已经无法使用8位二进制数表示。所以对于8位加法器，只能够表达有限整数范围内的算数运算。这个有限范围指的是，A输入、B输入以及最后的计算结果都要落在`-128 ~ 127`这个范围内，否则就是溢出错误。

我们将这种方式推广到64位加法器，这样能够表达的运算范围就非常大了。


## 14 反馈与触发器

### 蜂鸣器

开关连通后，电路闭合(图二)，电磁铁把弹簧拉下从而电路断开(图三)，电磁铁失去磁力弹片回到原来位置，电路又闭合(图四)，周而复始。

![深度截图_选择区域_20190815191430.png](https://img.codekissyoung.com/2019/08/15/28899fa6b082a8180865138d775602fc.png)

改良后的蜂鸣器:

![深度截图_选择区域_20190815192301.png](https://img.codekissyoung.com/2019/08/15/c8a57b061cf86bf039177bb82bcfedfa.png)

### 振荡器

左边图是取反器(非门)，如果将它的输出连接到输入，就构成了一个蜂鸣器(图中)，逻辑图见右上角，这段线路的输出在周期时间内一直在`0`与`1`之间震荡。每秒钟震荡的次数称为赫兹，是计量单位。

![深度截图_选择区域_20190815195104.png](https://img.codekissyoung.com/2019/08/15/b2ac6bf5920472164009b2c1fa8c2ebc.png)

### RS触发器

下图是使用或非门构建的一个触发器电路，上面的开关闭合使点亮灯泡，当它断开时，灯泡保持亮状态:

![深度截图_选择区域_20190815200521.png](https://img.codekissyoung.com/2019/08/15/625c758517ceb9706082d886869129b2.png)

下图，当下面开关闭合时，灯泡关闭，当开关断开时，灯泡仍然保持关闭状态:

![深度截图_选择区域_20190815200810.png](https://img.codekissyoung.com/2019/08/15/0326e2b9f8c7c50d007b4396bbef7184.png)

这就是触发器电路，当两个开关都断开时，电路处于两个稳定状态之一，也就是说它有记忆性，可以记住最近一次时哪个开关闭合了。

上面是触发器最简单的一种，称为`R-S`触发器，也叫作`R-S`锁存器。

![深度截图_选择区域_20190815205216.png](https://img.codekissyoung.com/2019/08/15/094212081756198156d81137fe8bdeb9.png)

RS触发器可以实现，在`R`与`S`都为`0`情况下(开关都关闭):
- 通过`S`位设置为`1`来将`Q`设置为`1`，即便`S`位再次变为`0`，`Q`的输出依然保持为`1`
- 同理，通过将`R`设置为`1`，来将`Q`重置为`0`

### D位触发器

有了RS触发器作为基础，我们再来构思这样一种触发器,有一个数据端与一个保持位作为输入,有一个输出端:

- 当保持位为`1`时，输出的就是数据端的输入(`0`或`1`)
- 当保持位被置为`0`时，无论数据端的值是什么，都不会再改变输出端的值

![2019-08-20 19-40-24 的屏幕截图.png](https://img.codekissyoung.com/2019/08/20/8c6d697295a1f1269c9c72e739bbfcfb.png)

观察RS触发器表与D位触发器表:`Q`的值与`S`的值是一致的，当`S`与`R`的都为`0`时，`Q`的值是不变的。

利用RS触发器电路作为基础来实现D位触发器:使用与门实现保持位，当保持位置为`0`时，RS触发器的输入就都是`0`，不再影响`Q`的值。

![2019-08-20 19-48-00 的屏幕截图.png](https://img.codekissyoung.com/2019/08/20/3e813dc4f0ceb558dd77883d2cdb3ede.png)

上图中，保持位决定置位能不能修改`Q`的值，当保持位为`1`时，置位的值决定了`Q`的值，现在的问题是，如何去掉无用的`R`位。观察下RS触发器表，可知使用一个非门，就可以实现:

![2019-08-20 20-14-23 的屏幕截图.png](https://img.codekissyoung.com/2019/08/20/214a8eca32f6a1f13ee129ab49d03b94.png)

当保持位接入到一个时钟(振荡器)上，简写为`Clk`,数据端简写为`D`,下图即为D型触发器表:

![2019-08-20 20-19-00 的屏幕截图.png](https://img.codekissyoung.com/2019/08/20/d3857a8df911b61b5f601eb4a5d34ec8.png)

### 8位锁存器

如果将8个D位触发器连接起来，就构成了一个8位锁存器，它可以用来存储一个8位二进制数据了:

![2019-08-20 20-22-05 的屏幕截图.png](https://img.codekissyoung.com/2019/08/20/dfaa9460c14a965e155ef74a0ce13faf.png)

### 改进加法器

参考之前章节的加法器，有A,B两排输入，有灯泡作为输出，现在想让8位存储器存下加法器的输出，并且可以选择作为下一次加法的输入:

![2019-08-20 20-29-31 的屏幕截图.png](https://img.codekissyoung.com/2019/08/20/b9972fd04be590aeab4911ff35e8a5ca.png)

上图中`2-1`的选择器实现如下:

![2019-08-20 20-33-33 的屏幕截图.png](https://img.codekissyoung.com/2019/08/20/c147725a269b533876e828c0790ee77b.png)

有了8位锁存器后，我们可以考虑将加法机器的第二排开关去掉，理由是:

- 第一次使用第一排开关输入的值可以存储到锁存器中，然后再次使用第一排开关输入一个数，该数与存储器中的数相加后，再次存入8位锁存器。
- 如果使用递推逻辑的话，第一次输入时，应该是该数与锁存器中的`0`相加后再次存入锁存器。

所以我们对D位触发器做一点小修改，使得无论输入端是什么，`Q`强制输出`0`:

![2019-08-20 20-43-29 的屏幕截图.png](https://img.codekissyoung.com/2019/08/20/2d90b6709916b873e7b54de0486e8f19.png)

优化后的加法机器如下:

![2019-08-20 20-45-14 的屏幕截图.png](https://img.codekissyoung.com/2019/08/20/5e36fefeebcb0902968be6fdc17e8a9f.png)

你可能会发现这个加法器比前面那个好用,尤其是当你需要加上一长串数字时。

- 刚开始时,按下清零开关,这个操作使锁存器输出为`0`,并熄灭了所有的灯泡,同时使加法器的`B`端输入全为`0`
- 接着,通过开关输入第一个加数,闭合“相加”开关,则此加数反映在灯泡上
- 再输入第二个数并再次闭合“相加”开关,由开关输入的 8位操作数加到前面的结果上,其和输出到灯泡。

如此反复,可以连加很多数。

### 电平触发 与 边沿触发

上述的触发器都是**电平触发式**的，意思是只有在时钟端输入从`0`变到`1`后(即高电平时),数据端输入的值才能保存在锁存器中，并且**在时钟端输入为 1期间,数据端输入的任何改变都将反应在Q上**。对于一般的应用，电平触发已经够用了。

**边沿触发**对输出的改变条件要求更加严格，对于边沿触发器而言，只有当时钟从`0`变到`1`的**瞬间**,输出才会改变。而当时钟输入维持为`1`时,数据端输入的改变也不会影响输出。

边沿触发的 D型触发器是由两级 R - S触发器按如下方式连接而成的

非工作状态:
![2019-08-20 20-56-59 的屏幕截图.png](https://img.codekissyoung.com/2019/08/20/17715381952dd4db9a88ea4b2badaf6c.png)

现在使数据端输入为`1`,这改变了第一级触发器状态,因为时钟信号取反后为`1`。但第二级仍保持不变,因为时钟
端输入仍为`0`。

![2019-08-20 20-58-10 的屏幕截图.png](https://img.codekissyoung.com/2019/08/20/cb72ee5d224752b589a7d615ac0f547a.png)

现在把时钟输入变为`1`,这就引起第二级触发器改变,使 Q端输出变为 1。

![2019-08-20 20-59-56 的屏幕截图.png](https://img.codekissyoung.com/2019/08/20/55884b1f073d6f3eb2d0cb1c12a58c48.png)

与前面不同的是现在无论数据端输入如何变化(如变为`0`),它也不会影响`Q`端的输出值。

![2019-08-20 21-03-35 的屏幕截图.png](https://img.codekissyoung.com/2019/08/20/a108052a8a7fd36373e4990c469ac003.png)

边沿触发的 D型触发器的功能表需要一个新符号来表示这种从 0到1的瞬时变化,即用一个向上指的箭头:

![2019-08-20 21-06-33 的屏幕截图.png](https://img.codekissyoung.com/2019/08/20/7c8a35839813cc8f91fd7a14e1f38f71.png)

### 计数器的构造

之前提到的振荡器中，它的频率为1秒震荡的次数，那么这个次数如何来统计呢？思路是电路实现一个计数器，连接到振荡器上。那么这个计数器如何构建呢？

我们使用上述的边沿触发器,它与振荡器的连接方式如下:

刚开始时，`CLK`与`D`的输入都是`0`，然后`Q`的输出就是`0`，`Q扛`就是`1`,带动`D`变成`1`.所以最初始的状态就是右表格中的第一行，之后时钟开始震荡，各个输入输出端的值变化如右表。

![2019-08-20 21-54-41 的屏幕截图.png](https://img.codekissyoung.com/2019/08/20/2eb4aef80a36f784d89a549a467858ad.png)

画成更直观的时间折线图如下:

![2019-08-20 22-01-03 的屏幕截图.png](https://img.codekissyoung.com/2019/08/20/efe813a4a100b4659716b9bd633caae4.png)

可以很直观的看到，`Q`的震荡频率是`CLK`的一半。这种电路称为分频器。

如果将多个分频器串联呢:

![2019-08-20 22-06-57 的屏幕截图.png](https://img.codekissyoung.com/2019/08/20/12133ccb5c73043b5a4fd8c1a085d8cf.png)

如果给高低电平标上`0`和`1`,并且竖着从下往上读的话,明显就是一个计数器了:

![2019-08-20 22-08-38 的屏幕截图.png](https://img.codekissyoung.com/2019/08/20/9e7b27f287eac1786257d78e1a1d8b3f.png)

如果使用更多的分频器,就可以实现更大位数的计数，下面是一个8位计数器:

![2019-08-20 22-08-38 的屏幕截图.png](https://img.codekissyoung.com/2019/08/20/9e7b27f287eac1786257d78e1a1d8b3f.png)

将振荡器连到8位计数器上，当计数器总和达到`11111111`时,它又会返回到`00000000`。计算振荡器频率的方法就是:
把计数器的输出连到8个灯泡上。当所有输出为0时(即没有一个灯泡点亮),启动一个秒表;当所有灯泡都点亮时,停住秒表。这就是振荡器循环256次所需要的时间。

所以边沿D位触发器还需要一个清零开关，同时再加一个预置开关(当开启时,Q变为1,Q杠变为0),电路设计如下:

![2019-08-20 22-21-19 的屏幕截图.png](https://img.codekissyoung.com/2019/08/20/b1ec8318c9be45764e530e66ecb39a44.png)

## 15. 字节与十六进制

略，这部分很简单。

## 16. 存储器组织

D位触发器就可以作为保存一位信息的存储器，它的输入时钟输入变成了写入信号、数据端变为了数据输入端，而`Q`则是保存的信息位。想要在保存一位数据，写入信号应该先置为1后为0。

![2019-08-23 16-20-22 的屏幕截图.png](https://img.codekissyoung.com/2019/08/23/c616d02248cbca945e163c7a3f23b9ab.png)

### 8位锁存器

左边为上述触发器的简化图，通过并联在一起就组成了一个可以保存8个位的存储器。

![2019-08-23 16-26-53 的屏幕截图.png](https://img.codekissyoung.com/2019/08/23/2755c29f50621817daddbd50230077fc.png)

再简化:

![2019-08-23 16-33-11 的屏幕截图.png](https://img.codekissyoung.com/2019/08/23/afb5145277b5eeb13f651cc0be86a5b6.png)

### 8-1选择器

如果上述8位锁存器的输出接入8个灯泡，那么很容易知道每个位存入的值，但如果灯泡只有一个呢?

可以通过3个开关来控制显示哪一位的值。

![2019-08-27 17-55-40 的屏幕截图.png](https://img.codekissyoung.com/2019/08/27/3f744dcb92b07034cbbf73a961bc54b8.png)

图中的这部分电路就是`8-1`选择器，可以用它来控制输出哪一位的值。

![2019-08-27 17-22-49 的屏幕截图.png](https://img.codekissyoung.com/2019/08/27/6c8395022ea61940dd88fe47eb4fc169.png)

电路实现如下:

![2019-08-27 17-50-37 的屏幕截图.png](https://img.codekissyoung.com/2019/08/27/5f00a68908a70fb27bb4c8c44cae990a.png)

### 3-8译码器

同样的道理，我们想实现通过3个开关来控制写入8位中指定的位置。称为`3-8`译码器的电路。

![2019-08-27 17-59-50 的屏幕截图.png](https://img.codekissyoung.com/2019/08/27/893791328eac64c22128c5ca157cdcef.png)

下面就是8位锁存器的完整电路:

![2019-08-27 18-01-17 的屏幕截图.png](https://img.codekissyoung.com/2019/08/27/5b2c84a9511dfbbff41392542e0a9d6f.png)

`s0 s1 s2`通常称为地址，电路简化为:

![2019-08-27 18-03-46 的屏幕截图.png](https://img.codekissyoung.com/2019/08/27/42ff38b69d3cd82d2fb1def2e2870095.png)

这种电路成为`读/写存储器`，通常也叫做随机访问存储器`RAM`。称它为随即是因为可以通过改变地址，就可以从8个锁存器中的任意一个读出或者写入数据。

### 锁存器阵列

可以通过将两个`8-1 RAM`连接起来，使它们按照相同的方法来寻址:

![2019-08-27 18-10-49 的屏幕截图.png](https://img.codekissyoung.com/2019/08/27/05d46e692924ccdd7904a97bf1fdd0c5.png)

这样的话，一个地址可以有两个位置来存储数据，即可以存储和读取4种状态`00` `01` `10` `11`。这种电路称为`8x2 RAM`阵列。

如果想用`8-1 RAM`来构造一个`16-1 RAM`呢？即有16个地址，可以随机存储`16`位数据。电路如下:

![2019-08-27 18-17-44 的屏幕截图.png](https://img.codekissyoung.com/2019/08/27/21e859389dd0ca5e93cbc5e16b5d779b.png)

上图中增加的`选择`输入，其实就是地址线路。

通过第一个阵列，我们知道了如何将让一个地址存储多位数据，所以可以扩建出`8x8 RAM`,即一个地址可以存储和读取`8 x 8 = 256`种状态。

通过第二个阵列，我们知道如何拓展地址数目，如果我们将地址线加到10条呢，就可以有`1024`个地址可以用。

所以我们很容易就可以构建出一个`1024x8 RAM`存储器。如下图:

![2019-08-27 18-30-19 的屏幕截图.png](https://img.codekissyoung.com/2019/08/27/d64f7b8f5495e733ae049d89654e5506.png)

那么上面这个存储器能够存多大容量呢？一位数据就是`1 bit`，八位数据就是`1 B`。`1B = 8bit`。所以`1024x8 RAM`能存储的数据量为: `1024 B`，也就是`1kB`。

1980年代的PC机的存储器的配置都是`64KB`的，地址范围是`0x0000 ~ 0xFFFF`，电路图如下:

![2019-08-27 18-39-31 的屏幕截图.png](https://img.codekissyoung.com/2019/08/27/cce0404e29fe57b0291f199661d89060.png)

### 16位存储器机器

![2019-08-27 18-43-44 的屏幕截图.png](https://img.codekissyoung.com/2019/08/27/9b53d202f2a38d1da64b3563e419db90.png)

`A0 - A15`是地址输入开关，操作开关表示好一个数据后，下面的指示灯会立即显示出当前地址所存储的`8`位数据值。

`D0 - D7`是数据输入开关，操作开关表示好一个数据后，拨动一次写入开关( `0 -> 1 -> 0` )，就可以将该数据写入上诉地址。

`接管位`设置为0，就表示从外部接受输入，所有`A`和`D`开关不再起作用，设置为`1`即表示使用`A`和`D`开关输入的数据。

电路图如下:

![2019-08-27 18-53-10 的屏幕截图.png](https://img.codekissyoung.com/2019/08/27/a43f6db1ca4c2b0c2aabc19fe3d9e934.png)

## 17. 自动操作

这章是最难理解的，有了开关作为输入，灯泡作为输出，加法器作为运算工具，存储器作为存储器。如何将它们结合在一起实现:在存储器的100个地址里存入100个数字，然后通过加法器将它们依次累加，计算一个和，然后再次存入某个存储器位值?

基本的电路如何实现？

- 加载一个数到加法器
- 将一个数存入到存储器

基本电路实现后，我们怎么使用这些基本电路?人们创造出了指令，一条指令对应基本电路的某些操作。

指令有二进制表示，也有人可读的汇编代码表示。

下图为第14章实现的加法机器，它的使用参考14章。

![2019-08-27 20-14-36 的屏幕截图.png](https://img.codekissyoung.com/2019/08/27/17e379411ca4212649a4ce5128132e5a.png)

这个机器最大的问题是: 如果想把100个二进制数加起来,你就得坐在加法机前耐着性子输入每一个数字并累加起来。当你完成时,却发现有两个数字是错误的,你只好又重复全部的工作。

现在如果使用上一章的存储器，代替加法器中的`8`位开关输入,并且使用计数器代替代替存储器中的地址输入，计数器自动将累加后的值作为8位数据的存储地址。

![2019-08-27 20-17-40 的屏幕截图.png](https://img.codekissyoung.com/2019/08/27/d4bf7f9614c050c975420eec82d6769f.png)

上图中电路的用法如下:

1. 先通过"清零"开关，将8位锁存器和16位计数器都置为0
2. 通过存储器的控制面板，将100个整数的值，写入到存储器的`0 - 99`这100个地址处
3. 打开振荡器开关，它振荡时`0->1`，计数器就加1作为地址,然后存储器输出该地址的值给8位加法器
4. 加法器将该地址的值(A输入)与目前锁存器中的值(B输入)相加，输出给8位锁存器
5. 锁存器也接收到振荡器`0->1`的信号时，它将来自加法器的输出存入锁存器(这是边沿触发)
6. 振荡器继续振荡，依次将存储器中的`0 - 99`地址处的值，累加到了8位锁存器中，用户可以从灯泡上读取最后的结果

### 将100个数加成50个数

如果想将存储器中的100个数,每个相加，然后存回存储器中，最终得到50个数呢？

首先，8位锁存器的灯泡输出可以去掉，直接连回存储器。通过存储器指定地址来查看计算后的结果。

![2019-08-28 19-29-37 的屏幕截图.png](https://img.codekissyoung.com/2019/08/28/06122bbd0bfab986c7a7fe37f48a26b5.png)

现在我们想要做到的是: 我们希望能随心所欲地控制累加数字的个数，以及加完后的和存储在RAM的地址。

比如下图: 先加3个数，再加2个数,再加3个数。

![2019-08-28 19-34-37 的屏幕截图.png](https://img.codekissyoung.com/2019/08/28/23d6e6882a92e4bf38f83564d9ab07ea.png)

我们怎样来设计一个自动加法器,能完成下面的工作?

- 从存储器中传送一个字节到累加器中，这时该数字存储在8位锁存器中，这个操作叫装载(Load)
- 从存储器中传送一个字节加到累加器中，这个操作叫Add
- 从累加器中取出结果，保存(Store)到存储器中
- 让自动加法器停止工作(Halt)

对于上述案例，自动加法器所做的工作应该如下:

- 把地址`0000h`中的数装载到累加器中
- 把地址`0001h`中的数加到累加器中
- 把地址`0002h`中的数加到累加器中
- 把累加器中的数保存到地址`0003h`中
- 把地址`0004h`中的数装载到累加器中
- 把地址`0005h`中的数加到累加器中
- 把累加器中的数保存到地址`0006h`中
- 把地址`0007h`中的数装载到累加器中
- 把地址`0008h`中的数加到累加器中
- 把地址`0009h`中的数加到累加器中
- 把累加器中的数保存到地址`000Ah`中
- 停止自动加法器的工作

怎样完成这些工作呢?只是简单地键入一组数到`RAM`中并期望自动加法器来正确操作是不可能的。对于`RAM`中的每个数字,我们还需要一个数字代码来表示自动加法器所要做的工作:装载,加,保存或停止。

最容易的方法是将这些代码存储在一个完全独立的`RAM`阵列中，称为代码阵列。由这个阵列来控制自动加法器对数据所在`RAM`(称为数据阵列)所要进行的操作。




## 18. 从算盘到芯片

## 19. 两种典型的微处理器

## 20. ASCII码与字符转换

## 21. 总线

## 22. 操作系统

## 23. 定点数与浮点数

## 24. 高级语言与低级语言

## 25. 图形化革命
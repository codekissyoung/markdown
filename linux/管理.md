# 工作管理
在单个shell登录终端如何进行多个任务
```bash
ctrl + z  # 将当前执行的程序放入后台,程序是暂停的
tail -f /var/log/apache.log &  # 直接放入后台,程序是执行的
jobs -l  # 查看当前的后台任务
fg # 恢复最近的一个后台任务到前台
fg %工作号 # 恢复指定后台任务到前台
/etc/rc.local # 自启动文件，每次启动终端都会执行这个文件里面的shell脚本
nohup 命令 &  # 后台命令脱离终端运行
```


# 用户类型
linux 中只有`root`用户和`非root`用户两种用户
`nobody` `adm` `ftp` 等系统预设用户是不分配密码和shell的 一般作为进程指定用户使用 比如nginx指定nobody为运行用户
`whoami` 当前用户
`useradd  caokaiyan`  向系统添加一个用户
`passwd   caokaiyan` 给用户设定一个秘密
`sudo + 命令`  普通用户使用root用户权限操作
`usermod -l newuser1 newuser` 修改 newuser 的用户名为 newuser1
`usermod -L newuser1`  锁定账号 newuser1
`usermod -U newuser1` 解除对 newuser1 的锁定
`userdel -r username` 彻底消除一个用户,包括他的目录
`logout` 注销登录

# 用户组
类似于身份，每个用户必须有一个身份，并可以拥有多个身份
`usermod -a -G staff newuser2` 将 newuser2 添加到组 staff 中
`groups user` 查看用户属于哪几个用户组

# 目录和文件的权限
是针对`文件所有者` `用户组` `其它用户`三者设立的


# /etc/passwd 系统所有用户文件
```
用户名：密码(x代替)：UID：GID：用户全名：home目录：shell
```
# /etc/shadow 所有用户的密码(加密过后的)

# /etc/group 组文件
```
组名：用户组密码(x代替)：GID：用户名1,用户名2
```

# /etc/gshadow 组密码文件


# 给用户sudo权限(centOs系统)
`su`切换到root用户
`visudo` 编辑sudo文件
下面是sudo文件的配置
`root  ALL=(ALL)  ALL` 这一行下面，再加入一行
`caokaiyan  ALL=(ALL) ALL` 给caokaiyan用户跟root一样的sudo权限
`%admin ALL=(ALL) ALL` 给admin这个用户组跟root一样的sudo权限,admin用户组里的成员都拥有
`%admin ALL=/sbin/mount /mnt/cdrom,/sbin/umount /mnt/cdrom`
上面命令限制admin用户组只能使用`/sbin/mount /mnt/cdrom`,`/sbin/umount /mnt/cdrom`两个命令
`%admin ALL=(ALL) ALL,!/usr/sbin/adduser,!/usr/sbin/useradd` `!`表示admin禁用的命令
建议：明文禁止su命令被sudo特权执行,原因是 `sudo su anyone`这样可以切换到任意一个linux用户的目录
保存退出


# 查看当前在线的所有用户
```
[root@iZ252e1zy6zZ ~]# w
 06:16:14 up  5:24,  2 users,  load average: 0.02, 0.03, 0.05
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
cky      pts/0    183.37.226.20    02:53   28.00s  0.98s  0.98s -zsh
root     pts/1    183.37.226.20    06:16    0.00s  0.00s  0.00s w
```

# 强制踢出 pts/1 登录的用户
```
pkill -9 -t pts/1
```


# 进程管理

程序运行产生进程,同一个程序能产生`n`个进程
进程管理：判断服务器健康状态,查看系统中所有进程,杀死异常进程
如果发现某个进程是病毒,应该先删除它的文件,再杀死它的进程

# `ps aux`
`USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND`
```
USER：该 process 属于那个使用者账号的
PID ：该 process 的号码
VSZ ：该 process 使用掉的虚拟内存量 (Kbytes)
RSS ：该 process 占用的固定的内存量 (Kbytes)
TTY ：该 process 是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序
若为 pts/0 等等的，则表示为由网络连接进主机的程序。
STAT：该程序目前的状态，主要的状态有
R ：该程序目前正在运作，或者是可被运作
S ：该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (signal) 唤醒。
T ：该程序目前正在侦测或者是停止了
Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态
+ #后台进程
START：该 process 被触发启动的时间
TIME ：该 process 实际使用 CPU 运作的时间
COMMAND：该程序的实际指令
```

# `pstree`
以树形查看进程以及进程间的关系
`-p` 同时显示进程的`pid`
`-u` 同时显示该进程的用户

`ps axjf`               树状形式查看所有进程
`PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND`


# `top`
http://www.2cto.com/os/201209/157960.html
实时监控进程，监控服务器的健康情况
交互命令
`[shift] P`  按cpu使用率从大到小排序
`[shift] M` 按内存从大到小排序
`[shift] N`  按pid从小到大排序

`buffer` 缓冲,用于加速数据的写入,每次代码写操作不是直接写硬盘,而是写在内存里,等积累到一定数量了,一次性全部写入磁盘
`cache` 缓存,用于加速数据的读出,从磁盘或者数据库中取出到数据暂时存在内存里,若下次使用相同数据,就可以直接使用内存了
第一行：
10:01:23 当前系统时间
126 days, 14:29 系统已经运行了126天14小时29分钟（在这期间没有重启过）
2 users 当前有2个用户登录系统
load average: 1.15, 1.42, 1.44 load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。
load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。

第二行：
Tasks 任务（进程），系统现在共有183个进程，其中处于运行中的有1个，182个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。

第三行：cpu状态
6.7% us 用户空间占用CPU的百分比。
0.4% sy 内核空间占用CPU的百分比。
0.0% ni 改变过优先级的进程占用CPU的百分比
92.9% id 空闲CPU百分比
0.0% wa IO等待占用CPU的百分比
0.0% hi 硬中断（Hardware IRQ）占用CPU的百分比
0.0% si 软中断（Software Interrupts）占用CPU的百分比
在这里CPU的使用比率和windows概念不同，如果你不理解用户空间和内核空间，需要充充电了。

第四行：内存状态
8306544k total 物理内存总量（8GB）
7775876k used 使用中的内存总量（7.7GB）
530668k free 空闲内存总量（530M）
79236k buffers 缓存的内存量 （79M）

第五行：swap交换分区
2031608k total 交换区总量（2GB）
2556k used 使用的交换区总量（2.5M）
2029052k free 空闲交换区总量（2GB）
4231276k cached 缓冲的交换区总量（4GB）
第七行以下：各进程（任务）的状态监控
PID 进程id
USER 进程所有者
PR 进程优先级
NI nice值。负值表示高优先级，正值表示低优先级
VIRT 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES
RES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
SHR 共享内存大小，单位kb
S 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程
%CPU 上次更新到现在的CPU时间占用百分比

%MEM 进程使用的物理内存百分比
TIME+ 进程使用的CPU时间总计，单位1/100秒
COMMAND 进程名称（命令名/命令行）
多U多核CPU监控

# 杀死进程
`kill -1 pid` 平滑重启
`killall -1 pid` 平滑重启某一类进程
`Kill  -9  8935` 通过PID强制杀死进程
`killall -9  8323` 杀死它和它的子进程

# 进程优先级
就是决定cpu先执行哪个进程
除非做内核裁剪或者嵌入式开发,否则没有多大意义

# 按16进制 对照查看文件
```bash
➜  cky git:(master) od -ax shell
0000000   #   !   /   b   i   n   /   s   h  nl   e   c   h   o  sp   "
           2123    622f    6e69    732f    0a68    6365    6f68    2220
0000020   s   h   e   l   l   "  nl
           6873    6c65    226c    000a
```

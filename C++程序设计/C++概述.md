# C++概述

本文是杂乱无章的C++的笔记，大多数内容都从网上得来。

## C++ 程序设计风格

C++支持4种程序设计风格：过程式程序设计、数据抽象、面向对象程序设计、泛型程序设计。

- **过程式程序设计**: 专注于设计恰当的数据结构。

- **数据抽象**: 专注于接口的设计以及一般实现细节的隐藏和特殊的表示方式。

- **面向对象**: 专注于类层次的设计、实现和使用。类层次提供了运行时多态和封装机制。

- **泛型程序设计**: 专注于通用算法的设计、实现和使用。通用的含义是：一个算法可以设计成能处理多种类型，只要这些类型满足算法对其实参的要求即可。C++提供的特性是模板，提供了运行时参数多态。比如要对不同类型(整数 小数 字符 字符串 用户定义的类型)的数据进行排序，通常必须为每种类型创建一个排序函数，然而通过写一个泛型函数，就可以将其用于各种实际类型。

## C++出现的时间点与借鉴

![WX20190213-154850.png](https://i.loli.net/2019/02/13/5c63cbf882c03.png)

## 面向对象

- OOP：对象 类 封装 数据隐藏 多态 和 继承
- 多态: 可以为运算符和函数创建多个定义，通过编程上下文来确定使用哪个定义
- 继承: 能够让你使用旧类派生出新类
- OOP的本质就是设计并且拓展自己的数据类型，让设计的类型与现实数据相匹配

## 面向过程 与 面向对象

- 面向过程 强调的是 **算法** ， 面向对象强调的是 **数据**
- 面向对象的重点不是处理任务，而是表示概念

## Why C++

- “我们的系统已经是极度复杂的了，为了避开C++的复杂性而干脆不用C++（Linus的做法），无异于因噎废食。”在所有可用C和C++的领域，C++都是比C更好的语言。当我说“更好的”时候，我说的是C++拥有比C更安全的类型检查、更好的抽象机制、更优秀的库。当然，凡事都有例外，如果你做的项目1）不大。2）编码中用不到什么抽象机制，甚至ADT（抽象数据类型，例如std::complex这种不含多态和继承的）也用不到，RAII也用不到，异常也用不到。3）你连基础库（如，简化资源管理的智能指针、智能容器）都用不着。那么也许你用C的确没问题；所以如果你的情况如此，不用和我争论，因为我无法反驳你。我们这里说的领域大致是Bjarne在“C++应用列表”里面列出来的那些地方。

- 底线是：如果把C++中的诸多不必要的复杂性去掉，留下那些本质的，重要的语言特性，简化语言模型，消除历史包袱。即便是C++的反对者也许也很难找到理由说“我还是不用C++”。在我看来，一个真正从实践意义上理性反对使用C++的人只有一个理由：C++的复杂性带来的混乱抵消乃至超过了C++的抽象机制和库（在他的特定项目中）带来的好处。

- 值得注意的是，这里需要避免一个陷阱，就是一旦人们认定了“C++不好”，那么这个理由就会“长出自己的脚来”，即，就算我们拿掉C++的复杂性，他们可能也会坚持还是不用C++，并为之找一堆理由。我假定你不是这样的人。不过，也许最可能的是他会说：“问题是我们今天用的C++并非如此（简洁），你的假设不成立。”是的，我的假设不成立。但虽然我们无法消除复杂性，我们实际上是可以容易地避开复杂性，避短扬长的。这也是本文的要点，容我后面再详述。

## 如何编写好的C++程序

1. 用代码直接表达想法
1. 用代码直接表达想法之间的关联，如层次化 参数化 以及所属关系
1. 无关的想法独立用代码表达
1. 保持简单
1. 尽量使用静态类型检查
1. 保持信息的局部性 如 避免全局变量 尽量减少指针的使用
1. 不要过分抽象化 没有明显的需求时 不要使用泛型  不要引入类层次 或是进行参数化

## 使用C++11的新特性来更新你的设计和编程技术

1. 使用构造函数建立不等式
1. 使用构造/析构函数来简化资源管理
1. 避免裸 new 和 delete
1. 使用容器和算法，而不是内置数组和专用代码
1. 优先使用标准库特性，而非自己造轮子
1. 使用异常，而非错误代码来报告不能局部处理的错误
1. 使用移动语义来避免拷贝大对象
1. 使用 `unique_ptr` 来引用多态类型的对象
1. 使用 `shared_ptr` 来引用共享对象,即不只有一个所有者负责析构的对象
1. 使用模板来保持静态类型安全,消除类型转换,并避免类层次的不必要使用

## C++ 与 C

- 使用内联 inline 函数，代替了宏替换
- 使用new 和delete 代替了 malloc() 和 free(),作为动态内存管理！优点：new 自动计算要分配类型的大小，不使用 sizeof 运算符。它自动返回正确的指针类型，不用进行强制类型转换。可以使用new 对分配的对象进行初始化。
- 函数重载，对于简化函数命名有作用！
- 对于确定不会被设置为 null 的变量，使用 引用 & 来代替 * ！在任何情况下都不能使用指向空值的引用！如果在设计中不允许变量为空，那推荐使用引用！
- STL : algorithm ,container,iterator +工具类
- 模板 : 解决了不需要根据不同参数类型，写重复代码的繁琐！
- 对于c语言的预处理，c++中引入了一些新的方法代替它们

## c++ 与 java

C++ 和java相比，只有标准的容器和算法，它的标准里没有网络，GUI以及应用框架这些内容，因此需要第三方的库来支持，如果你了解MFC，你就用知道qt和c++的关系其实 与 MFC和C++的关系一样，qt有完整的应用框架，GUI，网络等内容。

## C++语法

本文主要记录下C++的常用的语法。

## 断言

```c++
static_assert( sizeof(int) >= 4, "sizeof int 小于4字节\n");
```

## 基本操作

![WX20190322-110103.png](https://i.loli.net/2019/03/22/5c945003b887d.png)

### 安全的类型转换

- bool到char
- bool到int
- char到int
- char到double
- int到double

### 不安全的类型转换

- double到int
- double到char
- double到bool
- int到char
- int到bool
- char到bool

## 表达式

### 常量

```c++
const double pi = 3.14159
```

![WX20190322-111108.png](https://i.loli.net/2019/03/22/5c94525ab0a76.png)

## 异常

为了保证检测到的错误不会被遗漏，异常处理的基本思想是把错误检测(在被调函数中完成)和错误处理(在主调函数中完成)分离。

异常提供了一条可以把各种最好的错误处理方式组合在一起的途径。它的基本思想是：如果函数发现一个自己不能处理的错误，它不是正常返回，而是抛出异常来表示错误的发生。任何一个直接或间接的函数调用者都可以捕获这一异常，并确定应该如何处理。

## 自定义类型

类型的好处：

- 表示：类型知道如何表示对象中的数据
- 运算：类型知道如何对对象进行实名运算

### 运算符重载

你可以在类或枚举对象上定义几乎所有C++运算符，这通常称为运算符重载。

重载运算符时，运算对象数目必须和原来一样。

一个重载的运算符必须作用于至少一个用户自定义类型的运算对象。

```c++
enum Month{ Jan = 1, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec }

Month operator++( Month& m )
{
    m = ( m == Dec ) ? Jan : Month( m + 1 );
    return m;
}
```
# C++ Primer Plus 第六版

《C++ Primer Plus 第六版》 的学习笔记。

## 第1章 预备知识

C语言：数据 + 算法 = 程序

OOP: 强调数据，设计出与问题本质相对应的数据格式。

泛型编程：强调独立于特定的数据类型，创建出独立于类型的代码。

## 第2章 开始学习C++

C++对大小写敏感。

`函数声明`描述了 函数 与 调用方 之间的接口，指明了 `返回类型` 与 `调用参数列表`。

对象的长处：不用了解对象的内部情况，只需要知道它的`接口`，即可以使用它。

同一个运算符号，在不同的上下文中，作用于不同的对象上，具有不同的含义与表现，即`运算符重载`。

使用一个变量之前必须声明，声明指明了变量的名称以及它的类型，但并不分配内存空间。变量的定义为变量分配了内存空间。如果`a.cpp`需要使用`b.cpp`中定义的`全局变量`，则必须使用`extern`声明它，表明它是来自于其他文件的`全局变量`。当然更一般的做法是，由`b.h`提供`全局变量`的声明，`a.cpp`只需要`#include b.h`即可以使用`b.cpp`中定义的全局变量。

```c++
// b.cpp
const double PI = 3.14159;

// b.h
extern double PI;

// a.cpp
#include "b.h"
cout << PI << endl;
```

函数格式

```c++
// a.h
type functionname( argumentlist ); // 函数声明

// a.cpp
#include "a.h"
type functionname( argumentlist ) // 函数定义
{
    // ...
}

// b.cpp
#include "a.h"
type a = functionname( b, c, d ); // 函数调用
```

## 第3章 处理数据

OOP的本质是设计并拓展自己的数据类型，自定义数据类型 与 内置类型的使用是一样的。

运算符的 `优先级` 与 `结合性`。`优先级`指示了先进行什么运算，后进行什么运算。`结合性` 在多个相同`优先级`运算符的情况下，是从左往右开始运算，还是从右往左开始运算。

C++中有11种整形 与 3种浮点型，不同的数值类型进行运算时，计算机自动为它们进行类型转换后，再运算。

类型转换存在3种问题：

- 精度损失 `double -> float`
- 小数部分丢失 `double -> int`
- 数值错误 `long -> short`, 通常只复制`long`的低位字节

使用`{}`初始化列表进行变量的初始化，可以防止变量的窄化`narrowing`。

强制类型转换:

```c++
(typeName) value;   // C 与 C++ 都适用
typdeName( value ); // 只有C++支持
```

字符通过其数值编码来表示，`IO`系统决定了编码是被解释为字符还是数字。

## 第4章 复合类型

### 数组

元素的类型，数组名，数组中的元素个数。

```c++
typeName arrayName[arraySize];
```

C 风格字符串中，处理字符串的函数是根据空字符`\\0`的位置，而不是字符数组的长度来处理。计算存储字符串的所需的最短数组时，不要忘记结尾的`\\0`字符需要占一个元素。

### 结构

结构将多个不同类型的值存储在一个数据对象中，使用`.`返回其中成员。声明一个结构类型，即是声明了一种新类型。

![WX20190418-155340.png](https://i.loli.net/2019/04/18/5cb82d46a23ac.png)

共用体被设计用于存储一个值，但这个值可以是不同的类型，成员名指出了使用的模式。

### 枚举

`enum`提供了另一种创建符号常量的方式，这种方式可以代替`const`。枚举也是声明了新类型。

```c++
enum spectrum { red, orange, yellow = 8, green, blue };
spectrum band; // 使用 spectrum 类型 声明一个变量，该类型只有 5 个能取的值
band = blue;   // 赋值
```

### 指针与动态内存

`new`运算符是在程序运行时为数据对象申请内存，它返回申请到的内存的地址，可以将这个地址赋给一个指针。之后，只能使用该指针来访问这块内存。

```c++
int *pt   = new int;
short *ps = new short[500];

delete pt;
delete[] ps;
```

- 不要使用`delete`来释放不是`new`分配的内存。
- 不要使用`delete`是否同一块内存两次。
- `delete[]` 用于释放`new[]` 生成的数组
- 对空指针`nullptr`使用`delete`是安全的

C++将数组名解释为一个内存地址。多数情况下，解释为数组的第一个元素的地址。是一个地址常量。但如果对数组名取地址，则得到的是整个数组的地址。地址的值虽然一样，但它们的类型不一样。

```c++
short tell[10];
// tell 等价于 &tell[0]; 是一个 2 字节内存块的地址
// &tell 是一个 20字节内存块的地址
short (*pas)[20] = &tell; // pas 是一个指针，指向 20 字节的内存块
```

### 变量的生存期

自动存储：变量在函数调用时产生，在函数返回时销毁。

静态存储：函数外定义的全局变量，以及函数内使用`static`声明的静态变量

动态存储：`new`与`delete`管理的堆内存池。

## 第5章 循环和关系表达式

略

## 第6章 分支语句与逻辑运算符

略

## 第7章 函数 C++的编程模块

函数的返回值的类型限制：基本类型、指针、数组、结构体、对象。

传递参数：C++通常按值传递，这意味着将数值传递给函数，而后函数将其赋给一个新变量，用于函数内部使用。将一个地址传递给函数，也是按值传递，只不过函数内部可以通过该地址，修改函数外部的值。

如果函数的定义中，将函数的参数声明为引用，则新变量与函数外部变量指向的是同一个数据对象。

```c++
void swap( int a, int b );   // 按值传递，变量副本
void swap2( int *a, int *b ); // 按值传递，要求值时一个地址
void swap3( int &a, int &b ); // 按引用传递，变量副本 与 外部变量执行同一个数据对象

int c = 5, d = 6;
swap( c, d );
swap2( &c, &d );
swap( c, d );   // 推荐使用，程序更加清晰，优雅
```

### 函数与数组

```c++
int sum_arr( int arr[], int n ); // 传入数组首地址，以及数组大小

int arr[] = { 1, 2, 3, 4, 5 };
int sum = sum_arr( arr, sizeof(arr) / sizeof(int) );
```

使用数组区间的函数：

```c++
// begin 指向要处理的起始位置，end 指向要处理最后元素的后面一个位置
int sum_arr( int *begin, int *end )
{
    const int *pt;
    int total = 0;
    for( pt = begin; pt != end; pt++ )
        total = total + *pt;
    return total;
}

int sum = sum_arr( arr, arr + sizeof(arr) / sizeof(int) );
```

函数与二维数组:

```c++
int sum( int (*ar2)[4], int size );
int sum( int arr[][4], int size ); // 与上式等价，列数固定 4 列，行数为 size
```

### 函数与C风格字符串

C风格字符串 与 常规char数组之间的区别是：字符串内部有内置的结束字符`\\0`,这意味着不必传字符串长度到函数。

### 函数与结构

像处理内置类型那样来处理结构，可以将结构作为参数传递，也可以从函数内返回一个结构，这些都是按值传递。当然，如果结构体较大，最好是传递结构体的指针，或者使用引用来传递，这样可以提高程序运行效率。

### 函数与对象

对象与结构类似，例如可以相互赋值，可以直接传递给函数。

### 函数指针

与数据对象类型，函数也有地址。函数的地址是存储其机器语言代码的内存首地址。如果将函数A的地址传递给函数B,则在函数B中可以通过这个地址调用A。这意味着，我们可以在不同情况下，给B函数传递不同函数的地址，这样操作可以非常灵活的实现某些功能。

那么我们该用什么参数来接收这个函数地址呢？答案是 函数指针。

C++中函数名与函数地址的作用相同。函数名的值即是函数的内存地址，传递函数的名称作为参数。

```c++
double pam( int );   // 函数原型
double (*pf)( int ); // pf 就是 pam 的函数指针

// 在函数的参数中使用 函数指针
void estimate( int lines, double (*pf)(int) )
{
    double h = (*pf)( lines ); // 使用函数指针 调用函数
    // double h = pf( lines ); // 与上式等价，由于历史原因，对于函数调用 *pf 等价于 pf
}

estimate( 7, pam ); // 调用函数，将 pam 作为值传入

// 使用 typedef 简化函数指针的使用
const double *get_max( const double *a, int b );       // 函数原型
const double *get_min( const double *a, int b );       // 函数原型

typedef const double *(*p_fun)( const double *, int ); // p_fun 现在是 该函数指针 的类型了

p_fun p1 = get_max; // 声明 该函数指针类型的变量
p_fun pa[3] = { get_max, p1, get_min }; // 声明该 函数指针的数组

p_fun (*pd)[3] = &pa;  // 想想看 &pa 的类型是什么？
```

## 第8章 函数探幽
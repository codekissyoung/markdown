# 文件系统

## 文件的信息结构

```c
#include <sys/stat.h>
int stat( const char *restrict pathname, struct stat *restrict buf );
int fstat( int fd, struct stat *buf );
int lstat( const char *restrict pathname, struct stat *restrict buf );
int fstatat( int fd, const char *restrict pathname, struct stat *restrict buf, int flag );
```

- pathname 路径
- fd 文件描述符
- lstat 返回该符号链接本身的有关信息
- fstatat 为一个相对于当前打开目录(fd指向)的路径名返回文件统计信息。
  - flag 设置为AT_SYMLINK_NOFOLLOW时，返回符号链接本身的信息
  - flag 设置为AT_FDCWD时，如果pathname是一个相对路径，则计算相对于当前目录的pathname参数，如果是一个绝对路径，就使用该路径作为pathname
- struct stat 结构， 用于接收文件的结构

```c
struct stat{
    mode_t st_mode;           // 文件类型
    ino_t  st_ino;            // i-node 节点号
    dev_t  st_dev;            // 设备号
    dev_t  st_rdev;           // 特别设备的设备号
    nlink_t  st_nlink;        // 链接数
    uid_t st_uid;             // 用户ID
    gid_t st_gid;             // 用户组ID
    off_t st_size;            // 文件的字节数
    struct timespec st_atime; // 访问时间
    struct timespec st_mtime; // 修改时间
    struct timespec st_ctime; // 创建时间
    blksize_t st_blksize;     // best IO block size
    blkcnt_t st_blocks;       // number of disk blocks allocated
}
```

- st_mode 包含文件类型信息，使用宏确定文件类型

```c
S_ISREG( st_mode )  // 普通文件
S_ISDIR( st_mode )  // 目录
S_ISCHR( st_mode )  // 字符特殊文件
S_ISBLK( st_mode )  // 块特殊文件
S_ISFIFO( st_mode ) // 管道
S_ISLINK( st_mode ) // 符号链接
S_ISSOCK( st_mode ) // socket
```

- IPC 对象的类型

```c
S_TYPEISMQ( struct stat * )  // 消息队列
S_TYPEISSEM( struct stat * ) // 信号量
S_TYPEISSHM( struct stat * ) // 共享存储对象
```

## 测试文件的权限

```c
int access( const char *pathname, int mode );
int faccessat( int fd, const char *pathname, int mode, int flag );
```

- mode
  - R_OK 测试 pathname 是否可读
  - W_OK 测试可写
  - X_OK 测试可执行
- flag 设置为 AT_EACCESS,则检查用的是进程的有效用户ID和有效组ID,而不是实际用户ID
- return
  - 错误 -1
  - 成功 0

## 创建文件时，掩码设置

```c
mode_t umask( mode_t cmask );
```

- 文件权限有 `set-user-ID位`,`set-group-ID位`,`sticky位` 加上 9 个权限位，在创建的时候由`int creat(path,0766)`和`umask( 022 )`两者确定
- `umask( 022 )` 设置`新建文件掩码`,目的为屏蔽新建文件的某些权限，例如：要防止程序创建出能被同组用户和其他用户修改的文件，掩码就是`022`(八进制) 即 `000 010 010`( 二进制 )，取反就是`111 101 101`, 与 `0766` 即 `000 111 110 110` 进行 `&` 运算得到 `000 111 100 100` 即 `--- rwx r-- r--` 就是新建文件的最终权限
- `chmod( path, mod )` 可以直接修改文件的权限，并且不受`新建文件掩码`影响

## 更改现有文件的访问权限

```c
#include <sys/stat.h>
int chmod( const char *pathname, mode_t mode );
int fchmod( int fd, mode_t mode );
int fchmodat( int fd, const char *pathname, mode_t mode, int flag );
```

- mode

```c
S_ISUID 执行时设置用户ID / S_ISGID 执行时设置组ID / S_ISVTX 粘着位
S_IRUSR 用户读权限  / S_IWUSR 用户写权限 / S_IXUSR 用户执行权限 / S_RWXU 用户可读可写可执行
S_IRGRP 用户组读权限 / S_IWGRP 用户组写权限  / S_IXUSR 用户组执行权限 / S_IRWXG 组员可读可写可执行
S_IROTH 其他人读权限 / S_IWOTH 其他人写权限 / S_IXOTH 其他人执行权限 / S_IRWXO 其他人可读可写可执行
```

- flag 取值为 AT_SYMLINK_NOFOLLOW 时，fchmodat 不解析符号链接
- 只有root可以设置粘着位，目录设置了粘着位后，只有满足三个条件之一的才可以删除目录下的文件，第一，拥有文件权限 第二，拥有此目录权限 第三，是root用户

## 更改用户ID和组ID

```c
int chown( const char *pathname, uid_t owner, gid_t group );
int fchown( int fd, uid_t owner, git_t group );
int fchownat( int fd, const char *pathname, uid_t owner, gid_t group, int flag );
int lchown( const char *pathname, uid_t owner, gid_t group );
```

## 文件截断

```c
int truncate( const char *pathname, off_t length );
int ftruncate( int fd, off_t length );
```

- 将一个现有文件长度截断为 length 个字节

## 创建链接

```c
int link( const char *existpath, const char *newpath );
int linkat( int efd, const char *existpath, int nfd, const char *newpath, int flag );
```

## 删除链接

```c
int unlink( const char *pathname );
int unlinkat( int fd, const char *pathname, int flag );
int remove( const char *pathname ); // 解除对一个文件或者目录的链接
```

- 当链接计数达到 0 时，该文件的内容才可被删除
- 当还有进程正在使用该文件时，该文件即使计数为0也不会立刻删除，而是等到所有使用它的进程退出后，才删除。利用这个特性，进程如果需要临时文件，可以creat后立刻unlink,这样进程即使崩溃，这个临时文件也不会遗留下来

## 对文件重命名

```c
int rename( const char *oldname, const char *newname );
int renameat( int oldfd, const char *oldname, int newfd, const char *newname );
```

## 创建符号链接

```c
int symlink( const char *actualpath, const char *sympath );
int symlinkat( const char *actualpah, int fd, const char *sympath );
```

## 打开符号链接本身，读取它本身的内容

```c
ssize_t readlink( const char *restrict pathname, char *restrict buf, size_t bufsize );
ssize_t readlinkat( int fd, const char *restrict pathname, char *restrict buf, size_t bufsize );
```

## 修改文件访问时间和修改时间

```c
int futimens( int fd, const struct timespec times[2] );
int utimensat( int fd, const char *path, const struct timespec times[2], int flag );
int utimes( const char *pathname, const struct timeval times[2] );
```

## 创建/删除目录

```c
int mkdir( const char *pathname, mode_t mode );
int mkdirat( int fd, const char *pathname, mode_t mode );
int rmdir( const char *pathname );
```

## 读目录

```c
DIR *opendir( const char *pathname );
DIR *fdopendir( int fd );
struct dirent *readdir( DIR *dp );
void rewinddir( DIR *dp );
int closedir( DIR *dp );
long telldir( DIR *dp );
void seekdir( DIR *dp, long loc );
```

## 修改进程当前工作目录

```c
int chdir( const char *pathname );
int fchdir( int fd );

char *getcwd( char *buf, size_t size ); // 获取当前工作目录
```
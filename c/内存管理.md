## 结构体成员指针未初始化
```c
struct student  
{  
    char *name;  
    int score;  
} stu , *pstu;

int main()  
{  
    strcpy(stu.name,"Jimy");  
    stu.score = 99;  
    return 0;  
}  
```
- 解决的办法是为 `name` 指针`malloc`一块空间

```c
int main()  
{  
    pstu = (struct student*)malloc(sizeof(struct student));  
    strcpy(pstu->name,"Jimy");  
    pstu->score = 99;  
    free(pstu);  
    return 0;  
}
```

# 简单的内存管理
```c
#include <stdlib.h>
void *malloc( size_t size );
```

# 按需换页的虚拟内存系统

- linux 实现了一个按需换页的 **虚拟内存系统** ，用户进程看到的所有内存都是虚拟的，也就是说它并不真正存在于程序使用的物理地址上。linux 将所有的内存都以页为单位进行划分，通常每一页的大小为4096字节。每当程序试图访问内存时，就会发生虚拟内存到物理内存的转换，转换的具体实现和耗费的时间取决于你使用的特定硬件情况。当访问的内存在物理上并不存在时，就会产生一个页面错误并将控制权交给内核。

- linux 内核会对访问的内存地址进行检查，如果这个地址对于程序来说是合法可用的，并且未被写入过，内核就直接分配它，如果它已经被保存在硬盘的交换空间，就读取该页到物理内存(可能把已有的页面移回硬盘)。接着，完成虚拟内存地址到物理内存的映射之后，内核允许用户程序继续运行。

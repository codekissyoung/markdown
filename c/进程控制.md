# 基本概念

- 每个进程都有一个父进程
- 当父进程调用fork函数创建一个子进程而不调用wait函数时,一个僵尸进程就产生了
- fork这个函数的特别之处在于一次调用，两次返回，一次返回到父进程中，一次返回到子进程中

```c
为了充分的利用资源,系统还对进程区分了不同的状态.将进程分为新建,运行,阻塞,就绪和完成五个状态.
新建表示进程正在被创建
运行是进程正在运行
阻塞是进程正在等待某一个事件发生
就绪是表示系统正在等待CPU来执行命令
完成表示进程已经结束了系统正在回收资源
```

## 进程

```c
pid_t getpid(void);  // 获取当前进程 ID
pid_t getppid(void); // 获取当前进程的 父进程ID
uid_t getuid(void);  // 当前进程的 用户ID
uid_t geteuid(void); // 当前进程的 有效用户ID
gid_t getgid(void);  // 当前进程的 组ID
gid_t getegid(void); // 当前进程的 有效组ID
```

## 创建新进程

```c
if( ( pid_t pid = fork() ) > 0 )
{
    // 父进程
}
else if( pid == 0 )
{
    // 子进程
}
else
{
    // 创建新进程失败
}
```


## 打印内存地址

```c
int a;
printf("address : %p \n", &a);
```

## 普通的创建一个进程

```c
pid_t pid = fork();
if(pid < 0){
    printf("fork 出错");
} else if ( pid == 0) {
    printf("-------child porcess %d start ----------\n",getpid());
    execl("hello","a",NULL);
    printf("-------child porcess %d end ----------\n",getpid());
} else {
    printf(" 父进程 ");
    sleep(3);
}
```

## 普通的子线程

```c
int stack = 1;
int *heap = (int *) malloc(sizeof(int));
*heap = 100;
// 进程中数据
printf("before vfork : global : %d , stack : %d , *heap : %d \n",global ,stack ,*heap);
pid_t pid = vfork();
if(pid < 0){
    printf("vfork error");
}else if(pid == 0){
    printf("thread process %d start\n",getpid());
    global ++ ;
    stack ++;
    (*heap) ++ ;
    printf("after vfork in thread : global : %d , stack : %d , *heap : %d \n",global ,stack ,*heap);
    printf("thread process %d end\n",getpid());
    exit(0);
}else {
    printf("in process : global : %d , stack : %d , *heap : %d \n",global ,stack ,*heap);

}
```

## 僵尸进程

```c
pid_t pid = fork();
if(pid < 0){
}else if(pid == 0){
    printf("the child process %d start \n", getpid());
    sleep(3);
    printf("the child process %d end \n", getpid());
    // 子进程退出了，父进程还在运行，并且没有调用 wait 清理子进程，则子进程就成了zombie
    exit(0);
}else{
    sleep(30);
    if(wait(NULL) == -1){
        perror("fail to wait");
    }
    printf("the parent process %d end \n", getpid());
    exit(0);
}
```

- 如果子进程先于父进程退出， 同时父进程又没有调用wait/waitpid，则该子进程将成为僵尸进程。

## 避免产生僵尸进程

## 改变进程所有者

```c
int setuid(uid_t uid);
int seteuid(uid_t uid);
int setgid(gid_t gid);
int setegid(gid_t gid);
```

## 调试多进程

## 设置跟踪流

```c
(gdb)set follow-fork-mode [parent|child]
(gdb)set detach-on-fork [on|off]
```

## 使用gdb的attach命令

## 在进程中运行shell命令

```c
#include <stdlib.h>
int system(const char * cmdstring);
```

## 获取子程序结束信息

```c
#include <sys/wait.h>
pid_t wait(int *statloc);
```

## 输出进程统计信息

- 进程统计信息都储存在rusage这个统计资源结构体内

```c
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <sys/source.h>
pid_t wait3(int *statloc,int options,struct rusage *rusage);
pid_t wait4(pid_t pid,int *statloc,int options,struct rusage *rusage);
```

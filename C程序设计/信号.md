# 信号基础
- 信号通信是一种典型的异步通信
- 信号又称为软件中断,一个进程一但收到信号，就会打断原来的执行流程来处理该信号
- 任何一个进程都可以发送和接收信号

- 查看支持的信号
```bash
$ kill -l
HUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE
ALRM TERM STKFLT CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ
VTALRM PROF WINCH POLL PWR SYS
```

# 产生信号
- 按下某些终端键，比如`ctrl + C`产生INT信号,`ctrl + \`产生QUIT信号,这个信号会产生core文件
- 进程调用`kill(2)`函数，发送信号给另一个进程
- 进程调用`kill(1)`命令，发送信号给另一个进程
- 内核检测到某种软件条件发生时
- 硬件异常，首先是硬件检测到，然后通知内核，内核再向当前进程发送适当的信号

# 处理信号
- 忽略它
- 注册一个信号处理函数，单接到这个信号时按函数写的进行处理
- 执行该信号的系统默认处理


# 信号的副作用
- 重入

# POSIX 使用sigaction代替signal
- `sigaction(int signum,const struct sigaction *action, struct sigaction *prevaction)`
    - signum 要处理的信号
    - action 指针，指向描述操作的结构
    - prevaction 指针，指向描述被替换操作的结构

```c
struct sigaction{
    void (*sa_handler)(); // 与 sa_sigaction 二选一,这个就是使用旧的处理机制
    void (*sa_sigaction)(int,siginfo_t *,void *); // 传送给函数的不只是编号，还包括信号产生的原因和条件结构体
    sigset_t sa_mask; // 处理一个消息时是否要阻塞其他信号，其中的位指定哪些信号被阻塞
    int sa_flags; // 如何处理多个信号：SA_RESETHAND 捕鼠器模式 SA_NODEFER SA_RESTART SA_SIGINFO
}
```

# 信号相关资源
- https://blog.csdn.net/wwt18811707971/article/details/52672063
- signal用于安装不可靠信号
- linux现在用sigaction实现sigaction用于安装可靠信号，当然也可以安装不可靠信号并且可以附带更多的信息。**这个还不懂**
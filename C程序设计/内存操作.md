# 内存操作

## 结构体成员指针未初始化

```c
struct student  
{  
    char *name;  
    int score;  
} stu , *pstu;

int main()  
{  
    strcpy(stu.name,"Jimy");  
    stu.score = 99;  
    return 0;  
}  
```

解决的办法是为 `name` 指针`malloc`一块空间

```c
int main()  
{  
    pstu = (struct student*)malloc(sizeof(struct student));  
    strcpy(pstu->name,"Jimy");  
    pstu->score = 99;  
    free(pstu);  
    return 0;  
}
```

## 按需换页的虚拟内存系统

- linux 实现了一个按需换页的 **虚拟内存系统** ，用户进程看到的所有内存都是虚拟的，也就是说它并不真正存在于程序使用的物理地址上。linux 将所有的内存都以页为单位进行划分，通常每一页的大小为4096字节。每当程序试图访问内存时，就会发生虚拟内存到物理内存的转换，转换的具体实现和耗费的时间取决于你使用的特定硬件情况。当访问的内存在物理上并不存在时，就会产生一个页面错误并将控制权交给内核。

- linux 内核会对访问的内存地址进行检查，如果这个地址对于程序来说是合法可用的，并且未被写入过，内核就直接分配它，如果它已经被保存在硬盘的交换空间，就读取该页到物理内存(可能把已有的页面移回硬盘)。接着，完成虚拟内存地址到物理内存的映射之后，内核允许用户程序继续运行。

## 申请内存

```c
// 返回值：分配成功返回分配内存块的首地址，失败返回NULL
void *malloc( size_t size );

// num为分配内存块的个数，size为分配内存块的大小
void *calloc( int num, size_t size );
```

- 区别
  - malloc一次只能申请一个内存区，calloc一次可以申请多个内存区；
  - malloc不会对分配的内存初始化，calloc会初始化为0

## 释放申请到的内存

```c
// ptr为malloc或calloc等内存分配函数返回的内存指针
void free(void *ptr);
```

## 拷贝内存内容

```c
// dest为目标内存区，src为源内存区，n为需要拷贝的字节数
// 返回值: 指向dest的指针
// 缺点: 未考虑内存重叠情况
void *memcpy(void *dest, void *src, size_t n);

// 相比memcpy：当dest与src重叠时，仍能正确处理，但是src内容会被改变
// 当dest与src重叠时，仍能正确处理，但是src内容会被改变 推荐使用
void *memmove(void *dest, void *src, size_t n);

// 函数实现
void *memmove(void *dest, void *src, size_t n)
{
    char *ret = char *dest;
    char *dest_t;
    char *src_t;
    if((unsigned char *dest <= unsigned char *src) || (unsigned char *dest >= unsigned char *src + n))
    {
        dest_t = char *dest;
        src_t = char *src;
        while(n--)
        {
            *dest_t++ = *src_t++; //正向拷贝
        }
    }
    else
    {
        dest_t = char *dest + n - 1;
        src_t = char *src + n - 1;
        while(n--)
        {
            *dest_t-- = *src_t--; //反向拷贝
        }
    }
    return ret;
}
```

## 初始化指定内存空间

```c
// memset是按字节为单位对buffer指向的内存赋值
void *memset(void *buffer, int c, size_t n);

int a[5];

// 00000011 00000011 00000011 00000011
memset(a, 3, 5 * sizeof(int) );

// 00000000 00000000 00000000 00000000
memset(a, 0, 5 * sizeof(int));
```

## 比较两个内存空间的字符

```c
// n为要比较的字符数
int memcmp(const void *buf1, const void *buf2, size_t n);
- 返回值
  - 当buf1 > buf2时，返回 > 0
  - 当buf1 = buf2时，返回 = 0
  - 当buf1 < buf2时，返回 < 0
```

## 在内存中查找字符

```c
// 返回指向ptr指向的内存块中value值第一次出现位置的指针,如果没有找到value值，则该函数返回NULL
const void * memchr ( const void * ptr, int value, size_t num );

// 举例
char *pch;
char str[] = "Example string";
pch = (char*)memchr (str, 'p', strlen(str));
```

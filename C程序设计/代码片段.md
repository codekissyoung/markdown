# c代码片段
```c
// 判断浮点数为0
const float EPSINON = 0.00001;
if ((x >= - EPSINON) && (x <= EPSINON))

// 判断指针为空 | 非空
if (p == NULL)
if (p != NULL)

// 空语句
if ( NULL != p); // ;是空语句 fun(); 不会被调用
    fun();

// 在执行代码里面修改循环变量的值，很容易导致循环失控
for( n = 0 ; n < 10 ; n++){
    if(true){
        n = 8;
    }
}

// 编译错误 不同类型的指针不能相互赋值
float *p1;
int *p2;
p1 = p2;

// 前置++ 和 后置++
int i =3；
j=(++i)+(++i)+(++i)  // 编译器区别 VC6 ：16    gcc ：18

// 逗号表达式，i 在遇到每个逗号后，认为本计算单位已经结束，i 这时候++
j=(i++,i++,i++);    // 后置 ：5    先进行别的运算（赋值）再 ++
j=(i++,i++,++i);    // 前置 ：6    先 ++ 再赋值

x=(++i,i++,i+10);    //    i=5    x=15
k=(i++)+(i++)+(i++); // k=9    i=6

// 符号的贪心原则：判定一个符号时，尽可能的包括多的字符
a+++b;  // 等价于 a++  +b  

// NULL 定义为 0
int *p = NULL; // 意思是指向 内存0 地址
int *j;
*j = NULL;    //将 *j 指向的值 赋值为 0


// 短路计算 怎么使得两数之积总是小于等于255?
result   = ((a*b) > 255) ? 255 : a*b; // 方法 1
bool tmp = ((result = a*b) < 255) || (result=255); // 方法 2
bool tmp = ((result = a*b) >= 255) && (result=255); // 方法 3

// 精简的 while
while( scanf("%ld",&num) == 1 )     // 获取值和判断都成功
while(( ch = getchar()) != '\n')    // 注意 () 不能省，!= 优先级高
while( * string )                   // 判断空字符串

// 错误：因为不能对标量取地址
swamp( &34, &89 );
```

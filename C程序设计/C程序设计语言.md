# C程序设计语言笔记

本文是 C 语言之父`Dennis Ritchie` 所写的经典书籍《C程序设计语言》第二版的笔记。

## 前言

C语言提供了许多数据类型。基本类型：字符、具有多种长度的整形和浮点型。另外还通过指针、数组、结构和联合派生出各种数据类型。

**表达式**：由运算符和操作数组成,包括赋值表达式或函数表达式。

指针提供了与具体机器无关的地址算术运算符。

实现了基本控制流结构：语句组、`if-else`条件判断、`switch`多路选择、`while for`终止测试在顶部的循环、终止测试在底部的循环`do`、提前跳出循环`break`、跳过循环的某一步`continue`。

是一种工作在`low level`的语言。指的是C语言可以处理大部分计算机能够处理的对象，比如字符、数字和地址。这些对象可以通过具体机器实现的算术运算符和逻辑运算符组合在一起。

不提供直接处理诸如字符串、集合、列表或数组等复合对象的操作。虽然可以将整个结构作为一个单元进行拷贝，但C语言没有处理整个数组或字符串的操作。

除了由局部变量提供的静态定义和堆栈外，C语言没有定义任何内存分配工具，也不提供堆和无用内存回收工具。最后，C语言本身没有提供`I/O`、没有`READ`和`WRITE`语句，也没有内置的文件访问方法。所有这些机制必须由操作系统（以`system call`系统调用形式）提供。C语言的标准库封装了这些系统调用，提供了更加友好易用的函数。

C标准库描述了如何访问操作系统（如读写文件）、格式化输入/输出、内存分配和字符串操作等类似的很多函数，定义了一系列标准头文件，它们为访问函数声明和数据类型声明提供了统一的方法。这就确保了使用这个函数库与宿主系统进行交互的程序之间具有兼容的行为。

C语言只提供简单的单线程控制流、即测试、循环、分组、和子程序。它不提供多道程序设计、并行操作、同步和协同例程。

大多数计算机本身就直接支持C语言提供的数据类型和控制结构，因此只需要一个很小的运行时库就可以实现自包含程序。由于程序只能够显示地调用标准库中的函数，因此在不需要的情况下就可以避免对这些函数的调用。除了其中隐藏的一些操作系统细节外，大部分库函数可以用C语言编写。

ANSI要求对变量进行正确的声明和显式的强制类型转换。编译器将对大部分的数据类型错误发出警告，并且不自动执行不兼容数据类型之间的类型转换。

## 第一章 C语言核心简介

概念：变量、常量、算术运算、控制流、函数、基本输入/输出。

函数是封装计算的一种简便方法。

函数之间进行数据交换的一种方法是：调用函数向被调用函数提供参数列表。参数，传值调用,被调用函数不能直接修改主调函数中变量的值，而只能修改其私有的临时副本的值。

一个C语言程序，无论大小如何，都是由函数和变量组成的。

**局部变量**： 在函数内部定义的变量，在函数执行时存在，函数执行完毕返回后消失
**外部变量**： 在函数外定义的变量，在任意函数内部都可以使用，因此C的函数可以通过外部变量交换数据，而不必使用参数表，`外部变量`在程序执行期间一直存在

## 第二章 类型、运算符与表达式

变量用于存储计算过程中使用的值。声明语句说明变量的名字及类型。类型决定可取值的范围，以及可以执行的操作 和 使用的运算符。运算符指定将要进行的操作。表达式则把变量与常量组合起来生成新的值。

- 算术运算符 `+` `-`
- 关系运算符`==` `!=`
- 逻辑运算符 `||` `&&`

### 类型转换

允许字节小的类型自动转换为字节大的类型。

C语言没有指定`char`类型的变量是`signed`还是`unsigned`。当一个`char`类型自动变为`int`类型时，其结果是否可能是负数？

对于不同的机器，其结果也不相同：

- 在某些机器中，如果char类型值的最左一位是`1`,则转为负整数。
- 而在另一些机器中，则是在`char`类型值的左边添加`0`，这样导致转换的结果值总是正值。

为了保证程序的可移植性，如果要在`char`类型的变量中存储非字符数据，最好指定`signed`或`unsigned`限定符。

### 隐式转换规则

表达式中没有`unsigned`操作数:

- 如果其中一个操作数为`long double`,则将另一个操作数转换为`long double`;
- 其中一个操作为`double`,则另一个操作数也转换为`double`;
- 其中一个操作为`float`,则另一个操作数也转换为`float`;
- 其中一个操作数的类型为`long`,则将另一个操作数也转换为`long`类型;
- `char`与`short`转换为`int`类型。

表达式中含有`unsigned`操作数：

- `signed`与`unsigned`之间的比较运算是与机器相关的，它们取决于机器中不同整数类型的大小。例如，假设`int`类型占16位，`long`类型占32位，那么`-1L < 1U`,这是因为`unsigned int`将被提升为`signed long`类型。但`-1L > 1UL`,这是因为`-1L`会被提升为`unsigned long`类型，因而成为一个比较大的正数。

为了解释某些操作限制，引入:

- `L-value`指的是`locator value`，即 在内存中有特定位置的值，国内翻译为`左值`
- `R-value`指的是`read value` 即 可读取的值，国内翻译为`右值`

赋值时也要进行类型转换，右值需要转换为左值的类型。

无论是否进行符号拓展，字符型变量都将被转换为整型变量。

长整数强制转换为短整数或`char`类型时，超出的高位部分将被丢弃。

- 当把`float`类型转换为`int`类型时，小数部分将被截取掉。
- 当`double`类型转换为`float`类型时，是四舍五入还是截取，取决于具体实现。

把参数传递给函数时，也要进行类型转换:

- 在没有函数原型的情况下，`char`与`short`类型都将被转换为`int`类型,`float`类型被转换为`double`类型。

因此，即使调用函数的参数为`char`或`float`类型，我们也可以把函数参数声明为`int`或`double`类型。

强制类型转换`（类型名）表达式`，表达式将按照规则转换为类型名指定的数据类型。

通常情况下，参数是通过函数原型声明的。当函数被调用时，声明将对参数进行自动强制转换。例如`double sqrt(double);`函数声明，当调用时`root2 = sqrt(2);`,`2`会被自动强制转换成`2.0`。

```c
unsigned int a = 9;
int b = -4;
int c = a / b;
printf("c: %d\n", c); // 0
```

上例，`b`被隐式转换成`unsigned int`类型，`-4`成了一个很大的正数，所有`c`算出来是小数`0.xxx`，然后由于`c`是`int`类型，截断小数后部分，即剩下`0`。

```c
unsigned char a = 0;
unsigned char b = 0xFF;

if( a == ~b )
    printf("a == ~b\n");
else
    printf("a != ~b\n"); // 这句被打印
```

上例，初学者会认为，`0xFF`取反后就是`0x00`，因为`a`和`b`在编译器都是`char`类型变量，所以`a == ~b`。而实际上在32位以上计算机中，表达式在运行时，将`unsigned char`型的变量自动转换成了`unsigned int`型变量，即`~b = 0xFFFFFF00`,而`a = 0x00000000`，所以不相等。

### 按位运算符

C语言提供了6个操作运算符。这些运算符只能用于整型。

- `&` 按位与
- `|` 按位或
- `^` 按位异或
- `～` 按位求反
- `<<`左移
- `>>`右移

`x << 2`表示将`x`的值左移2位，右边空出的2位用0填补。

在对`unsigned`类型的值进行右移时，左边空出的部分将用`0`填补。

当对`signed`类型的值进行右移时：

- 某些机器将对左边空出的部分用符号位填补(算术移位)
- 而另一些机器则对左边空出的部分用`0`填补(逻辑移位)

### 运算符优先级与求值次序

`()`、`[]`、`->`、`.` 是优先级最高的。

`&&` 比 `||` 优先级高。

## 第三章 控制流

`if-else`条件语句，`if( 表达式 )`中，判定规则是表达式计算的结果`非0`,则为真。

`if-else if-else`条件语句。

`switch-case`条件语句，`break;`用于退出`switch`代码块，可选用。

```c
switch( 表达式 )
{
    case 常量1:
        语句1;
    case 常量2:
        语句2;
        break;
    default:
        语句3;
}
```

`while(表达式){ 语句; }` 循环。

`for(表达式1;表达式2;表达式3){ 语句; }` 循环。

`do{ 语句; }while(表达式);` 循环。

`break;`用在循环中，表示提前退出循环。`continue`用在循环中，表示跳过这次循环。

`goto 与 标号` 用于在函数内部，作用是直接跳转到某处，然后执行后面的代码。

```c
for(表达式)
{
    for(表达式)
    {
        if( 表达式 )
            goto error;
    }
}

error:
    处理错误表达式;
```

## 第四章 函数和程序结构 外部变量、作用域规则、多源文件、预处理器

### 外部对象

C语言程序可以看成由一系列外部对象(`外部变量`或`函数`)构成。C语言不允许在一个函数中定义其他函数。

默认情况下，外部变量与函数具有下列性质：通过同一个名字对外部变量的所有引用（即使这种引用来自于单独编译的不同函数），实际上都是引用同一个对象（标准中把这一性质称为外部链接）。

任何函数都可以通过名字访问一个外部变量，当然这个名字需要通过某种方式进行声明。

因为外部变量可以全局访问，这就为函数之间的数据交换提供了一种可以代替函数参数与返回值的方式。如果函数之间需要共享大量的变量，使用外部变量要比使用一个很长的参数表更方便有效。

`外部变量`与`内部变量`相比，拥有更大的的作用域和更长的生存期。`内部变量`在函数被调用时存在，在函数返回时消失;而`外部变量`在程序的整个生命周期都存在。

### 作用域规则

构成C语言程序的函数与外部变量可以分开进行编译。一个程序可以存放在几个文件中，原先已经编译过的函数可以从库中进行加载。这里我们感兴趣的问题有：

- 如何进行声明才能确保变量在编译时被正确声明？
- 如何安排声明的位置才能确保程序在加载时各部分能正确链接？
- 如何组织程序中的声明才能确保只有一份副本？
- 如何初始化外部变量？

名字的`作用域`指的是程序中可以使用该名字的部分。对于`内部变量`来说，其作用域是声明该变量的函数内部。`外部变量`或`函数`的作用域从它的声明开始，到其所在文件的末尾结束。

如果要在外部变量的定义之前使用该变量，或者外部变量的定义与变量的使用不在同一个源文件中，则必须在相应的变量声明中强制性地使用`extern`。

将外部变量的`声明`与`定义`严格区分开来很重要。变量声明用于说明变量的属性，而变量定义除此以外还将引起存储器的分配。

```c
int ap;
double val[MAXVAL];
```

上述两条语句放在所有函数的外部，将定义外部变量`sp`与`val`,并为之分配存储单元。同时这两条语句还作为该源文件中的其余部分的声明。

```c
extern int sp;
extern double val[];
```

而上述两条语句为源文件的其余部分声明了一个`int`类型的外部变量`sp`以及一个`double`数组类型的外部变量`val`(该数组的长度在其他地方确定)。但这两个声明并没有建立变量，也没有为它们分配存储单元。

在一个程序的所有源文件中，一个外部变量只能在某个文件中定义一次，而其他文件可以通过`extern`声明来访问它。定义必须要指明数组长度，而声明不需要。

### 头文件

一个程序的所有源代码分割成多个文件，主要是考虑在实际的程序中，它们分别来着单独编译的库。同时要考虑定义和声明在这些文件之间的共享问题。我们尽可能地把共享的部分集中在一起，这样就只需要一个副本，改进程序时也容易保证程序的正确性。

我们把这些公共的部分放在一个头文件中，在需要使用公共部分中变量与函数时，通过`#include`指令将它包含进来。

![头文件](https://i.loli.net/2019/02/07/5c5bdf0cbae47.png)

如上图所示，我们对两个因素进行了折中：一方面是我们期望每个源文件只能访问它完成任务所需要的信息；另一方面是现实中维护较多的头文件比较困难。我们可以得出这样一个结论：对于某些中等规模的程序，最好只用一个头文件程序存放程序中的各部分共享的对象。而较大的程序需要使用更多的头文件，我们需要精心地组织它们。

### 静态变量

用`static`声明`外部变量`，则该`外部变量`的作用域被限定为本文件的剩余部分，其他源文件无法访问。用`static`声明函数。则该函数只在本文件内部可见，其他源文件都无法访问。这种性质可以用作`模块化`开发，将只在模块内部使用的`外部变量`和`函数`隐藏在本模块内部，禁止外部访问。

`static`用于`内部变量`，则该`内部变量`在函数中一直占据存储空间，不会随函数的返回而销毁。

### 寄存器变量

寄存器变量只适用于`内部变量`以及函数的形式参数。它建议编译器，该`内部变量`使用频率较高，可以存储在寄存器中，例子`register int x;`。

### 程序块结构

```c
float i = 1.00;
if( n > 0 )
{
    int i;
    for ( i = 0; i < n; i++ )
    {
        // do something
    }
}
```

`int i`与外部的`float i`无关，`int i`的作用域只在`if程序块`中。每次进入程序块时，在程序块内部的声明以及初始化的内部变量都将被初始化。

```c
int x;
int y;

void func( double x )
{
    double y;
    ...
}
```

内部变量(包括形式参数)可以隐藏同名的外部变量与函数。

### 初始化

对外部变量与静态变量来说，初始化表达式必须是常量表达式，且只初始化一次（从概念上讲是程序开始执行前进行初始化）。

对于内部变量与寄存器变量，则在每次进入函数或程序块时都将被初始化，初始化表达式中可以包含任意之前定义的值或是函数调用。

### 递归

递归的一个好的说明例子是快速排序。

```c
void qsort( int v[], int left, int right )
{
    if( left >= right )
        return ;

    int i,last;

    swap( v, left, (left + right)/2 );

    last = left;

    for( i = left + 1; i <= right; i++ )
    {
        if( v[i] < v[left] )
            swap( v, ++last; i );
    }

    swap(v, left, last );

    qsort( v, left, last - 1);
    qsort( v, last + 1, right );
}
```

### C预处理器

```c
#define 名字 替换文本
#define max(A,B) ((A) > (B) ? (A) : (B))
```

## 第五章 指针和地址运算

### 指针

```c
int iNum = 0x64;  // 变量
int *ptr = &iNum; // 指针变量

typedef int *PTR_INT;
PTR_INT *pPtr = &ptr; // 指针的指针 双重指针

// 以下关系恒成立
*pPtr  == *(&ptr) == ptr
**pPtr == *ptr == *(&iNum) == iNum 
```

变量与指针:
![WX20190313-162448.png](https://i.loli.net/2019/03/13/5c88be5cc7744.png)

变量的存储与引用:
![WX20190313-162819.png](https://i.loli.net/2019/03/13/5c88bf36e4a1d.png)

指针的指针:
![WX20190314-142154.png](https://i.loli.net/2019/03/14/5c89f7f6250b0.png)

指针是一种保存变量地址的变量。是表达某个计算的唯一途径。同其他方法比较起来，使用指针通常可以生成更高效、更紧凑的代码。指针与数组之间的关系十分密切。

一元运算符`&`可用于取一个对象的地址，它只能应用于内存中的对象，即变量与数组。它不能作用于表达式、常量或`register`变量。

一元运算符`*`是间接寻址或间接引用运算符，当它作用于指针时，将访问指针指向的对象。`int *ip;`这样声明表明`*ip`的结果是`int`类型。

每个指针都必须指向某种特定的数据类型，`void`类型的指针可以存放指向任何类型的指针。

`*`的优先级高于算术运算符，因此`y = *ip + 1`表达的是，把`ip`指向的对象的值取出加`1`,然后赋值给`y`。`*ip += 1;`表示将`ip`指向的对象的值加1,等价于`++*ip;`或`(*ip)++`,其中圆括号是必须的，否则该表达式`*ip++`表示对`ip`进行加1运算，然后再取值。类似于`*`与`++`这样的一元运算符遵循从右至左的结合顺序。

指针也是变量，在程序中可以直接使用。比如`iq`也是指向整数的指针，那么`iq = ip`表示把`ip`中的值拷贝到`iq`中，这样，指针`iq`也指向`ip`指向的对象。

### 指针与函数参数

C语言是以传值的方式将参数值传递给被调用函数，因此被调用函数不能修改外部（主调函数中）的值。可以通过传递指针到被调函数内，实现直接修改函数外部的值。

```c
swap( &a, &b );

void swap( int *px, int *py )
{
    int temp;
    temp = *px;
    *px = *py;
    *py = temp;
}
```

### 指针与数组

```c
int a[2];
a: 0x7ffe37f084a0,   &a: 0x7ffe37f084a0,   &a[0]: 0x7ffe37f084a0
a+1: 0x7ffe37f084a4, &a+1: 0x7ffe37f084a8, &a[0]+1: 0x7ffe37f084a4
```

`a`是由2个`int`值组成的数组，取出标识符`a`,剩下的`int [2]`就是`a`的类型，即由2个`int`值组成的数组类型，简称数组类型。

`a`、`&a`和`&a[0]`虽然值是一样的，但含义不同：

- 变量名`a`被解释为指向首元素`a[0]`的指针，`a`与`&a[0]`是等价的，类型都是`const int *`，即常量指针。

- 而`&a`的类型为`(int *)[2]`，即指向`int [2]`数组类型的指针，区别于`int *[2]`，后者是一个数组，数组中包含两个`int *`类型的指针。

通过数组下标能完成的任何操作都可以通过指针来实现。一般来说，用指针编写的程序比用数组下标编写的程序执行速度快。

![2019-02-08 12-37-41 的屏幕截图.png](https://i.loli.net/2019/02/08/5c5d07ab7a9d8.png)

```c
int *pa
pa = &a[0];
```

![2019-02-08 12-39-23 的屏幕截图.png](https://i.loli.net/2019/02/08/5c5d080f784fb.png)

`a[i]`等价于`*( pa + i )`。指针可以加上或者减去一个整数，移动的字节数依据指针的类型进行计算。

数组名与指针之间有个不同之处：指针是一个变量，所以`pa = a`和`pa++`都是合法的。但数组名不是变量，因此`a = pa`和`a++`形式的语句是非法的。

当把数组名传递给一个函数时，实际上传递的是该数组的第一个元素的地址。在被调用函数内部，这个参数是一个内部变量。函数的数组名参数必须设置为一个指针，也就是一个存储地址值的变量。在函数参数中，形式参数`char a[];`与`char *s;`是等价的。

### 地址算术运算

有效的指针运算包括相同类型指针之间的赋值运算；指针同整数之间的加法或减法运算；指向相同数组中元素的两个指针间的减法或比较运算；将指针赋值为0或指针与0之间的比较运算。

其他所有形式的指针运算都是非法的，例如两个指针间的加法、乘法、除法、移位或屏蔽运算；例如，指针同`float`或`double`类型之间的加法运算；不经强制类型转换而直接将指向一种类型对象的指针赋值给指向另一种类型对象的指针的运算。

指向某一类型的指针可以转换为指向另一类型的指针，但是如果该指针指向的对象不满足一定的存储对齐要求，则使用该指针可能导致地址异常

可以将指针强制转换为任意类型的指针，并且可以原封不动地再次转回本类型指针，包括函数类型指针也是一样

### 字符指针与函数

```c
char amessage[] = "now is the time";
char *pmessage = "now is the time";
```

amessage是一个仅仅足以存放初始化字符串以及空字符`\\0`的一维数组，数组中的单个字符可以进行修改,但amessage始终指向同一个存储位置。pmessage是一个指针，其初始值指向一个字符串常量，之后它可以指向别的地址，但如果试图修改字符串的内容，结果是没定义的。

![2019-02-08 17-06-02 的屏幕截图.png](https://i.loli.net/2019/02/08/5c5d468a0ecf6.png)

字符串指针的一些例子：

```c
// 将指针t指向的字符串复制到指针s指向的位置
void strcpy( char *s, char *t )
{
    while( *s++ = *t++ )
        ;
}

// 根据s按照字典顺序小于、等于或大于t的结果分别返回负整数、0或正整数
int strcmp( char *s, char *t )
{
    for( ; *s == *t; s++, t++ )
    {
        if( *s == '\0')
            return 0;
    }
    return *s - *t;
}
```

### 指针数组 以及指向指针的指针

由于指针本身也是变量，所以它们也可以像其他变量一样存储在数组中。

处理长度不一的文本行，与整数不同的是，它们不能在单个运算中完成比较或移动操作。我们引入指针数组处理这种问题。如果待排序的文本行首尾相连地存储在一个长字符数组中，那么每个文本行可通过指向它的第一个字符的指针来访问。这些指针本身可以存储在一个数组中。这样，将指向两个文本行的指针传递给函数`strcmp`就可实现对这两个文本行的比较。交换文本行的顺序时，实际上交换的是文本行对应的指针的顺序，而不是文本行本身。

![2019-02-08 19-51-40 的屏幕截图.png](https://i.loli.net/2019/02/08/5c5d6d5dd0c4f.png)

### 多维数组

二维数组实际上是一种特殊的一维数组，它的每个元素也是一个一维数组，`daytab[行][列];`。

如果将二维数组作为参数传递给函数，那么在函数的参数声明中必须指明数组的列数，数组的行数没有太大的关系，因为函数调用时传递的是一个指针，它指向由行向量构成的一维数组，其中每个行向量是具有若干个整形元素的一维数组。

下面三个表达式等价:

```c
f( int daytab[2][13] ){ ... }
f( int daytab[][13] ){ ... }
f( int (*daytab)[13] ){ ... }
```

`[]`的优先级高于`*`,所以`int *daytab[13]`表达的是：声明了一个数组，该数组有13个元素，每个元素都是一个指向整形对象的指针。

一般来说，除数组的第一维可以不指定大小外，其余各维都必须明确指定大小。

### 指针数组 与 多维数组

```c
// 指针数组的初始化
static char *name[] = {
    "Illegal month",
    "January","February","March","April","May","June",
    "July","August","September","October","November","December"
};
```

`int a[10][20]` 与 `int *b[10]`,从语法角度，`a[3][4]`与`b[3][4]`都是对一个`int`对象的合法引用。但a是一个真正的二维数组， 它分配了200个`int`类型长度的存储空间，并且可以通过`20 x row + col`计算得到`a[row][col]`的位置。而对于`b`来说，仅仅是分配了十个指针，并且没有对它们进行初始化，它们的初始化必须以显示的方式进行，比如静态初始化或通过代码初始化。假定`b`的每个元素都指向一个具有20个元素的数组，那么编译器就要为它分配200个`int`类型长度的存储空间，以及10个指针的存储空间。指针数组的一个重要优点在于，数组的每一行长度可以不同，也就是说，`b`的每个元素不必都指向一个具有20个元素的数组，某些元素可以指向具有2个元素的数组，某些元素可以指向具有50个元素的数组，而某些元素可以不指向任何数组。

指针数组图示：

![2019-02-08 20-15-45 的屏幕截图.png](https://i.loli.net/2019/02/08/5c5d730405b45.png)

二维数组图示：
![2019-02-08 20-16-20 的屏幕截图.png](https://i.loli.net/2019/02/08/5c5d73208d157.png)

### 命令行参数

在支持C语言的环境中，可以在程序开始执行时，将命令行参数传递给程序。`main()`函数运行时，它带有两个参数。第一个参数`argc`表示运行程序时，命令行中参数的数目(下例是3)；第二个参数`argv`是一个指针数组，每个指针指向一个参数字符串。按照C的约定，`argv[0]`是程序名，其后是各个参数，另外ANSI标准要求，`argv[argc]`的值必须是一个空指针。

```bash
$ echo hello, world
```

![2019-02-08 20-22-34 的屏幕截图.png](https://i.loli.net/2019/02/08/5c5d74972a914.png)

### 指向函数的指针

在C语言中，函数本身不是变量，但可以定义指向函数的指针。这种类型的指针可以被赋值，存放在数组中，传递给函数以及作为函数的返回值等等。

### 复杂声明

C语言的语法力图使声明和使用一致。对于简单的情况，C语言的做法是有效的，但是如果情况比较复杂，则容易混淆。原因在于，C语言的声明并不能从左至右阅读，而且使用了大量的`()`。

```c
int *f(); // f 是一个函数，返回一个指向 int 类型的指针
int (*pf)(); // pf 是一个指向函数的指针，该函数返回一个 int 类型的对象
```

## 第六章 结构和联合

结构是一个或多个变量的集合，这些变量可能为不同的类型，为了处理方便而将这些变量组织在一个名字下。由于结构将一组相关的变量看做一个单元而不是各自独立的实体，因此结构有助于组织复杂的数据，特别是在大型的程序中。

ANSI标准在结构方面最主要的变化是，定义了结构的赋值操作：结构可以拷贝、赋值、传递给函数、函数也可以返回结构类型的返回值。

![2019-02-09 11-42-25 的屏幕截图.png](https://i.loli.net/2019/02/09/5c5e4c462f0ac.png)

```c
struct point{
    int x;
    int y;
};

struct point maxpt = { 320, 300 };
```

结构声明由包含在`{}`内的一系列声明组成。关键字`struct`后面的名字是可选的，称为`结构标记`。结构标记用于为结构命名，在定义之后，结构标记就代表花括号内的声明，可以用它作为该声明的简写形式。

结构中定义的变量称为成员。结构成员、结构标记和普通变量可以采用相同的名字，它们之间不会冲突，因为通过上下文可以区分。不同结构中的成员可以使用相同的名字。

`struct`声明定义了一种数据类型，在`}`之后可以跟一个变量表，这与其他基本类型的变量声明是相同的。

```c
struct { ... } x, y, z;
int x, y, z;
```

通过`结构名.成员名`的方式来访问结构中的成员。

结构可以嵌套：

```c
struct rect {
    struct point pt1;
    struct point pt2;
};

struct rect screen;
screen.pt1.x = 100;
```

### 结构与函数

结构的合法操作：作为一个整体复制和赋值，通过`&`运算符取地址，访问结构的成员。其中，复制和赋值包括向函数传递参数以及从函数返回值。结构之间不可以进行比较。

传递结构的方式：一是分别传递各个结构成员，二是传递整个结构，三是传递指向结构的指针。

假定`p`是一个指向结构的指针，可以用`p->结构成员`这种形式访问相应的结构成员。`.`与`->`都是从左往右结合的。

```p
struct rect r, *rp;
rp = &r;

// 下面四个式子等价
r.pt1.x;
rp->pt1.x;
(r.pt1).x;
(rp->pt1).x;
```

`.`、`->`、`()`和`[]`的优先级最高，它们同操作数之间的结合也最紧密。举个例子：

```c
struct {
    int len;
    char *str;
} *p;
```

- `++p->len`将增加`len`的值，而不是`p`的值。
- `(++p)->len`将先对`p`执行加1操作，再对`len`执行操作。
- `(p++)->len`则先对`len`执行操作，然后再将`p`加1（该表达式中的括号可以省略）。
- `*p->str`读取的是指针`str`所指向的对象的值；
- `*p->str++`先读取指针`str`指向的值，然后再将`str`加1（与`*s++`相同）
- `(*p->str)++`将指针`str`指向的对象的值加1;
- `*p++->str`先读取指针`str`指向的对象的值，然后再将`p`加1。

### 结构数组

声明一个结构类型`key`,并定义了该类型的结构数组`keytab`,同时为其分配存储空间。数组`keytab`的每个元素都是一个结构。

```c
struct key {
    char *word;
    int count;
} keytab[10];

// 也可以分开声明
struct key{
    char *word;
    int count;
};

struct key keytab[10];

keytab[1].count = 0;
```

### 指向结构的指针

### 自引用结构

统计输入中所有单词的出现次数。因为预先不知道出现的单词列表，所以无法方便地排序，并使用折半查找。一种解决方法是，在读取输入中任意单词的同时，就将它放置到正确的位置，从而始终保证所有单词是按照顺序排列的。其中使用了一种称为`二叉树`的数据结构。

"now is the time for all good men to come to the aid of their party" 按照二叉树存储后，如图所示：

![2019-02-10 15-19-22 的屏幕截图.png](https://i.loli.net/2019/02/10/5c5fd09385edf.png)

要查找一个新单词是否已经在树中，可以从根节点开始，比较新单词与该节点中的单词。

- 若匹配，则得到正确答案
- 若新单词小于该节点中的单词，则在左树中继续查找
- 若新单词大于该节点中的单词，则在右树中继续查找

如果在搜寻方向上无子树，则说明新单词不在树中，并且当前的空位就是存放新加入单词的正确位置。因为从任意节点出发的查找都要按照同样的方式查找它的一个子树，所以该过程是递归的。

```c
// 二叉树节点的结构
struct tnode {
    char *word; // 单词
    int count;  // 单词出现的数量
    struct tnode *left;  // 左子节点 指针
    struct tnode *right; // 右子节点 指针
};
```

一个包含其自身实例的结构是非法的，但包含自身结构的指针是合法的。

简单讨论下存储分配程序的问题：

第一，如何在大多数实际机器上满足各种类型对象的对齐要求，例如整形通常必须分配在偶数地址上？

第二，使用什么样的声明能处理分配程序必须能返回不同类型的指针的问题？

对齐比较容易满足，只需要确保分配程序始终返回满足所有对齐限制要求的指针就可以了，代价是牺牲一些存储空间。`alloc`函数不保证任何特定类型的对齐，而`malloc`能够满足对齐要求。

对于第二个问题，在C语言中，一种合适的方法是将`malloc`的返回值声明为一个指向`void`类型的指针，然后再显式地将该指针强制转换为所需类型。

### 类型定义 typedef

C 语言提供了一个称为`typedef`的功能，用来建立新的数据类型名。

```c
typedef int Length;

Length len,maxlen;
Length *lengths[];
```

如上，将`Length`定义为与`int`具有同等意义的名字。类型`Length`可用于类型声明、类型转换等，它与`int`完全相同。

```c
typedef char *String;

String p, lineptr[100], alloc(int);
p = (String) malloc( 100 );
```

将String定义为与`char *`或字符指针同义，此后，便可以在类型声明和类型转换中使用`String`。

```c
typedef struct tnode *Treeptr;

typedef struct tnode {
    char *word;
    int count;
    Treeptr left;
    Treeptr right;
} Treenode;

Treeptr talloc( void )
{
    return (Treeptr) malloc( sizeof(Treenode) );
}
```

上述类型定义创建了两个新类型关键字:`Treenode`(一个结构)和`Treeptr`(一个指向该结构的指针)。

从任何意义上讲，`typedef`声明并没有创建一个新类型，它只是为某个已存在的类型增加了一个新的名称而已。`typedef`声明也没有增加任何新的语义:通过这种方式声明的变量与通过普通声明方式声明的变量具有完全相同的属性。

实际上，`typedef`类似于`#define`语句，但是由于`typedef`是由编译器解释的，因此它的文本替换功能要超过预处理器的能力。

```c
typedef int (*PFI)(char *, char *);
```

上面语句定义了`PFI`是一个指向函数的指针，该函数具有两个`char*`类型的参数，返回值类型为`int`。

```c
PFI strcmp, numcmp;
```

`typedef`可以提高程序的可移植性。如果`typedef`声明的数据类型同机器有关，那么，当程序移植到其他机器上时，只需要改变`typedef`类型定义就可以了。

`typedef`为程序提供了更好的说明性，比如`Treeptr`类型显然比一个声明为指向复杂结构的指针更容易让人理解。

### 联合 union

- 在 union 中 所有的 数据成员 共用一个空间，同一个时间只能储存其中一个数据成员，所有的数据成员具有相同的起始数据地址
- union 使用最大的的长度来储存所有成员，所以只能一个时间，存一个！

```c
union Data
{
    int i;
    float f;
    char  str[20];
};
union Data d1;
strcpy( d1.str, "codekissyoung" );
```

### 位字段 位域

定义一个变量`flags`,它包含3个一位的字段。冒号后面表示字段的宽度(表示占用多少个比特位)，字段被声明为`unsigned int`类型，以保证它们是无符号量。

```c
struct {
    unsigned int is_keyword : 1;
    unsigned int is_extern: 1;
    unsigned int is_static: 1;
} flags;

flags.is_extern = 0;
flags.is_keyword = 1;
```

某些机器上字段的分配是从字的左端至右端进行的，而某些机器则相反。这意味着在选择外部定义数据的情况下，必须仔细考虑哪端优先的问题，依赖字段的顺序的程序是不可移植的。字段也可以仅仅声明为`int`,但为了方便移植，需要显式声明该`int`类型是`signed`还是`unsigned`类型。字段不是数组，并且没有地址，因此对它们不能使用`&`运算符。

## 第七章 输入与输出

输入与输出功能并不是C语言的组成部分。

标准库实现了简单的文本输入/输出模式。文本流由一系列行组成,每一行的结尾是一个`\\n`。如果系统没有遵循这种模式，则标准库将通过一些措施使得该系统适应这种模式。例如，标准库可以在输入端将回车符和换页符都转换成换行符，而在输出端进行反向转换。

最简单的输入机制，每次从`标准输入`中一次读取一个字符:

```c
int getchar(void); // 文件结尾 则返回 EOF
```

最简单的输出机制，每次输出一个字符到`标准输出`上

```c
int putchar( int ); // 如果发生错误，返回EOF
```

### 可变参数

```c
#include <stdarg.h>
int func(int a, int b, ... ){
    va_list arg_ptr;                          // 声明可变参数 arg_ptr
    void va_start( arg_ptr, b );              // 填入最后一个固定参数 b
    int    var1 = va_arg( arg_ptr, int );     // 得到第一个可变参数的值 var1
    double var2 = va_arg( arg_ptr, double );  // 得到第一个可变参数的值 var2
    void va_end( arg_ptr );                   // 清理 arg_ptr
}
/* 指定 变量数量 */
void test(int count, ...) {
    va_list args;
    va_start(args, count);
    for (int i = 0; i < count; i++)
    {
        int value = va_arg(args, int);
        printf("%d\n", value);
    }
    va_end(args);
}
/* 以 NULL 为结束标记 */
void test2(const char* s, ...) {
    printf("%s\n", s);
    va_list args;
    va_start(args, s);
    char* value;
    do
    {
        value = va_arg(args, char*);
        if (value) printf("%s\n", value);
    }
    while (value != NULL);    va_end(args);
}
/* 直接将 va_list 传递个其他可选 变量函数 */
void test3(const char* format, ...)
{
    va_list args;
    va_start(args, format);
    vprintf(format, args);
    va_end(args);
}

int main(int argc, char* argv[])
{
    test(3, 11, 22, 33);
    test2("hello", "aa", "bb", "cc", "dd", NULL);
    test3("%s, %d\n", "hello, world!", 1234);
    return EXIT_SUCCESS;
}
```

- [用法参考](https://www.cnblogs.com/edver/p/8419807.html)
- [可变参数实现](https://blog.csdn.net/smstong/article/details/50751121)


## 第八章 C语言与UNIX之间的接口

## 附录A 语言参考手册

- 词法规则：程序由存储在文件中的多个翻译单元`translation unit`组成，翻译的第一步是预处理，将所有的`#`宏展开，得到一个记号序列
- 记号：`标识符` `关键字` `常量` `字符串字面值` `运算符` `分隔符(空格 换行 制表符等)` 共6类记号，编译时，被分隔符隔开的最长字符串构成记号，即贪心算法
- 标识符: 字母和数字构成的序列。比如变量名，函数名，结构名，对标识符的解析依赖两个主要属性:`存储类` 和 `类型`
- 存储类
  - 自动存储类:这类对象对于一个程序块(函数等)来说是局部的，退出程序块时，该对象消失
  - 静态存储类:程序运行结束才消失的对象类，可以是某个程序块的局部对象，在函数内部用`static`声明; 在所有程序块外部定义的对象默认是静态的，而用`static`声明则表示只供本文件访问
- 类型
  - 基本类型: `int` `double` 等
  - 复合类型: 数组，结构体，指向给定类型对象的指针，联合体
- 关键字: `int` `double` `if` 等
- 左值: `lvalue`
- 自动类型转换：`int`在和`double`运算时，自动转为`double`类型等

## 附录B 对标准库的总结

## 附录C C语言版本更新的总结

各个特定的编译器是解释语言的最终权威。

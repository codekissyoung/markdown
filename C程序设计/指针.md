# 指针

`指针`: 变量的起始内存地址称为`指针`，`指针类型`决定了如何读取取该内存地址后面的数据:取几个字节，如何切分;如：`int型`就该按4个字节依次读取;

`指针类型`非常重要，它决定了程序是如何使用指针指向的内存，`指针`只是一个内存地址的数值，`指针`可以被强制转换成任意一种`指针类型`，不同`指针类型`的`指针变量`不能相互赋值;

`指针变量` ： 不过是一个保存数字的变量罢了，64位下占用 8 字节；使用`&`可以查看`指针变量`自己的内存地址；指针也就是一般的数字，跟`long`类型一样长，`long a = (long)p` 直接将指针变量保存到`long`类型的变量a中

为什么要使用指针？

- 函数调用时，可以只传递一个指针，而不用传递全部数据
- 让两段代码处理同一条数据，而不是处理两段独立的副本

## 变量的内存地址

- `&var_name` 获取变量内存地址; `printf("内存地址: %p",(void *)&var_name);` 打印变量的内存地址
- 一个程序跑起来后，内存分布由高位到低位划分为 `栈区 - 堆区 - 全局变量区 - 常量段 - 代码段`

## 指针作为函数的入参

- 函数的入参是变量，调用时函数生成该变量的拷贝在函数里使用；在函数里修改拷贝的值，对函数外的该变量没有影响
- 函数的入参是变量的`起始内存地址`，在函数里直接修改该内存地址处的值，与在函数外部修改该变量是一样的效果，内存地址即是指针

## 使用指针的步骤

```c
void func( int * ); // 函数声明

int x = 4;          // 定义变量
int *address_of_x;  // 1. 定义与变量相同类型的指针
address_of_x = &x;  // 2. &x 获取该变量的地址,再赋值给指针

func( address_of_x ); // 3. 将内存地址传进去

// 函数定义
void func( int *address_of_x )
{
    printf("value of x : %d \n ", *address_of_x ); // 4. *address_of_x 获取该内存地址(指针)处的值

    *address_of_x = 100;                           // 5. 修改该内存地址(指针)存储的值
}
```

## 函数入参为数组

- sizeof 是运算符，编译器将其编译为一串指令；在编译时就已经确定了存储空间的大小
- 而函数被编译为代码片段，调用函数，程序会跳到这段独立的代码片段中执行；
- 传递数组到函数中，就只会传递数组内存首地址，为了效率，C就是这么设计的；
- 所以sizeof在函数外面计算的是str数组的字节数 12，而在函数里面计算的是指针占用的字节数 8

```c
#include "stdio.h"
void fortune_cookie( char* );

int main( int argc, char *argv[] )
{
    char str[] = "Hello world";
    printf("%ld\n",sizeof(str)); // 12
    fortune_cookie(str); // str 是一个数组，作为传参，只赋值内存首地址给 msg 就可以了
    return 0;
}

void fortune_cookie( char* msg )
{
    printf("%s\n",msg);
    printf("%ld\n",sizeof(msg)); // 8
}
```

- sizeof(数组) 是数组的大小，sizeof(指针)返回 8 或者 4

```c
char s[] = "How big is it?";
char *t = s;

sizeof(s); // 15
sizeof(t); // 8
```

- 指针变量的内存地址与其指向的内存地址不同；并且其指向的内存地址可以随意改变
- 而数组名的内存地址与其指向的内存地址相同，并且不允许更改数组指向的内存地址

```c
s == &s;  // s是数组名 true
t == &t;  // t是指针 false
```

- 指针与数组的关系, `arr[1]` 等价于 `*(arr + 1)`, 指针的运算中 `+1`指的是地址偏移`指针类型`的字节数
- 下面这段代码中，`doses`为数组指针,于是 `doses[3] == *(doses + 3) == *(3 + doses) == 3[doses]`
- 在C的编译过程中，`arr[2]`会编译成 `*( arr + 2 )`，再编译成 `*( arr的内存地址 + arr指针类型的字节数)`，所以`3[doses]`经过编译后，计算的结果与`doses[3]`是一样的
- 把数组变量传给指针，会发送退化；索引的本质 是 **指针算术运算**,所以数组从 0 开始; 指针变量具有类型，这样就能调整 **指针算术运算** 。
- C语言什么时候对 **指针算术运算** 进行调整?
  - 在编译器生成可执行文件时，编译器根据变量的类型，使用 `该类型的字节数 乘以 指针的增量或者减量`
  - sizeof运算符的结果也是在编译时就决定好的，对各种数据类型，sizeof 和 **指针算术运算** 都将使用同样的长度

```c
#include "stdio.h"
int main( int argc, char *argv[] )
{
    int doses[] = {1,3,2,1000};
    printf("%i\n",3[doses]); // 1000
    return 0;
}
```


## 数组指针

```c
int var = 10;   // 定义变量
int* a　= &var; // 定义指针
*a;             // 访问指针的值
a+1;            // 将内存地址加4

short* b;
b+1; // 将内存地址加２,指针存储的内存地址的加减跟"指针类型"有直接关系

int arr[3] = {1,2,3}; // 声明数组
int* parr = arr;      // 声明指针指向数组
printf("%d",*parr);      // 输出1
printf("%d",*(parr+1));  // 输出2
printf("%d",parr[2]);    // 输出３


int (* p_arr)[10];
int arr[3] = {1,2,3}; // arr为数组,也是指针常量,arr的值不可变, arr++是错误的
int* prr = arr;       // 将arr赋值给prr指针,prr++正确
*arr;                 // 等价于 arr[0]
*(arr+1);             // 等价于 arr[1]
*(arr+2);             // 等价于arr[2]
&arr[2] - &arr[0];    // 2  地址相差2
int sum (int *ar,int n){} // 等价于 int sum (int ar[],int n){}
```

### 指向多维数组的指针

```c
// 指向多维数组的指针
int zippo[3][2] =
{
    {2,3},
    {4,5},
    {6,7}
};
int (* pz)[2]; // 指向一个含有两个int类型值的数组
pz = zippo;
printf("zippo : %p , zippo[0]: %p :zippo[0][0] : %d \n",zippo,zippo[0],zippo[0][0]);
printf("pz : %p , *pz: %p : **pz: %d \n",pz,*pz,**pz);
printf("pz = %p,pz + 1:%p \n",pz,pz+1);
printf("pz[0] = %p,pz[0] + 1:%p \n",pz[0],pz[0]+1);
printf("*pz = %p,*pz + 1:%p \n",*pz,*pz+1);
printf("**pz = %d,*(*pz + 1):%d \n",**pz,*(*pz+1));
printf("**(pz + 1) = %d,*(*(pz + 1) + 1):%d \n",**(pz + 1),*(*(pz + 1)+1));
printf("pz[0][0] = %d,pz[0][1]:%d \n",pz[0][0],pz[0][1]);
```

- `[]`的优先级高于`*`
- `int (*pz)[2]` pz先与`*`结合，说明它是一个指针，`[2]`说明了这个指针指向的内存字节大小
- `int *pz[2]` pz先与`[2]`结合，说明它是含有两个元素的数组，`int *` 说明它的两个元素是`int`类型的指针
- `char *argc[]` pz先与`[]`结合，说明是一个不定个数元素的数组，`char*`说明这些元素都是`char`类型的指针,结合`char *ch = "test";`,可以得出`argc[0]` `argc[1]`等都是字符串
- `zippo` 存的是一个地址,`zippo[0]`存的也是一个地址,前一个地址类型为两个int的数组，后一个地址的类型是int,`zippo[0][0]`就是该地址处的值了
- `pz` 存的是一个地址,`*pz`存的也是一个地址,前一个地址类型为两个int的数组，后一个地址的类型是int，`**pz`就是该地址处的值了

### 函数指针

- `函数指针` : 指向函数函数指针可以像一般函数一样，用于调用函数、传递参数
- 声明一个指向函数的指针，函数指针常用作另一个函数的参数

```c
int (* p_fun)( int , int);
typedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型

#include <stdio.h>
int get_big(int i,int j){
    return i > j ? i : j;
}
//将指向函数的指针int (*p)(int,int) 作为形参，传递函数
int get_max( int i, int j, int k, int (*p)(int ,int) )
{
    int ret;
    ret = p(i,j);//使用函数指针掉用函数，跟使用函数是一样的！
    ret = p(ret,k);
    return ret;
}
int main(int argc,char **argv){
    int i = 5,j = 10,k = 15,ret;
    // 将get_big函数传进去，在get_max里面调用
    ret = get_max(i,j,k,get_big);
    printf("the max is %d\n",ret);
    return 0;
}

// 传递二维数组的地址
func(int arr[][4],int length){}
// 等价于
func(int (*arr)[4],int length){}
(*arr)[4];               // 指向列数为4的二维数组的指针, arr+1 就是移动 4 x 4 个字节
*(*(index + 2)+1)        // 等价于 index[2][1]
int  (*pz)[2];           // 声明指向二维数组的指针
int  *pax[2];            // 声明装有两个int型指针的数组;
int array[][4];          // 定义二维数组
int *p2array = array;  // 二维数组的指针
*(*(p2array+3)+2)        // 等价于 array[3][2] 等价于 p2array[3][2]

void ToUpper(char *); // 函数
void (*pf)(char *); // 指向函数的指针

// 区别于
void *pf(char *); // pf 是一个函数，它返回字符指针
```

### 指针的指针

```c
int **p_point;
```

### void任意类型指针

```c
// ANSI错误: 进行算法操作的指针必须是确定知道其 指向数据类型 大小的
// 也就是说，不但要知道器内存地址，还要知道 可以访问 内存地址后的几个字节
void *povid;
povid++;
povid+=1;  

// 这两个函数都是操作一片内存，而不关心知道参数 指针 是什么类型 并且 其返回的也是任意类型的 指针
void *memcpy(void *dest , const  void *src, size_t,len);
void *memset(void *buffer , int c,size_t num);
```

### const 修饰指针

```c
// 表示该函数不会使用指针改变数据
void show_array( const double *ar, int n );

// 不能改变指针的指向 , 但是可以改变它指向处的值
double * const pc = rates;
pc = &rates[2]; // 编译错误
*pc = 11; // 可以改变它指向处的值
```

### 指针的兼容性

- 不同类型的指针不能相互赋值

```c
int n = 5;
double x = 4.2;
int *p1 = &n;
double *pd = &x;
x = n; // 隐式类型转换
pd = p1; // 错误　int 类型指针赋值给　double 类型指针

int *pt;
int (*pa)[3];
int ar1[2][3];
int ar2[3][2];
int **p2;
pt = &ar1[0][0]; // 指向int的指针
pt = ar1[0]; //　等价上
pt = ar1; // 错误, ar1 是指向内含3个int类型元素的数组的指针
pa = ar1; //　都是指向内含3个int类型元素的数组的指针
pa = ar2; // 错误，ar2 是指向内含2个int类型元素的数组的指针
p2 = &pt; // 指针的指针，
*p2 = ar2[0]; // *p2 等价于　pt , pt 是指向int类型的指针,ar2[0]也是指向int类型的指针
p2 = ar2; // p2 为指向int类型指针的指针，ar2 是指向内含2个int类型元素的指针
```

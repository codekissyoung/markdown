# 从汇编看C语言

自从学完Linux下64位汇编语言后，对C的理解更深入了一步，本文记录了我再次看C时的想法。

C语言翻译成汇编语言，只有 全局变量 和 函数 有自己的名字(也是内存地址)，类型信息、局部变量都被抹去，取而代之的是反复利用的“寄存器”和精确计算好的“内存地址+偏移量”。

## 简单的汇编语言

从这个意义上来说，汇编代码比C语言简单的多，因为它规则少并且统一。用汇编语言是自由的，它所有的操作都限定在“寄存器”（有名字的盒子）和“内存”（有编号的抽屉）中。它所有的操作不过是:


- 线性执行指令 + (有条件的)跳转，就实现了循环与选择分支功能
- 将盒子的数据移动到抽屉，或者反过来
- 将两个盒子的数据进行加减乘除、与、或...运算
- 一个栈模型，数据通过指定顺序的寄存器`rdi` `rsi` `rdx`...传入数据、`偏移值(rbp)`传出数据

C编译器实现的块作用域、静态变量、数据类型、指针等功能，带来了非常多规则和程序结构，人需要花时间去理解、总结和记忆这些规则，但省却了计算“内存地址+偏移量”这类工作。

## C提供的数据类型

#### 变量在汇编里面是怎样的

![2019-10-17 19-45-23 的屏幕截图.png](https://img.codekissyoung.com/2019/10/17/9c013c62fc1cdcf550095992b53da58a.png)

如图，全局变量在汇编里面就是全局区`.data`一处地址，占用固定字节，而局部变量则变成了指令里的“立即数”、或者直接用寄存器充当了、寄存器用完时也是会使用栈区内存代替的。总之变量名肯定是没了的。

#### 基本类型

![2019-10-16 11-51-56 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/fe87769709239601d145a6d9e46b0bad.png)

对于基本类型，在汇编看来，只有占用字节大小的不同，并无类型信息。对于`name`,它是`char*`类型指针，指向的内容在只读区`.rodata`中，同时也可以得知，name存的就是`.LC0`处的地址。

#### 数组

![2019-10-16 12-21-33 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/dff1159a9a630d3eef13dc747e361ae6.png)

再看数组，其实数组名就是数组首地址，数组元素在全局数据区`.data`。

指针可以修改，而数组名不可修改的原因就是：指针`name`自身有地址，并且存储的数据是别的数据的地址，而数组名处地址存的就是自己的元素。

从图里，也可以看出使用 指针`name` 和 数组`words` 表示字符串的区别。

#### 英文字符 与 中文字符

![2019-10-17 19-53-17 的屏幕截图.png](https://img.codekissyoung.com/2019/10/17/a6c80e165f7cbf38788355b00ac60b21.png)

计算机在存储字符时，不是存储的实际字符，而是存储该字符在“字符集”中的编号（编码值）。

在C语言中:

- `char`类型的窄字符，使用使用ASCII编码
- `char`类型的窄字符**串**，微软编译器使用本地编码；GCC、LLVM/Clang 使用和源文件编码相同的编码，上图中可以看到汉字部分都转化成了源文件的`UTF-8`编码值

如果是宽字符类型：

C语言规定，对于汉语、日语、韩语等 `ASCII` 编码之外的单个字符，也就是专门的字符类型，要使用宽字符的编码方式。常见的宽字符编码有 `UTF-16` 和 `UTF-32`（都基于 `Unicode` 字符集）。

但在实现时，微软编译器采用 `UTF-16`，使用 2 字节存储一个字符，而GCC、LLVM/Clang 采用`UTF-32`编码，使用 4 字节存储字符。

`<wchar.h>`中定义了`wchar_t`类型专门用来存放宽字符，同时也提供了`putwchar()`、`wprintf()`、`%lc`格式等用于输出宽字符。程序中，字符“立即数”需要使用`L`前缀来表明是宽字符。在控制台若想看到宽字符的输出，还需进行设置，代码参考如下：

```c
#include <stdio.h>
#include <locale.h>
wchar_t name[] = L"彦神1995";
int main(){
    setlocale( LC_ALL, "zh_CN" );
    wprintf( "%lc", name);
    return 0;
}
```

#### 枚举

![2019-10-16 12-26-16 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/d6df5802ac638b809e842583fb0d409e.png)

我们定义了一种枚举类型`enum color`,但这个类型只在编译器是有用的，变成汇编代码后，这个类型就消失了，只保留了使用这个类型定义的实体 `r` 和 `b`,而这个两个实体在汇编看来和其他数据类型(比如`int`)定义的实体 没有任何区别。

#### 结构体

![2019-10-16 13-21-38 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/f29af8388db357f58e03f2d131d614f4.png)

#### Union

![2019-10-16 16-31-41 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/54d7bfa532d8db26ac59e1978585982f.png)

如图，`union`中所有的数据成员共用一个空间，同一个时间只能储存其中一个数据成员，所有的数据成员具有相同的起始数据地址，未初始化的数据存于 `.bss`区，`char[30]`到了汇编里成了`32`是为了内存对齐。

#### 位域

![2019-10-16 17-03-51 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/6b0b474e87243748fd68a374e7f1a231.png)

#### 内存对齐

内存对齐是编译器的行为，一般来说，编译器会设置CPU位数的对齐系数，比如下图是64位机器，对齐系数是8`Byte`,结构体`Align_Y`的内存分布就如汇编代码所看到的：

![2019-10-16 17-43-30 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/8c94be141eb6432921c96c1bd6d607ef.png)

但是我们也可以人为指示编译器，使用指定的对齐系数进行对齐，C代码如下:

```c
#pragma pack(4)             // 可设置 1, 2, 4, 8
```

下图便是同样的代码，依次设置`1, 2, 4`后生成的汇编代码，可以对比下结构体的内存分布:

![101617561036_02019-10-16 17-51-59 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/95a85a4b3b8a9389aab22e3690c111e6.png)

我们为神马要编译器进行内存对齐操作?
- 平台原因: 不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常
- 性能原因: 某些cpu把内存当成是一块一块的，块的大小可以是2,4,8,16 个字节，因此CPU在读取内存的时候是一块一块进行读取的，块的大小称为内存读取粒度

## 指针

![2019-10-16 20-20-24 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/442b6cf4721ee59891ded5dbf20850cd.png)

指针就是存储数据的内存首地址，编译器根据指针类型产生处理的汇编代码，在汇编代码中就没有任何指针类型信息了，有的只是地址和偏移值。

传递一个指针到函数中，其实就是把一个内存地址给了函数，函数中通过括号操作寄存器,比如`movl %edx,(%rsi)`就是把`edx`中的值传送到`rsi`中所存地址处的值。

![2019-10-16 20-40-39 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/41f07926dc1707f5779d5b5b6bcb3888.png)

`sizeof`是编译器实现的一种计算，与汇编代码无关。编译器认定`sizeof(arr)`在函数外是计算数组`arr`的元素个数,而在`arr`用作指针传入到函数内使用时，再使用`sizeof(arr)`计算时,就成了`arr`指针的字节数。

![2019-10-16 20-49-35 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/fcc13a363302e035e7be6c11e3ee879d.png)

如上图,`arr[2]` 等价于 `*( arr + 2 )`，编译器翻译为 `*( arr地址 + 该指针类型字节数 x 2)`。`3[doses]`编译后的结果与`doses[3]`是一样的，实际上有：`doses[3] == *(doses + 3) == *(3 + doses) == 3[doses]`。

![2019-10-16 21-11-06 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/4b5ec62e3023cb070cd15a686d002391.png)

编译器规定，由于`[]`的优先级高于`*`,`pi`是包含2个`int*`指针的数组。而`pz`是一个指针，`[2]`指示该指针指向内存区域的大小为`2 x int`个字节。经过编译器后，这些类型信息都会被抹去，因此在汇编代码里的表示非常简单：地址 + 偏移量。

#### 函数指针

![2019-10-17 01-31-31 的屏幕截图.png](https://img.codekissyoung.com/2019/10/17/fc15da877d622baa5f249a641dabcbe7.png)

可以看到函数指针也就是普通的地址，在被调函数中，通过`*%rcx`的方式使用这个地址。


## 静态变量

![2019-10-17 10-50-37 的屏幕截图.png](https://img.codekissyoung.com/2019/10/17/7f749ce6cb7e7ec110041f86e5a12dd0.png)

从编译结果看，函数内部的静态变量在汇编代码中存放在`.data`区，函数返回后也不会消失，函数每次调用都使用的是这个地址。在汇编语言看来，静态变量与全局变量没有差别，可以推知静态变量是编译器实现的功能。

#### 变量同名遮蔽

![2019-10-17 11-20-20 的屏幕截图.png](https://img.codekissyoung.com/2019/10/17/7e733d98d30bbc58abe562354b5730fd.png)

C语言翻译成汇编语言，只有 全局变量 和 函数 有自己的名字(也是内存地址)，类型信息、局部变量都被抹去，取而代之的是反复利用的`寄存器`和精确计算好的`内存地址+偏移量`。

从这个意义上来说，汇编代码比C语言简单的多，因为它规则 **少** 并且 **统一**，用汇编语言是自由的。C编译器实现的块作用域、静态变量、数据类型、指针等功能，带来了非常多规则和程序结构，人需要花时间去理解、总结和记忆这些规则，但省却了计算`内存地址+偏移量`这类工作。




# 从汇编看C语言

自从学完Linux下64位汇编语言后，对C的理解更深入了一步，本文记录了我再次看C时的想法。

## C提供的数据类型

![2019-10-16 11-51-56 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/fe87769709239601d145a6d9e46b0bad.png)

对于基本类型，在汇编看来，只有占用字节大小的不同，并无类型信息。对于`name`,它是`char*`类型指针，指向的内容在只读区`.rodata`中，同时也可以得知，name存的就是`.LC0`处的地址。

#### 数组

![2019-10-16 12-21-33 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/dff1159a9a630d3eef13dc747e361ae6.png)

再看数组，其实数组名就是数组首地址，数组元素在全局数据区`.data`。

指针可以修改，而数组名不可修改的原因？

- 指针`name`自身有地址，并且存储的数据是别的数据的地址，而数组名处地址存的就是自己的元素。

从图里，也可以看出使用 指针`name` 和 数组`words` 表示字符串的区别。

#### 枚举

![2019-10-16 12-26-16 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/d6df5802ac638b809e842583fb0d409e.png)

我们定义了一种枚举类型`enum color`,但这个类型只在编译器是有用的，变成汇编代码后，这个类型就消失了，只保留了使用这个类型定义的实体 `r` 和 `b`,而这个两个实体在汇编看来和其他数据类型(比如`int`)定义的实体 没有任何区别。

#### 结构体

![2019-10-16 13-21-38 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/f29af8388db357f58e03f2d131d614f4.png)

#### Union

![2019-10-16 16-31-41 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/54d7bfa532d8db26ac59e1978585982f.png)

如图，`union`中所有的数据成员共用一个空间，同一个时间只能储存其中一个数据成员，所有的数据成员具有相同的起始数据地址，未初始化的数据存于 `.bss`区，`char[30]`到了汇编里成了`32`是为了内存对齐。

#### 位域

![2019-10-16 17-03-51 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/6b0b474e87243748fd68a374e7f1a231.png)

#### 内存对齐

内存对齐是编译器的行为，一般来说，编译器会设置CPU位数的对齐系数，比如下图是64位机器，对齐系数是8`Byte`,结构体`Align_Y`的内存分布就如汇编代码所看到的：

![2019-10-16 17-43-30 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/8c94be141eb6432921c96c1bd6d607ef.png)

但是我们也可以人为指示编译器，使用指定的对齐系数进行对齐，C代码如下:

```c
#pragma pack(4)             // 可设置 1, 2, 4, 8
```

下图便是同样的代码，依次设置`1, 2, 4`后生成的汇编代码，可以对比下结构体的内存分布:

![101617561036_02019-10-16 17-51-59 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/95a85a4b3b8a9389aab22e3690c111e6.png)

我们为神马要编译器进行内存对齐操作?
- 平台原因: 不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常
- 性能原因: 某些cpu把内存当成是一块一块的，块的大小可以是2,4,8,16 个字节，因此CPU在读取内存的时候是一块一块进行读取的，块的大小称为内存读取粒度

## 指针

![2019-10-16 20-20-24 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/442b6cf4721ee59891ded5dbf20850cd.png)

指针就是存储数据的内存首地址，编译器根据指针类型产生处理的汇编代码，在汇编代码中就没有任何指针类型信息了，有的只是地址和偏移值。

传递一个指针到函数中，其实就是把一个内存地址给了函数，函数中通过括号操作寄存器,比如`movl %edx,(%rsi)`就是把`edx`中的值传送到`rsi`中所存地址处的值。

![2019-10-16 20-40-39 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/41f07926dc1707f5779d5b5b6bcb3888.png)

`sizeof`是编译器实现的一种计算，与汇编代码无关。编译器认定`sizeof(arr)`在函数外是计算数组`arr`的元素个数,而在`arr`用作指针传入到函数内使用时，再使用`sizeof(arr)`计算时,就成了`arr`指针的字节数。

![2019-10-16 20-49-35 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/fcc13a363302e035e7be6c11e3ee879d.png)

如上图,`arr[2]` 等价于 `*( arr + 2 )`，编译器翻译为 `*( arr地址 + 该指针类型字节数 x 2)`。`3[doses]`编译后的结果与`doses[3]`是一样的，实际上有：`doses[3] == *(doses + 3) == *(3 + doses) == 3[doses]`。

![2019-10-16 21-11-06 的屏幕截图.png](https://img.codekissyoung.com/2019/10/16/4b5ec62e3023cb070cd15a686d002391.png)

编译器规定，由于`[]`的优先级高于`*`,`pi`是包含2个`int*`指针的数组。而`pz`是一个指针，`[2]`指示该指针指向内存区域的大小为`2 x int`个字节。经过编译器后，这些类型信息都会被抹去，因此在汇编代码里的表示非常简单：地址 + 偏移量。

#### 函数指针

![2019-10-17 01-31-31 的屏幕截图.png](https://img.codekissyoung.com/2019/10/17/fc15da877d622baa5f249a641dabcbe7.png)

可以看到函数指针也就是普通的地址，在被调函数中，通过`*%rcx`的方式使用这个地址。
# 《C陷阱与缺陷》笔记

本文是《C陷阱与缺陷》笔记,记录了一些我觉得容易犯的错误。

## 词法陷阱

`=`不等于`==`。

`|`与`&`不同于`||`和`&&`。

词法分析采用“贪心法”：每一个符号尽可能包含更多的字符:

- `a---b`与`（a--) - b`相同，而不是`a - (--b)`
- `y = x/*p`中，`/*`为注释的开始，若要表达`*p`为除数，则需写成`y = x / *p`或者明确`y = x/(*p)`

### 8进制写法

```c
int a = 015;      // 为了对齐，添加了一个0,却引入了Bug
int b = 123;
printf("%d\n",a); // 13
printf("%d\n",b); // 123
```

### 字符与字符串

`"\n"` 与 `'\n'`含义不一样，前者是字符串,后者是字符（也即是一个数字）。

`char *slash = '/';` 错误，将数字赋值给指针。

`printf('\n');` 错误，将数字赋值给指针。

## 语法陷阱

### 理解函数声明

```c
( *( void(*)() ) 0 )();
```

上述声明该如何理解？构造这类表达式只有一条简单的规则:按照使用的方式来声明。

```c
float f;
float ((g)); // 同上含义一致
```

对`f`与`((g))`的求值结果的类型为`float`,可以推知`g`的类型是`float`。

```c
float ff();
float *pf;
```

`ff()`的求值结果，即返回值为`float`类型，`*pf`的求值结果为`float`,可以推知`pf`的类型为`float指针`。

```c
float *g();
```

`()`的优先级高于`*`，`*g()`求值结果为`float`，可以推知`g()`的求值结果为`float指针`,可以推知`g`是一个函数名。

```c
float (*h)();
```

`(*h)()`的求值结果为`float`，可以推知`(*h)`的求值结果是一个函数名，可以推知`h`是一个函数指针，它指向这个函数。

因此`(float (*)())`就是`h`的类型，具体含义为“指向函数 (返回值为`float`,参数为空) 的指针类型”，使用这个类型就可以声明这样的一个指针。

> 函数的求值结果，就是函数的返回值，两者是一个意思。

现在我们来拆解`( *( void(*)() ) 0 )();`:

1. `( *( void(*)() ) 0 )`是一个函数名
2. `func() 0`这样的写法是非常老的一种C语法，`func()`的默认初始化为0，所以`*( void(*)() )`的求值结果为一个函数名
3. 所以可以推知`void(*)()`的求值结果为函数指针
4. 所以可以推知`void(*)`是一个函数名，那么它里面就是一个指针，没有变量名，说明它是类型，可以声明这种指针
5. 所以最后可以推知`( *( void(*)() ) 0 )()`是一种类型，它声明一个函数指针`A`。`A`指向的函数的返回值也是一个函数指针`B`，`B`指向的函数 无参数，也无返回值。

```c
void ( *signal( int, void(*)(int) ) )(int);// signal 函数的声明

//　使用typedef简化
typedef void (*HANDLER)(int);
HANDLER signal(int, HANDLER);
```

### 注意运算符的优先级

```c
if( flags & FLAG != 0 ) // 等价与 if( flags & ( FLAG != 0 ) ) 很明显逻辑错了

r = hi << 4 + low; // 等价于 hi << ( 4 + low ) 很明显逻辑错了
```

`=`运算符最低，其次是`?:`运算符，`+`算术运算符高于`<<`移位运算符。

记忆口诀:

```bash
括号成员第一        # [] () -> .
全体单目第二        # ++ -- * &
乘除余三           # * / %
加减四             # + -
移位五             # >> <<
关系六             # < > >= <=
等于不等排第七      # == !=
位运八　　　　　　　 # >> << | & ^ ~
逻辑九             # && ||
三目十             # ?:
```

### 标点符号

多余的分号:

```c
if( x[i] > big ); // 这里的标点符号，将代码原来的意思完全改变了，而且编译器还没有提示报错
    big = x[i];

if( n < 3 )
    return        // 漏掉的 ; 完全改变了代码愿意

logrec.date = x[0];
logrec.time = x[1];
```

漏掉的`break`:

```c
case '\n':
    line_cnt ++;
    // 此处漏了break
case '\t':
    ...;
```

### 不对等的else

```c
if( x == 0 )
    if( y == 0 )
        error();
else{
    z = x + y;
}
```

## 语义陷阱

### 数组与数组

数组:

- C语言只有一维数组，数组的每个元素可以是另一个一维数组或者是结构体，数组的大小必须在编译期就确定。
- 对于一个数组，我们只能做两件事:
  - 确定数组的大小
  - 获得指向下标为０的元素的指针，下标的运算其实内部实现都是指针的运算

```c
int calendar[12][32];
```

上诉代码，`sizeof(calendar)`的值是`12 * 31 * sizeof(int)`,它的类型是`int [12][32]`类型，如果`calendar`用在其他场合(除了`sizeof`),它总是被转换成`int [32]`类型的指针。

```c
calendar[month][day];

// 等价于

*(*(calendar + month) + day);
```

数组名作为参数时，会转换成数组第一个元素类型的指针:

```c
char hello[] = "hello";

printf("%s\n", hello);

// 等价于

printf("%s\n", &hello[0]);
```

### 使用不对称边界

如果想表示数组中的一段元素，是`16 <= x && x <= 37`好呢？还是`16 <= x && x < 38`好呢？

`16`称为入界点，后面的值称为出界点，那么我们的出界点该怎么取，才能够简化程序代码？

如果使用前一种:

- 区间元素个数 `cnt = 37 - 16 + 1`
- 但上界，与下界相等时，表示还有一个元素
- 当下界 大于 上界时，表示没有元素

如果使用后一种:

- 区间元素个数 `cnt = 38 - 16`
- 下界面小于上界面时，表示还有元素
- 当下界面通过递增，等于上界面时，即表示没有元素
- 上述性质，其实保证了上界永远不会小于下届

综上我们处理数组时，下界就是`0`,上界取数组的元素个数,所以遍历代码应该写成:

```c
int a[10];

for ( int i = 0; i < 10; i++ )
    a[i] = i * i;
```

### 检测整形溢出

```c
unsigned int a;
unsigned int b;

scanf("%d %d", &a, &b );
// ...

if( a + b < 0 ){
    error("溢出");
}
```

在某些机器上，上述代码是有误的,那些机器可能采用了一个内部寄存器存储`正` `负` `零` `溢出`四种状态，`a+b`的状态是溢出，而不是负，所以条件判断会失灵。正确的检测方法如下:

```c
if( a + b > INT_MAX ){
    error("溢出");
}
```

### 死循环代码

在某些编译器下，容易死循环的一段代码。数组越界修改了`i`的值导致的。

```c
int main(int argc, char *argv[])
{
    int i;
    int a[10];
    for(i = 0; i <= 10; i++) // 数组越界
        a[i] = 0;
    return 0;
}
```

### 字符串总是需要多一个空间存储`\\0`

```c
char *r;

r = malloc( strlen(s) + strlen(t) + 1 );

strcpy( r, s );
strcat( r, t );
```

### 不要混淆指针与指针指向的数据

```c
char *p;
char *q;

p = "xyz";

q = p;
```

上诉代码中，`p`指针本身的值为`"xyz"`字符串的起始地址，代码执行后的情况如下:

![代码执行](https://img.codekissyoung.com/2019/06/28/29f0356c77d144805ddd6eede84eae00.png)

## 链接

介绍了一些链接错误，声明与定义之类的错误，比较熟悉，不记录了。

## 库函数

略过。

## 预处理器

小心空格:

```c
#define f (x) ((x)-1)

// 上述代码含义: f 代表 (x) ((x)-1)
```

上述代码，如果想定义`f(x)`为`((x)-1)`,则必须将`f`与`(x)`中间的空格去除。

宏并不是函数，添加那么多的`()`是为了防止优先级错误:

```c
#define abs(x) (((x)>=0)?(x):-(x))
#define max(a,b) ((a)>(b)?(a):(b))
```

宏并不是语句,`assert`断言的例子

```c
if( x > 0 && y > 0 )
    assert( x > y);
else
    assert( y > x );

// 上述代码展开后，明显发现结构乱了

if( x > 0 && y > 0 )
    if(!(x > y)) assert_error("foo.c",37);
else
    if(!(y>x)) assert_error("foo.c",39);
```

宏不是类型定义:

```c
#define T1 struct foo *
typedef struct foo *T2;

T1 a, b; // a 是指针, b是结构体
T2 c, d; // c,d都是指针
```

## 可移植性缺陷

C标准的支持和变更

标识符名称的限制

整数的大小

字符是有符号数还是无符号数?对于有符号数，右移时左边是补`0`还是补`符号位`?

内存位置`0`的操作:读保护？

```c
q = a / b;
r = a % b;
```

除法与求余数运算:

- 要求满足: `q * b + r = a`，这条是必须要满足的，因为这是余数的定义
- 要求满足: 修改`a`的正负号，`q`的正负号也随之改变
- 要求满足: 当`b>0`时，我们希望保证`r>=0`且`r<b`

举个例子:`3 / 2 = 1 余数为 1`，当`-3 / 2`时，如果要满足第２条性质，商为`-1`,根据余数的定义，余数为`-1`，但是这就破坏了第３条规则。三条需求中，大多数C语言只遵守前两条。

## 建议与答案

有的逻辑错误，编译器不会提示，要仔细谨慎写代码。

直接了当表明意图。

首先考虑输入为空的情况。

使用不对称边界。

防御性编程。

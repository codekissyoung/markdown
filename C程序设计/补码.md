# 补码

- [关于2的补码-阮一峰的网络日志](http://www.ruanyifeng.com/blog/2009/08/twos_complement.html)
- [你真的了解补码吗](https://www.jianshu.com/p/3004e5999be4)
- [你真的了解Java中的负数?](https://my.oschina.net/joymufeng/blog/139952)

现实生活中，我们有加法、减法、乘法和除法，但在计算机中只有一个加法器。换句话说，加法运算在计算机中可以直接完成，减法、乘法和除法运算最终也得转换为加法才能实现。

一个数减去另外一个数，与一个数加上 "另外一个数的补码" 结果是一样的。这就是补码对于计算机的意义：将减法运算变成了加法运算。

![pIYBAFqWYmiATS3oAABXSWadEV4867.png](https://i.loli.net/2019/03/12/5c8790a19e0b0.png)

## 时钟

理解补码最简单的例子就是时钟。

假如一个时钟现在显示的是10点钟，如何将它调到6点钟？

答：有两种方法，一是向后拨8个小时，二是向前拨4个小时。

在这个例子中，8 和 4 互为补数，也就是说4的补码是8,8的补码是4，而这个时钟的模就是12。可能有人会想，在往后调8个小时虽然也调到了6点，但是他实际上比原来日期多了12小时。是的，的确如此，但是你的时钟有地方存储了这多余的12个小时吗？答案是没有，所以在你调完后，你没有记录这12个小时，换句话说，你把这溢出的12个小时自动舍弃了。当第二个人来查看闹钟时间的时候，他看到的时间就是准的。

一个数的数值是11，他的模是16，那么他的补码是多少？

16 - 11 = 5，即补码就是5。

### 模 mod

**计数系统** : 一个计数系统可以存多少容量状态的数，我叫它作为计数系统的`Mod`。一个计数系统不断地加一，那么它表示的数的状态也会周期性地变化，我叫这个周期的大小叫做`Mod`

举个两个例子：

- 一个包含两个bit的存储单位，它可以表示`00`，加一变成`01`，加一变成`10`，加一变成`11`，再加一又变成了`00`。即该计数系统的`Mod`为`4`
- 一个时钟显示十二个小时，时针旋转一周后回到原来的状态，即该系统的`Mod`为`12`

### 变减为加

设`Mod = 16`

若`a=3，b=-4`

则：

```bash

a + b = 3 - 4 = -1;

a + b = a + b + Mod;

a + b + Mod = a + ( Mod + b) = 3 + ( Mod - 4 ) = 15

-1 = 15; # 在计数系统中 -1 和 15 等价

Mod - 4 = 12;
```

`4` 与 `Mod - 4` 互为关于`Mod`的补数，`被减数 - 减数` 等价于`被减数 + Mod - 减数`，即 `被减数 + 减数的补数`。

所以，所有的减法在计算机中都可以转化为加上减数的补数，对应计算机上的概念就是补码。

### 使用补码运算

16 - 13，模为32，使用补码运算该算式？

```bash
(16 + ( 32 - 13 ) ) % 32 = 35 % 32 = 3 
```

想想看，原先是减一个数，变换后却变成了一个比减数更大的加数了，能不溢出吗。所以要模掉溢出位`35 % 32`。跟时钟未记录的12个小时是一个道理。

### 约定的正负号

设现有一个4位的计数系统，那么我们可以知道该系统的Mod=16，即该系统一共可以表示16个状态。我也约定这个四位系统的0000状态为0，向前连续加十六得到0000本身，对应表示的数字如下：

```bash
1111 = 15    0000 = 0
1110 = 14    0001 = 1
1101 = 13    0010 = 2
1100 = 12    0011 = 3
1011 = 11    0100 = 4
1010 = 10    0101 = 5
1001 = 9     0110 = 6
1000 = 8     0111 = 7
```

如果这个计数系统是无符号位的，显然可以知道它表示的数据范围为：0~15。如果这个计数系统是有符号位的呢？

首先要对这些数据进行分配，现在的教科书上的做法就是把Mod前一半划分给0~7，后一半Mod划分给-8~-1，即如下图（这里二进制都是补码）:

```bash
1111 = -1    0000 = 0
1110 = -2    0001 = 1
1101 = -3    0010 = 2
1100 = -4    0011 = 3
1011 = -5    0100 = 4
1010 = -6    0101 = 5
1001 = -7    0110 = 6
1000 = -8    0111 = 7
```

可以看出，最高位为0的即是正数，最高位为1的即是负数。至于为什么`-1 就是 1111`呢？

Mod为16,即`10000`,对于`1 - 1 = 0`这个等式，等价于`1 + (-1) = 0`；即`0001（二进制） + （-1）= 0000（二进制）`，那么`（-1）= 0000 - 0001`，向高位借1位后，减得`（-1）= 1111（二进制）`，所以计算机中使用`1111`来表示以及存储`-1`。

## 无符号数

无符号数强制转换为有符号数:
![23234628-f98b86e7e2e849e39f448134b000e2ea.jpg](https://i.loli.net/2019/03/12/5c8790a17b6aa.jpg)

有符号数强制转换为无符号数:
![23232728-24927279e84a4686a8f8e3efe7892956.jpg](https://i.loli.net/2019/03/12/5c8790a187bc7.jpg)

```c
#include <stdio.h>
int main(){
    char t = 0xFF;
    unsigned char u = 0xFF;
    printf("t=%d u=%u\n",t,u);
    printf("t2u=%u u2t=%d\n",(unsigned char)t,(char)u);
}
// t=-1 u=255
// t2u=255 u2t=-1
```
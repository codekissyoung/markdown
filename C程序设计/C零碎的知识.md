# C零碎的一些知识




对齐处理（Alignment）的标准化（包括_Alignas标志符，alignof运算符，aligned_alloc函数以及<stdalign.h>头文件）。

_Noreturn 函数标记，类似于 gcc 的 __attribute__((noreturn))。

_Generic 关键字。

多线程（Multithreading）支持，包括：
_Thread_local存储类型标识符，<threads.h>头文件，里面包含了线程的创建和管理函数。
_Atomic类型修饰符和<stdatomic.h>头文件。

增强的Unicode的支持。基于C Unicode技术报告ISO/IEC TR 19769:2004，增强了对Unicode的支持。包括为UTF-16/UTF-32编码增加了char16_t和char32_t数据类型，提供了包含unicode字符串转换函数的头文件<uchar.h>。

删除了 gets() 函数，使用一个新的更安全的函数gets_s()替代。

增加了边界检查函数接口，定义了新的安全的函数，例如 fopen_s()，strcat_s() 等等。

增加了更多浮点处理宏(宏)。

匿名结构体/联合体支持。这个在gcc早已存在，C11将其引入标准。

静态断言（Static assertions），_Static_assert()，在解释 #if 和 #error 之后被处理。

新的 fopen() 模式，("…x")。类似 POSIX 中的 O_CREAT|O_EXCL，在文件锁中比较常用。

新增 quick_exit() 函数作为第三种终止程序的方式。当 exit()失败时可以做最少的清理工作。

为什么 SQLite 不使用面向对象的语言？
开发人员可能无法想象用“非面向对象”来开发一个像 SQLite 这样复杂的系统会是什么样子。所以 SQLite 为什么不使用 C++ 或者 Java 来开发呢？

1、用 C++ 或 Java 编写的库通常只能由以相同语言编写的应用程序使用。 使用 Haskell 或 Java 编写的应用程序很难调用用 C++ 编写的库。 另一方面，用 C 语言编写的库可以从任何编程语言调用。

2、面向对象是设计模式，而不是编程语言。 你可以使用任何所需语言（包括汇编语言）进行面向对象编程。 某些语言（例如：C++ 或 Java）可以使面向对象更容易，但你仍然可以用像 C 这样的语言进行面向对象的编程。

3、面向对象不是唯一有效的设计模式。对象通常是分解问题的好方法。 但不是唯一的方法，也不总是分解问题的最佳方法。 有时好的旧程序代码更容易编写，更易于维护和理解，并且比面向对象的代码更快。

4、SQLite 进行开发时，Java 还不是一门成熟的语言，C++ 会成熟一点，但当时要找到两种能以 相同方式工作的 C++ 编译器比较困难。相比之下，C 语言是个不错的选择。虽然，这种情况现在有所改善，但为此对 SQLite 重新开发并没有什么好处。

为什么 SQLite 不使用”安全”语言编写？
使用“安全”语言不易发生内存泄露、数组溢出等的安全问题。最近，许多人好像对 Rust 和 Go 这样的“安全”语言感兴趣。但 SQLite 为什么不使用呢？

1、SQLite 出现后的 10 年时间里，所谓的“安全”语言还不存在。虽然 SQLite 可以用 Rust 或者 Go 重新编写，但这样可能会引入更多难以修复的 Bug，进而会影响编码速度。

2、“安全”编程语言解决简单的问题：像内存泄露、数组溢出等。在解决 SQL 计算结果这类的问题上，并不如 C 语言好用。

3、“安全”语言可防止安全漏洞，但 SQLite 并非一个对安全敏感的库。如果应用运行了不受信任的 SQL，那它可能已经存在更大的安全问题，而这是“安全”语言无法修复的问题。

4、一些“安全”语言（如 Go 语言）不喜欢使用 assert()，但这是保持 SQLite 可维护性的重要前提。

5、“安全”语言会插入额外的机器分支来执行其他操作。但在正确的代码中，这些分支并不会被采用。所以机器代码不能 100% 被测试到，可这恰恰是 SQLite 质量检测的重要组成部分。

6、“安全”语言会在内存不足（OOM）时请求终止，而 SQLite 的设计是遇到 OOM 时能重新恢复。目前，还不知道如何利用“安全”语言实现这一点。

7、现有的“安全”语言都比较新，SQLite 开发员对它们的出现表示赞赏，但依然认为 C 语言更适合目前的开发工作。

文章最后表示，SQLite 可能会考虑使用 Rust 重新开发，但不太可能使用 Go 语言，因为它对 assert() 不友好。但其实 Rust 目前的条件并不足以对 SQLite 进行重新开发，它还需要继续发展，详情请查看原文。

## C关键字

- C 标准并未定义指针、整数型（int）、长型（long）为特定的位数目。在32位体系结构下，一般int和long都是32位长；值得注意的是，64位机器下，很多程序设计环境，“int”变量仍然是 32 位宽，“long”和指针是 64 位宽。注意，这里说的只是一般情况下！详细的解释可以看这里。

- union声明的联合数据结构，里面的数据是共享内存的，可以看我的另一篇日志。

- unsigned声明的是一个无符号数据类型，也就是说，如果unsigned int i; 需要注意变量i永远不可能等于复数，除非强制类型转换。

1、auto关键字： 声明变量的生存期为自动，即将不在任何类、结构、枚举、联合和函数中定义的变量视为全局变量，而在函数中定义的变量视为局部变量。不明白？无视他好了，编译器默认的缺省情况下，所有的变量都是auto的。

2、extern关键字： 我们都知道，一个变量或函数，可以在a.c文件中定义，而在b.c文件中使用，这个时候，b.c就需要使用extern关键字来声明这个变量和函数，目的是为了告诉编译器，这个函数在b.c之外，别让我编译不过！

3、register关键字： 这个关键字就很少用到了，但是却十分有用。它的目的是告诉编译器尽量把这个变量放到寄存器中，这样提高存取速度，但是不是能真的放到寄存器中却不一定，毕竟寄存器的数量是有限的。在我们的二进制翻译器中，这个关键字被巧妙的用于线程切换。

4、static关键字： 好吧，我承认我土了，我就是栽在这个关键字上的。static有两种修饰，分别如下：
(1)修饰变量：变量分为全局变量和静态变量，都存储在内存的静态区中。

首先，当static修饰全局变量的时候，该变量的作用域仅被限定在当前文件中，别的文件即使使用extern关键字也无法使用这个变量。

其次，当static修饰局部变量的时候，该变量在哪个函数体中定义，就只能在哪个函数体中使用。也许你会说，这不跟普通局部变量一样么？不一样！别忘了他是被存储在内存的静态区中，所谓的静态区就是全局区，用来存放全局变量和静态变量的，程序不结束，这个区是不会被释放的，所以即使定义静态局部变量的函数结束，改静态局部变量仍然存在，下次访问改函数的时候，这个变量的值仍然是上次的值！举个例子把：
对的，静态局部变量只能被初始化一次，并且值会被保留，使用这个有两个好处，一个是可以计算函数被调用的次数，一个是可以减少函数构建局部变量的开销，自己体会一下把。

(2)修饰函数： 经常见这种形式，但没怎么用过，也就没去想。其实这个作用跟静态全局变量相似，也是限定函数的作用域为本文件。这样作的好处就是不用操心是否会跟别人编写的文件里的函数重名。（我这里栽了一下，太弱了～不甘心阿！）


const关键字： 这是一个很有意思的关键字，他修饰的变量是只读的，不能被修改；很多时候，编译器会将其优化成一个常量。const经常被用来修饰函数的参数，表示不希望这个参数值被函数体内的代码意外的改变。其实，最有意思的是用const修饰一个指针，让我们看下面这个例子：

const int *p;   //p可变，p指向的对象不可变
int const *p;   //同上
int *const p;   //p不可变，p指向的对象可变
const int *const p; //p和p指向的对象都不可变
这些各表示什么呢？注释里面给出了答案！是不是很不好记？我们只需要记得，const修饰的是*p的时候，p指向的内容不可变；const修饰的是p的时候，p就不可变！

sizeof关键字：很多人也许会大吃一斤，我类个去，sizeof居然是关键字？（高手请无视这里，我当初就是这种表现）。不错，sizeof确实是关键字，而不是库函数！所以，如果编译时得不到一个数组的大小，那么就不能使用sizeof关键字来获取改数组的大小！

typedef关键字： typedef说白了就是给一个已知的类型起一个外号。让我们考虑一个问题：

#define PCHAR char*
typedef char* pchar;
这两个语句都是给char*类型起一个别名，那么哪个比较好呢？ 要想知道答案，看下面：

PCHAR p1, p2;
pchar p3, p4;
看代码的意思，我们是想将p1,p2,p3,p4都赋成char*类型的，但是，事实是如此么？p2是么？

注意，p2并没有预期成为一个char*类型，因为define会在预编译阶段展开，所以语句1就相当于 char* p1, p2；而在这条语句下，p2不是一个指针，而是一个char类型的！这个错误经常会被忽略，所以一定要注意！

volatile关键字： 也许你见过这个关键字，但一般你都没有用过。哈哈，我用过！这个关键字表示改变量的值可能在外部被改变，编译器在用到这个变量时不能过度的优化，必须每次都重新从内存中读取这个变量的值，而不是将其优化在寄存器中。这个可以用来防止编译器优化产生的内存屏障
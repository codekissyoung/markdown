# 微信小程序面向对象开发教程

## 1. 基础概念与环境特点

### 微信小程序JS运行环境

- **JavaScript引擎**: V8引擎（Android）、JavaScriptCore（iOS）
- **ES6支持**: 完整支持ES6+ 语法，自动Babel编译
- **模块系统**: CommonJS（推荐）或ES6 Module
- **限制**: 无DOM、无BOM、不支持`eval`和`new Function`

## 2. 类的定义与使用

### 基础类定义
```javascript
// utils/BaseService.js
class BaseService {
  constructor(config = {}) {
    this.config = config;
    this.initialized = false;
  }
  
  // 初始化方法
  init() {
    this.initialized = true;
    return this;
  }
  
  // 静态方法
  static create(config) {
    return new this(config).init();
  }
  
  // 原型方法
  log(message) {
    console.log(`[${this.constructor.name}] ${message}`);
  }
}
module.exports = BaseService;
```

### 属性访问器（Getter/Setter）
```javascript
class UserService extends BaseService {
  constructor() {
    super();
    this._user = null;
    this._isLoggedIn = false;
  }
  
  // Getter - 计算属性
  get currentUser() {
    return this._user || this.getDefaultUser();
  }
  
  // Setter - 数据验证
  set currentUser(user) {
    if (!user || typeof user !== 'object') {
      throw new Error('Invalid user object');
    }
    this._user = user;
    this._isLoggedIn = true;
  }
  
  // 只读属性
  get isLoggedIn() {
    return this._isLoggedIn;
  }
  
  getDefaultUser() {
    return { name: '游客', avatar: '/images/default-avatar.png' };
  }
}
```

## 3. 继承与多态

### 经典继承模式
```javascript
// services/ApiService.js
const BaseService = require('../utils/BaseService');

class ApiService extends BaseService {
  constructor(baseURL) {
    super({ baseURL });
    this.baseURL = baseURL;
    this.headers = {
      'Content-Type': 'application/json'
    };
  }
  
  // 重写父类方法
  init() {
    super.init(); // 调用父类方法
    this.log('API Service ready');
    return this;
  }
  
  // 通用请求方法
  async request(url, options = {}) {
    const config = {
      url: `${this.baseURL}${url}`,
      method: 'GET',
      header: this.headers,
      ...options
    };
    
    return new Promise((resolve, reject) => {
      wx.request({
        ...config,
        success: (res) => {
          if (res.statusCode === 200) {
            resolve(this.handleResponse(res.data));
          } else {
            reject(new Error(`HTTP ${res.statusCode}`));
          }
        },
        fail: reject
      });
    });
  }
  
  // 抽象方法 - 子类必须实现
  handleResponse(data) {
    throw new Error('handleResponse must be implemented by subclass');
  }
}

// services/GameApiService.js
class GameApiService extends ApiService {
  constructor() {
    super('https://xdjsq.codekissyoung.com/api');
  }
  
  // 实现父类抽象方法
  handleResponse(data) {
    // 业务特定的响应处理
    if (data.success) {
      return data.data;
    }
    throw new Error(data.message || 'API Error');
  }
  
  // 游戏相关API
  async createRoom(roomData) {
    return this.request('/rooms', {
      method: 'POST',
      data: roomData
    });
  }
  
  async joinRoom(roomId, playerId) {
    return this.request(`/rooms/${roomId}/join`, {
      method: 'POST',
      data: { playerId }
    });
  }
}

module.exports = GameApiService;
```

### 混入（Mixin）模式
```javascript
// mixins/EventMixin.js
const EventMixin = {
  // 事件监听器存储
  _listeners: {},
  
  // 绑定事件
  on(event, callback) {
    if (!this._listeners[event]) {
      this._listeners[event] = [];
    }
    this._listeners[event].push(callback);
    return this; // 支持链式调用
  },
  
  // 触发事件
  emit(event, ...args) {
    const listeners = this._listeners[event];
    if (listeners) {
      listeners.forEach(callback => callback.apply(this, args));
    }
    return this;
  },
  
  // 移除事件监听
  off(event, callback) {
    if (!callback) {
      delete this._listeners[event];
    } else {
      const listeners = this._listeners[event];
      if (listeners) {
        const index = listeners.indexOf(callback);
        if (index > -1) {
          listeners.splice(index, 1);
        }
      }
    }
    return this;
  }
};

// 使用混入
class GameRoom {
  constructor(id) {
    this.id = id;
    this.players = [];
    
    // 混入事件功能
    Object.assign(this, EventMixin);
    this._listeners = {}; // 初始化事件存储
  }
  
  addPlayer(player) {
    this.players.push(player);
    this.emit('playerJoined', player); // 触发事件
  }
  
  removePlayer(playerId) {
    const index = this.players.findIndex(p => p.id === playerId);
    if (index > -1) {
      const player = this.players.splice(index, 1)[0];
      this.emit('playerLeft', player);
    }
  }
}

// 使用示例
const room = new GameRoom('room123');
room.on('playerJoined', (player) => {
  console.log(`玩家 ${player.name} 加入了房间`);
});
```

## 4. 设计模式在小程序中的应用

### 单例模式 - 全局服务管理
```javascript
// utils/ServiceManager.js
class ServiceManager {
  constructor() {
    this.services = new Map();
  }
  
  // 注册服务
  register(name, ServiceClass, ...args) {
    if (this.services.has(name)) {
      console.warn(`Service ${name} already registered`);
      return;
    }
    
    const instance = new ServiceClass(...args);
    this.services.set(name, instance);
    return instance;
  }
  
  // 获取服务实例
  get(name) {
    const service = this.services.get(name);
    if (!service) {
      throw new Error(`Service ${name} not found`);
    }
    return service;
  }
  
  // 检查服务是否存在
  has(name) {
    return this.services.has(name);
  }
  
  // 销毁服务
  destroy(name) {
    const service = this.services.get(name);
    if (service && typeof service.destroy === 'function') {
      service.destroy();
    }
    return this.services.delete(name);
  }
}

// 单例实例
const serviceManager = new ServiceManager();

// app.js中初始化
const GameApiService = require('./services/GameApiService');
const StorageService = require('./services/StorageService');

App({
  onLaunch() {
    // 注册核心服务
    serviceManager.register('api', GameApiService);
    serviceManager.register('storage', StorageService);
    
    // 挂载到全局
    this.services = serviceManager;
  }
});

// 页面中使用
const app = getApp();
const apiService = app.services.get('api');
```

### 观察者模式 - 数据响应式更新
```javascript
// utils/Observable.js
class Observable {
  constructor(initialData = {}) {
    this._data = { ...initialData };
    this._observers = new Map();
  }
  
  // 订阅数据变化
  subscribe(key, observer) {
    if (!this._observers.has(key)) {
      this._observers.set(key, []);
    }
    this._observers.get(key).push(observer);
    
    // 返回取消订阅函数
    return () => this.unsubscribe(key, observer);
  }
  
  // 取消订阅
  unsubscribe(key, observer) {
    const observers = this._observers.get(key);
    if (observers) {
      const index = observers.indexOf(observer);
      if (index > -1) {
        observers.splice(index, 1);
      }
    }
  }
  
  // 设置数据
  set(key, value) {
    const oldValue = this._data[key];
    this._data[key] = value;
    
    // 通知观察者
    this._notify(key, value, oldValue);
  }
  
  // 获取数据
  get(key) {
    return this._data[key];
  }
  
  // 通知观察者
  _notify(key, newValue, oldValue) {
    const observers = this._observers.get(key);
    if (observers) {
      observers.forEach(observer => {
        try {
          observer(newValue, oldValue, key);
        } catch (error) {
          console.error('Observer error:', error);
        }
      });
    }
  }
}

// services/RoomService.js
class RoomService extends Observable {
  constructor() {
    super({
      roomInfo: null,
      players: [],
      currentUser: null
    });
  }
  
  updateRoomInfo(roomInfo) {
    this.set('roomInfo', roomInfo);
  }
  
  addPlayer(player) {
    const players = [...this.get('players'), player];
    this.set('players', players);
  }
  
  updatePlayerChips(playerId, chips) {
    const players = this.get('players').map(p => 
      p.id === playerId ? { ...p, chips } : p
    );
    this.set('players', players);
  }
}

// 页面中使用
Page({
  onLoad() {
    const roomService = getApp().services.get('room');
    
    // 订阅玩家数据变化
    this.unsubscribePlayers = roomService.subscribe('players', (players) => {
      this.setData({ players });
    });
    
    // 订阅房间信息变化
    this.unsubscribeRoom = roomService.subscribe('roomInfo', (roomInfo) => {
      this.setData({ roomInfo });
    });
  },
  
  onUnload() {
    // 取消订阅
    this.unsubscribePlayers && this.unsubscribePlayers();
    this.unsubscribeRoom && this.unsubscribeRoom();
  }
});
```

### 策略模式 - AI决策系统
```javascript
// strategies/AIStrategy.js
class AIStrategy {
  // 抽象策略接口
  makeDecision(gameState, playerState) {
    throw new Error('makeDecision must be implemented');
  }
  
  // 通用辅助方法
  calculateHandStrength(cards) {
    // 手牌强度计算逻辑
    return 0.5; // 0-1范围
  }
}

// strategies/ConservativeStrategy.js
class ConservativeStrategy extends AIStrategy {
  makeDecision(gameState, playerState) {
    const handStrength = this.calculateHandStrength(playerState.cards);
    
    if (handStrength > 0.7) {
      return { action: 'raise', amount: gameState.minBet * 2 };
    } else if (handStrength > 0.4) {
      return { action: 'call', amount: gameState.currentBet };
    } else {
      return { action: 'fold' };
    }
  }
}

// strategies/AggressiveStrategy.js  
class AggressiveStrategy extends AIStrategy {
  makeDecision(gameState, playerState) {
    const handStrength = this.calculateHandStrength(playerState.cards);
    const bluffChance = Math.random();
    
    if (handStrength > 0.5 || bluffChance < 0.3) {
      return { action: 'raise', amount: gameState.minBet * 3 };
    } else if (handStrength > 0.2) {
      return { action: 'call', amount: gameState.currentBet };
    } else {
      return { action: 'fold' };
    }
  }
}

// services/AIService.js
class AIService {
  constructor() {
    this.strategies = {
      'conservative': new ConservativeStrategy(),
      'aggressive': new AggressiveStrategy()
    };
    this.currentStrategy = 'conservative';
  }
  
  // 设置策略
  setStrategy(strategyName) {
    if (this.strategies[strategyName]) {
      this.currentStrategy = strategyName;
    }
  }
  
  // 执行决策
  makeDecision(gameState, playerState) {
    const strategy = this.strategies[this.currentStrategy];
    return strategy.makeDecision(gameState, playerState);
  }
  
  // 动态切换策略
  adaptStrategy(gameHistory) {
    // 根据游戏历史动态选择策略
    const winRate = this.calculateWinRate(gameHistory);
    if (winRate < 0.3) {
      this.setStrategy('conservative');
    } else if (winRate > 0.7) {
      this.setStrategy('aggressive');
    }
  }
}
```

## 5. 错误处理与调试

### 自定义错误类
```javascript
// errors/GameError.js
class GameError extends Error {
  constructor(message, code, details = {}) {
    super(message);
    this.name = 'GameError';
    this.code = code;
    this.details = details;
    this.timestamp = new Date().toISOString();
  }
  
  // 错误序列化
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      details: this.details,
      timestamp: this.timestamp,
      stack: this.stack
    };
  }
}

// 具体错误类型
class ValidationError extends GameError {
  constructor(field, value, rule) {
    super(`Validation failed for field: ${field}`, 'VALIDATION_ERROR', {
      field, value, rule
    });
    this.name = 'ValidationError';
  }
}

class NetworkError extends GameError {
  constructor(message, statusCode) {
    super(message, 'NETWORK_ERROR', { statusCode });
    this.name = 'NetworkError';
  }
}

module.exports = { GameError, ValidationError, NetworkError };
```

### 错误处理装饰器
```javascript
// utils/decorators.js
function catchErrors(errorHandler) {
  return function(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function(...args) {
      try {
        return await originalMethod.apply(this, args);
      } catch (error) {
        if (typeof errorHandler === 'function') {
          return errorHandler.call(this, error, ...args);
        } else {
          console.error(`Error in ${target.constructor.name}.${propertyKey}:`, error);
          throw error;
        }
      }
    };
    
    return descriptor;
  };
}

// 使用装饰器
class RoomService {
  @catchErrors(function(error, roomId) {
    console.error('Failed to join room:', error);
    wx.showToast({
      title: '加入房间失败',
      icon: 'error'
    });
    return null;
  })
  async joinRoom(roomId) {
    // 可能抛出错误的业务逻辑
    const response = await apiService.joinRoom(roomId);
    return response.data;
  }
}
```

## 6. 性能优化技巧

### 对象池模式
```javascript
// utils/ObjectPool.js
class ObjectPool {
  constructor(createFn, resetFn, maxSize = 100) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    this.maxSize = maxSize;
    this.pool = [];
    this.usedObjects = new Set();
  }
  
  // 获取对象
  acquire() {
    let obj;
    if (this.pool.length > 0) {
      obj = this.pool.pop();
    } else {
      obj = this.createFn();
    }
    
    this.usedObjects.add(obj);
    return obj;
  }
  
  // 释放对象
  release(obj) {
    if (this.usedObjects.has(obj)) {
      this.usedObjects.delete(obj);
      
      if (this.pool.length < this.maxSize) {
        this.resetFn(obj);
        this.pool.push(obj);
      }
    }
  }
  
  // 获取统计信息
  getStats() {
    return {
      poolSize: this.pool.length,
      usedCount: this.usedObjects.size,
      totalCreated: this.pool.length + this.usedObjects.size
    };
  }
}

// 使用示例：扑克牌对象池
const cardPool = new ObjectPool(
  () => ({ suit: '', rank: '', visible: false }), // 创建函数
  (card) => { // 重置函数
    card.suit = '';
    card.rank = '';
    card.visible = false;
  }
);
```

### 内存管理与生命周期
```javascript
// utils/Lifecycle.js
class LifecycleManager {
  constructor() {
    this.instances = new WeakMap();
    this.cleanupTasks = new Map();
  }
  
  // 注册实例
  register(instance, cleanupFn) {
    const id = this.generateId();
    this.instances.set(instance, id);
    this.cleanupTasks.set(id, cleanupFn);
    
    // 自动清理机制
    if (typeof instance.onUnload === 'function') {
      const originalUnload = instance.onUnload;
      instance.onUnload = () => {
        this.cleanup(instance);
        originalUnload.call(instance);
      };
    }
    
    return id;
  }
  
  // 清理资源
  cleanup(instance) {
    const id = this.instances.get(instance);
    if (id) {
      const cleanupFn = this.cleanupTasks.get(id);
      if (cleanupFn) {
        try {
          cleanupFn();
        } catch (error) {
          console.error('Cleanup error:', error);
        }
        this.cleanupTasks.delete(id);
      }
      this.instances.delete(instance);
    }
  }
  
  generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }
}

// 全局生命周期管理器
const lifecycleManager = new LifecycleManager();

// 页面基类
class BasePage {
  constructor() {
    // 自动注册生命周期管理
    lifecycleManager.register(this, () => this.destroy());
    this.timers = [];
    this.subscriptions = [];
  }
  
  // 设置定时器（自动清理）
  setTimeout(callback, delay) {
    const timerId = setTimeout(() => {
      callback();
      this.clearTimer(timerId);
    }, delay);
    this.timers.push(timerId);
    return timerId;
  }
  
  // 清理定时器
  clearTimer(timerId) {
    clearTimeout(timerId);
    const index = this.timers.indexOf(timerId);
    if (index > -1) {
      this.timers.splice(index, 1);
    }
  }
  
  // 订阅事件（自动清理）
  subscribe(observable, callback) {
    const unsubscribe = observable.subscribe(callback);
    this.subscriptions.push(unsubscribe);
    return unsubscribe;
  }
  
  // 销毁资源
  destroy() {
    // 清理定时器
    this.timers.forEach(timerId => clearTimeout(timerId));
    this.timers = [];
    
    // 取消订阅
    this.subscriptions.forEach(unsubscribe => unsubscribe());
    this.subscriptions = [];
  }
}
```

## 7. 实战案例：德州扑克房间系统

### 完整的房间管理类
```javascript
// services/PokerRoomService.js
const { Observable } = require('../utils/Observable');
const { GameError, ValidationError } = require('../errors/GameError');
const EventMixin = require('../mixins/EventMixin');

class PokerRoomService extends Observable {
  constructor() {
    super({
      roomInfo: null,
      players: [],
      gameState: 'waiting', // waiting, playing, settlement
      currentRound: 0,
      pot: 0,
      communityCards: [],
      deck: []
    });
    
    // 混入事件功能
    Object.assign(this, EventMixin);
    this._listeners = {};
    
    // 配置
    this.maxPlayers = 9;
    this.minPlayers = 2;
    this.blinds = { small: 10, big: 20 };
  }
  
  // 创建房间
  async createRoom(roomConfig) {
    this.validateRoomConfig(roomConfig);
    
    try {
      const roomInfo = {
        id: this.generateRoomId(),
        name: roomConfig.name,
        createdAt: new Date(),
        createdBy: roomConfig.creator,
        status: 'active',
        settings: {
          blinds: roomConfig.blinds || this.blinds,
          maxPlayers: roomConfig.maxPlayers || this.maxPlayers
        }
      };
      
      this.set('roomInfo', roomInfo);
      this.emit('roomCreated', roomInfo);
      
      return roomInfo;
    } catch (error) {
      throw new GameError('Failed to create room', 'CREATE_ROOM_ERROR', { roomConfig });
    }
  }
  
  // 加入房间
  async joinRoom(roomId, player) {
    const roomInfo = this.get('roomInfo');
    if (!roomInfo || roomInfo.id !== roomId) {
      throw new GameError('Room not found', 'ROOM_NOT_FOUND', { roomId });
    }
    
    const players = this.get('players');
    
    // 验证玩家是否已在房间
    if (players.some(p => p.id === player.id)) {
      throw new GameError('Player already in room', 'PLAYER_ALREADY_EXISTS', { playerId: player.id });
    }
    
    // 验证房间是否已满
    if (players.length >= roomInfo.settings.maxPlayers) {
      throw new GameError('Room is full', 'ROOM_FULL', { 
        current: players.length, 
        max: roomInfo.settings.maxPlayers 
      });
    }
    
    // 添加玩家
    const newPlayer = {
      ...player,
      chips: 1000, // 初始筹码
      status: 'active',
      position: players.length,
      joinedAt: new Date()
    };
    
    const updatedPlayers = [...players, newPlayer];
    this.set('players', updatedPlayers);
    this.emit('playerJoined', newPlayer);
    
    return newPlayer;
  }
  
  // 开始游戏
  startGame() {
    const players = this.get('players');
    if (players.length < this.minPlayers) {
      throw new GameError('Not enough players', 'INSUFFICIENT_PLAYERS', {
        current: players.length,
        required: this.minPlayers
      });
    }
    
    // 初始化游戏状态
    this.initializeDeck();
    this.dealCards();
    this.setBlinds();
    
    this.set('gameState', 'playing');
    this.set('currentRound', 1);
    this.emit('gameStarted');
  }
  
  // 发牌
  dealCards() {
    const players = this.get('players');
    const deck = [...this.get('deck')];
    
    // 每个玩家发2张牌
    const updatedPlayers = players.map(player => ({
      ...player,
      cards: [deck.pop(), deck.pop()]
    }));
    
    this.set('players', updatedPlayers);
    this.set('deck', deck);
    this.emit('cardsDealt');
  }
  
  // 玩家行动
  playerAction(playerId, action) {
    const players = this.get('players');
    const playerIndex = players.findIndex(p => p.id === playerId);
    
    if (playerIndex === -1) {
      throw new GameError('Player not found', 'PLAYER_NOT_FOUND', { playerId });
    }
    
    const player = players[playerIndex];
    let updatedPlayer;
    
    switch (action.type) {
      case 'fold':
        updatedPlayer = { ...player, status: 'folded' };
        break;
        
      case 'call':
        const callAmount = this.calculateCallAmount(player);
        if (player.chips < callAmount) {
          throw new GameError('Insufficient chips', 'INSUFFICIENT_CHIPS', {
            required: callAmount,
            available: player.chips
          });
        }
        updatedPlayer = {
          ...player,
          chips: player.chips - callAmount,
          currentBet: (player.currentBet || 0) + callAmount
        };
        break;
        
      case 'raise':
        const raiseAmount = action.amount;
        if (player.chips < raiseAmount) {
          throw new GameError('Insufficient chips for raise', 'INSUFFICIENT_CHIPS', {
            required: raiseAmount,
            available: player.chips
          });
        }
        updatedPlayer = {
          ...player,
          chips: player.chips - raiseAmount,
          currentBet: raiseAmount
        };
        break;
        
      default:
        throw new GameError('Invalid action', 'INVALID_ACTION', { action });
    }
    
    // 更新玩家数组
    const updatedPlayers = [...players];
    updatedPlayers[playerIndex] = updatedPlayer;
    this.set('players', updatedPlayers);
    
    this.emit('playerAction', { player: updatedPlayer, action });
    
    // 检查是否进入下一阶段
    this.checkRoundEnd();
  }
  
  // 工具方法
  validateRoomConfig(config) {
    if (!config.name || typeof config.name !== 'string') {
      throw new ValidationError('name', config.name, 'must be a non-empty string');
    }
    
    if (!config.creator || !config.creator.id) {
      throw new ValidationError('creator', config.creator, 'must have valid creator with id');
    }
  }
  
  generateRoomId() {
    return Math.random().toString(36).substr(2, 6).toUpperCase();
  }
  
  initializeDeck() {
    const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
    const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
    
    const deck = [];
    suits.forEach(suit => {
      ranks.forEach(rank => {
        deck.push({ suit, rank });
      });
    });
    
    // 洗牌
    this.shuffleDeck(deck);
    this.set('deck', deck);
  }
  
  shuffleDeck(deck) {
    for (let i = deck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [deck[i], deck[j]] = [deck[j], deck[i]];
    }
  }
  
  setBlinds() {
    const players = this.get('players');
    const blinds = this.get('roomInfo').settings.blinds;
    
    // 设置小盲和大盲
    if (players.length >= 2) {
      players[0].currentBet = blinds.small;
      players[0].chips -= blinds.small;
      
      players[1].currentBet = blinds.big;
      players[1].chips -= blinds.big;
      
      this.set('players', players);
      this.set('pot', blinds.small + blinds.big);
    }
  }
  
  calculateCallAmount(player) {
    // 计算跟注所需金额的逻辑
    const highestBet = Math.max(...this.get('players').map(p => p.currentBet || 0));
    return Math.max(0, highestBet - (player.currentBet || 0));
  }
  
  checkRoundEnd() {
    const players = this.get('players');
    const activePlayers = players.filter(p => p.status === 'active');
    
    if (activePlayers.length <= 1) {
      this.endRound();
    }
  }
  
  endRound() {
    this.emit('roundEnd');
    // 结算逻辑...
  }
  
  // 获取房间统计
  getRoomStats() {
    const players = this.get('players');
    return {
      totalPlayers: players.length,
      activePlayers: players.filter(p => p.status === 'active').length,
      totalPot: this.get('pot'),
      currentRound: this.get('currentRound'),
      gameState: this.get('gameState')
    };
  }
}

module.exports = PokerRoomService;
```

## 8. 最佳实践总结

### 1. 项目结构组织

```bash
project/
├── services/          # 业务逻辑层
├── utils/            # 工具函数和基类
├── mixins/           # 可复用的功能混入
├── strategies/       # 策略模式实现
├── errors/           # 自定义错误类
├── config/           # 配置文件
└── components/       # UI组件
```

### 2. 命名约定
- **类名**: PascalCase (`UserService`, `GameManager`)
- **方法名**: camelCase (`createRoom`, `joinGame`)
- **常量**: UPPER_SNAKE_CASE (`MAX_PLAYERS`, `API_BASE_URL`)
- **私有属性**: 下划线前缀 (`_data`, `_listeners`)

### 3. 代码组织原则
- **单一职责**: 每个类只负责一个核心功能
- **开闭原则**: 对扩展开放，对修改关闭
- **依赖倒置**: 依赖抽象而非具体实现
- **组合优于继承**: 优先使用组合和混入模式

### 4. 错误处理策略
- **预期错误**: 使用自定义错误类，提供详细上下文
- **意外错误**: 全局错误处理器，记录和上报
- **用户友好**: 将技术错误转换为用户可理解的提示

### 5. 性能优化要点
- **对象复用**: 使用对象池减少GC压力
- **事件管理**: 及时清理事件监听器防止内存泄漏
- **异步操作**: 合理使用Promise和async/await
- **数据结构**: 选择合适的数据结构优化查找和更新

### 6. 调试和测试
```javascript
// 开发环境调试辅助
if (process.env.NODE_ENV === 'development') {
  // 全局错误监听
  App({
    onError(error) {
      console.error('Global error:', error);
      // 开发环境下显示详细错误信息
    }
  });
  // 性能监控
  console.time('service-initialization');
  // ... 服务初始化代码
  console.timeEnd('service-initialization');
}
```

这个教程涵盖了微信小程序环境下JavaScript面向对象开发的核心概念和实战技巧。通过合理使用这些模式和技术，可以构建出结构清晰、易于维护和扩展的小程序应用。
# Go



## 函数


不支持：

- 嵌套定义命名函数
- 同名函数重载
- 默认参数

支持：

- 不定长参数
- 多返回值
- 一等公民 first object class
- 匿名函数
- 闭包

**一等公民 first class object** : 可以在运行期创建、可作为值（参数、返回值、变量）的实体。

> 作为一等公民的函数的局限性：只能与 nil 比较．即便有相同函数类型　`fn1 == fn2`　语句也是错误的，而其他的一等公民（基础类型等）就没这个限制

**闭包**　是引用了外部变量的函数．被引用的外部变量和函数一同存在，即使已经离开了外部环境（出栈），这些外部变量也不会被释放，在闭包中可以继续使用这个外部变量。

> 函数 + 引用到的外部变量 = 闭包

**函数** 是编译期静态的概念，一个函数类型就像结构体一样，可以被实例化，函数本身不存储任何信息，编译后它的一切就被确定了。

**闭包** 是运行期动态的概念，只有在运行时，有了外部环境变量，函数捕捉了这些变量后，才称为“闭包”。

闭包对环境中变量的引用过程也可以被称为　**“捕获”**。捕获有两种类型：
- 可以改变引用的原值叫做　**“引用捕获”**
- 捕获的过程值被复制到闭包中使用叫做　**“复制捕获”**

**程序 = 数据 + 算法**

算法可以表象为函数，将函数附着在数据上，就成了**对象**。

反之呢？

函数既然是一等公民，将数据附着在函数上，就成了**闭包**。

以前可以通过 “传递对象” 完成的功能，现在可以通过 “传递闭包” 完成。并且更加灵活，因为对象的数s据结构，往往提前设计好，而　“闭包”　却可以灵活的捕捉数据。



闭包设计的目的是：在函数间传递共享数据时，不想传参，不想依赖全局变量。是一种隐秘的共享数据的方式。



## 类型



slice map channel interface 也被设计成一种类型，但实际上它们拥有更复杂的存储结构，初始化需要设置一系列属性：指针、长度、hash分布、数据队列等。这些类型创建的变量本身只占少量字节，用于存放指针和长度等属性，真正存储数据的地方都在变量内部指针指向的内存空间。



### 同一类型的判定

基础类型、用户自定义类型，类型名称相同就是同一类型。

有相同声明的未命名类型也被视为同一类型，包括：

- 相同基础类型的 pointer、slice
- 相同基础类型、相同长度的 array
- 相同键值类型的 map
- 相同基础类型、相同方向的 channel
- 相同基础类型、相同字段顺序、相同 tag 的 匿名 struct
- 相同签名（参数、返回值列表相同）的 func
- 相同方法集（方法名、方法签名）的 interface

**只有判定为同一类型，才可以进行赋值！！！**



## Goroutine

不足：没有将 Channel 扩展到多个进程，甚至是不同的机器进程之间，实现真正的分布式。



#### 赋值退化

定义退化成赋值（垃圾特性），很容易带来隐蔽的逻辑错误。

> 在同一作用域，最少有一个新变量被定义，才会发生赋值退化

```go
// eg. 1
x := 100
x, y := 200,"abc" // x 退化为赋值，y是变量定义

// eg. 2
x := 100
{
    x,y := 200,"abc" // 不同作用域，x y 都是新变量定义
}
```



## 工具链

- 单元测试

- 性能测试

- 代码覆盖率

- 数据竞态条件检查

- 调优`pprof`

- 通过环境变量输出运行时监控信息

- 垃圾回收和并发调度跟踪

- 包管理工具（go mod）一般

- 调度器（垃圾）

  

## GC

### 传指针VS传值

对于分配在堆上的内存空间，当指向它的指针为 0 个时，GC 后会被回收。在传参时，指向该内存的指针被复制，相当于会延长该内存空间的存在时间。

传指：将对象分配在堆上的成本 + GC成本

传值：将值复制到函数栈的成本（指令少而快，未必会比指针慢）








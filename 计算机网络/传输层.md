# 传输层

- 负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题
- 协议: TCP 传输控制协议、UDP 用户数据报协议
- 重要设备：网关



TCP ：双方必须先建立链接（三次握手）才可收发数据，内核维护了连接状态、读写缓冲区、定时器等结构。数据传送是基于`字节流`，一端不断的写入，另一端不断的接收。但通信结束时，必须断开链接（四次挥手），释放内核相关结构数据

UDP：无连接，每次发送数据都要指明接收端地址,基于数据报传输数据，每次发送的数据包的长度固定，接收时也必须一次性读取整个数据包（否则数据就被截断）



## TCP 协议

![](https://img.codekissyoung.com/2019/11/04/fdb476ead98dbc1debe1a385bc460cfe.png)

- TCP 负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而 IP 是给因特网的每一台联网设备规定一个地址
- IP 数据包是不可靠的，因为 IP 并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP 数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）
- TCP 是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接
- TCP 提供的是一种可靠的数据流服务，采用“带重传的肯定确认”技术来实现传输的可靠性
- TCP 还采用一种称为 `滑动窗口` 的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度

- `SYN`: synchronize 请求同步包; `ACK`: acknowledge 确认标志包； `FIN`：Finally 结束包
- `LISTEN` 监听状态; `SYN-SEND` 已经发送`SYN`包状态; `SYN-RCVD` 已接受`SYN`包，并且已回复`SYN+ACK`包状态; `ESTABLISED` 链接已经建立,互相可以自由发送数据的状态;

- TCP 连接过程

  - 首先 Client 端发送连接请求报文
  - Server 段接受连接后回复 ACK 报文，并为这次连接分配资源
  - Client 端接收到 ACK 报文后也向 Server 段发生 ACK 报文，并分配资源，这样 TCP 连接就建立了

- TCP 断开过程
  - 假设 Client 端发起中断连接请求，也就是发送`FIN`报文，Client 进入`FIN-WAIT-1`状态
  - Server 端接到`FIN`报文后，知道 Client 端不再发数据了, 但是自己 **可能** 还有数据没发完, 所以先发一个 `ACK` 包给 Client, 告诉它: OK 知道了。Client 端收到`ACK`就进入`FIN-WAIT-2`状态，继续等待 Server 端的`FIN`报文
  - 与此同时, Server 继续发送数据, 发完后, 发送`FIN`包给 Client, 告知 Client: 我已经准备好关闭`Socket`了
  - Client 端收到`FIN`报文后，就知道可以关闭连接了,但是他还是不相信网络，怕 Server 端不知道要关闭，所以发送`ACK`后, 才进入`TIME_WAIT`状态
  - Server 收到`ACK`后，直接关闭`Socket`
  - Client 在`TIME_WAIT`状态等待了 2 分钟后，没收到回复了, 就知道 Server 已经关了，所以自己也就关闭 `Socket` 了, TCP 链接就这样关了

### 为什么要三次挥手？

- 在只有两次“握手”的情形下，假设 Client 想跟 Server 建立连接，但是却因为中途连接请求的数据报丢失了，故 Client 端不得不重新发送一遍；这个时候 Server 端仅收到一个连接请求，因此可以正常的建立连接。
- 但是，有时候 Client 端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下 Server 端将先后收到 2 次请求，并持续等待两个 Client 请求向他发送数据...问题就在这里，Cient 端实际上只有一次请求，而 Server 端却有 2 个响应
- 极端的情况可能由于 Client 端多次重新发送请求数据而导致 Server 端最后建立了 N 多个响应在等待，因而造成极大的资源浪费！所以，“三次握手”很有必要！

### 为什么要四次挥手？

- 试想一下，假如现在你是客户端你想断开跟 Server 的所有连接该怎么做？
- 第一步，你自己先停止向 Server 端发送数据，并等待 Server 的回复。但事情还没有完，虽然你自身不往 Server 发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；
- 故 Server 端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！

## UDP 协议

![](https://img.codekissyoung.com/2019/11/04/8beb1db4cc5929609501c7cbc9c848bb.png)

- UDP 用户数据报协议，是面向无连接的通讯协议，UDP 数据包括目的端口号和源端口号信息
- 由于通讯不需要连接，所以可以实现广播发送。
- UDP 通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。
- UDP 与 TCP 位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP 不被应用于那些使用虚电路的面向连接的服务，UDP 主要用于那些面向查询---应答的服务，例如 NFS。相对于 FTP 或 Telnet，这些服务需要交换的信息量较小。
- 每个 UDP 报文分 UDP 报头和 UDP 数据区两部分。报头由四个 16 位长（2 字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP 报头由 4 个域组成，其中每个域各占用 2 个字节，具体如下：
  - 源端口号；
  - 目标端口号；
  - 数据报长度；
  - 校验值。
- 使用 UDP 协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。
- TCP 与 UDP 的区别：TCP 是面向连接的，可靠的字节流服务；UDP 是面向无连接的，不可靠的数据报服务。

## 端口号

- TCP 和 UDP 都采用 16bit 的端口号来识别应用程序，所有端口号:0 - 65535
- FTP : 21
- Telnet : 23
- TFTP : 69
- `/etc/services`记录了默认的程序的默认端口号
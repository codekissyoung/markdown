# 计算机硬件

## 硬件架构

### 传统兼容机

![image-20220328004826025](http://img.codekissyoung.com/2022/03/28/da67735ca2c6da11f070e626f94ffc94.png)

CMOS是一块芯片，记录计算机硬件信息。BIOS 是可以修改 CMOS 的程序，该程序为写死在硬件上，不可修改。硬件开机，第一个执行的程序便是 BIOS ，然后再是操作系统的引导程序（MBR：主引导记录，GRUB：统一引导加载器），然后是操作系统内核，再是内核上的操作系统。

### 现代兼容机

![image-20220328005444014](http://img.codekissyoung.com/2022/03/28/8956de35c9ee92752678eb5b55963074.png)


## IO端口寻址

在 CPU 和 I/O 适配器之间开始传输数据时，首先需要确定适配器的 I/O 位置，即端口地址。

### 统一编址

是把 I/O 控制器中的端口地址归入存储器寻址地址空间范围内。CPU 访问一个端口的操作与访问内存的操作一样，也使用访问内存的指令。

> CGA 显示卡上显示内存的地址就直接占用了存储器地址空间 0xB800 -- 0xBC00 范围。因此若要让一个字符显示在屏幕上，可以直接使用内存操作指令往这个内存区域执行写操作。

### 独立编址

是把 I/O 控制器和控制卡的寻址空间单独作为一个独立的地址空间对待，称为 I/O 地址空间。每个端口有一个 I/O 地址与之对应，并且使用专门的 I/O 指令来访问端口。

> IBM PC 及其兼容微机主要使用独立编址方式，采用了一个独立的 I/O 地址空间对控制设备中的寄存器进行寻址和访问。使用 ISA 总线结构的传统 PC 机其 I/O 地址空间范围是 0x000 -- 0x3FF，有 1024 个 I/O 端口地址可供使用。

对于使用 EISA 或 PCI 等总线结构的现代 PC 机，有 64KB 的 I/O 地址空间可供使用。在普通 Linux 系统下通过查看看/proc/ioports 文件可以得到相关控制器或设置使用的 I/O 地址范围.

## IO访问控制

在 CPU 和 I/O 之间传输数据时，一般可以使用程序循环查询、中断处理和 DMA 传输方式。

### 程序循环查询

循环查询方式是指 CPU 通过在程序中循环查询指定设备控制器中的状态来判断是否可以与设备进行数据交换。这种方式不需要过多硬件支持，使用和编程都比较简单，但是特别耗费 CPU 宝贵时间。因此在 Linux 操作系统中，只有在设备或控制器能够立刻返回信息时才会在很少的几个地方采用这种方式。

### 中断处理控制

需要有中断控制器的支持。在这种控制方式下，只有当 I/O 设备通过中断向 CPU 提出处理请求时，CPU 才会暂时中断当前执行的程序转而去执行相应的 I/O 中断处理服务过程。当执行完该中断处理服务过程后，CPU 又会继续执行刚才被中断的程序。在 I/O 控制器或设备发出中断请求时，CPU通过使用中断向量表（或中断描述符表）来寻址相应的中断处理服务过程的入口地址。因此采用中断控制方式时需要首先设置好中断向量表，并编制好相应的中断处理服务过程。Linux 操作系统中大多数设备 I/O 控制都采用中断处理方式。

### DMA

直接存储器访问 DMA（Direct Memory Access）方式用于 I/O 设备与系统内存之间进行批量数据传送，整个操作过程需要使用专门的 DMA 控制器来进行而无需 CPU 插手。由于在传输过程中无须软件介入，因此操作效率很高。在 Linux 操作系统中，软盘驱动程序使用中断和 DMA 方式配合来实现数据的传输工作。

## BIOS启动

### BIOS开机自检测

BIOS 程序主要用于计算机开机时执行系统各部分的自检，建立起操作系统需要的中断向量表、硬盘参数表。并且把处理器和系统其余部分初始化到一个已知状态，而且还为 DOS 等操作系统提供硬件设备接口服务。但是由于 BIOS 提供的这些服务不具备可重入性（即其中程序不可并发运行），并且从访问效率方面考虑，因此除了在初始化时会利用 BIOS 提供一些系统参数以外，Linux 操作系统在运行时并不使用 BIOS 中的功能。

当计算机系统上电开机或者按了机箱上的复位按钮时，CPU会自动把代码段寄存器CS设置为0xF000，
其段基地址则被设置为 0xFFFF0000，段长度设置为 64KB。而 IP 被设置为 0xFFF0，因此此时 CPU 代码指
针指向 0xFFFFFFF0 处，即 4G 空间最后一个 64K 的最后 16 字节处。由上图可知，这里正是系统 ROM BIOS
存放的位置。并且 BIOS 会在这里存放一条跳转指令 JMP 跳转到 BIOS 代码中 64KB 范围内的某一条指令
开始执行。

由于目前 PC/AT 微机中 BIOS 容量大多有 1MB 到 2MB，并存储在闪存（Flash Memory）ROM中，因此为了能够执行或访问 BIOS 中超过 64KB 范围而又远远不在 0--1M 地址空间中的其他 BIOS 代码
或数据，BIOS 程序会首先使用 32 位访问方式把数据段寄存器的访问范围设置成 4G（而非原来的 64K），
这样 CPU 就可以在 0 到 4G 范围内执行和操作数据。

此后，BIOS 在执行了一些列硬件检测和初始化操作
之后，就会把与原来 PC 机兼容的 64KB BIOS 代码和数据复制到内存低端 1M 末端的 64K 处，然后跳转到
这个地方并让 CPU 真正运行在实地址模式下，见图 2-5 所示。

最后 BIOS 就会从硬盘或其他块设备把操作系统引导程序加载到内存 0x7c00 处，并跳转到这个地方继续执行引导程序。

![image-20220328012335412](http://img.codekissyoung.com/2022/03/28/1480f1a48b10d269aa1a75066a3d7894.png)







当计算机上电初始化时，物理内存被设置成从地址 0 开始的连续区域。

除了地址从 0xA0000-0xFFFFF
（640K 到 1M 共 384K）和 

0xFFFE0000 到 0xFFFFFFFF（4G 处的最后一64K）范围以外的所有内存都可
用作系统内存。这两个特定范围被用于 I/O 设备和 BIOS 程序。

假如我们的计算机中有 16MB 的物理内存，
那么在 Linux 0.1x 系统中：

- 0-640K将被用作存放内核代码和数据。
- 640K-1M 之间的 384K 仍然保留用作图中指明的用途。
- 0xA0000开始的 128K 用作显示内存缓冲区，
- 随后部分用于其他控制卡的 ROM BIOS 或其映射区域
- 0xF0000 到1M 范围用于高端系统 ROM BIOS 的映射区。
- 1M--16M 将被内核用于作为可分配的主内存区。

另外高速缓冲区和内存虚拟盘也会占用内核代码和数据后面的一部分内存区域，该区域通常会跨越 640K -- 1M 的区域。

Linux 内核不使用 BIOS 功能，也不使用 BIOS 设置的中断向量表。

![image-20220328011222477](http://img.codekissyoung.com/2022/03/28/99fad7558982fbdcbf36044a1e43d111.png)



### CMOS 存储器

在 PC/AT 机中，除需要使用内存和 ROM BIOS 以外，还使用只有很少存储容量的（只有 64 或 128 字节）CMOS 存储器来存放计算机的
实时时钟信息和系统硬件配置信息。这部分内存通常和实时时钟芯片（Real Time Chip）做在一块集成块中。CMOS 内存的地址空间在基本内存地址空间之外，需要使用 I/O 指令来访问。



## 开机固件接口标准

功能包括开机自检、启动流程（如何找到引导程序）、给操作系统和引导程序提供系统服务等。

启动方式: 是指如何主板上的固件在开机自检后如何找到引导程序。

### BIOS

Legacy模式：BIOS + MBR　启动。CMOS 是 PC 上的另一个重要的存储器，用于保存 BIOS 的设置结果，CMOS 是 RAM。

1. 开机自检
1. 加载引导程序（MBR中的，通常是bootloader的第一级）
1. 向OS提供抽象的硬件接口

启动方式：

1. BIOS加电自检（Power On Self Test -- POST）。

1. 读取主引导记录（MBR）。BIOS根据CMOS中的设置依次检查启动设备：将相应启动设备的第一个扇区（也就是MBR扇区）读入内存。

1. 1. 检查MBR的结束标志位是否等于55AAH，若不等于则转去尝试其他启动设备，如果没有启动设备满足要求则显示"NO ROM BASIC"然后死机。
   1. 当检测到有启动设备满足要求后，BIOS将控制权交给相应启动设备的MBR。

1. 根据MBR中的引导代码启动[引导程序]。

### UEFI

UEFI模式：UEFI + GPT　启动。架设在系统固件之上的软件接口，用于替代BIOS接口.

1. Pre-EFI初始化模块
1. EFI驱动程序执行环境（DXE）
1. EFI驱动程序
1. 兼容性支持模块（CSM）
1. EFI高层应用
1. GUID磁盘分区表（GPT）

启动方式：

1. Pre-EFI初始化模块运行，自检
1. 加载DXE（EFI驱动程序执行环境），枚举并加载EFI驱动程序（设备ROM或ESP中）
1. 找到ESP中的引导程序，通过其引导操作系统。

## 硬件设备名

在Linux系统中的文件名：

| 设备               | 文件名                                       |
| ------------------ | -------------------------------------------- |
| SCSI / SATA / USB  | /dev/sd[a-p]                                 |
| Virtual/O 虚拟硬盘 | /dev/vd[a-p]　虚拟机内                       |
| 软盘               | /dev/fd[0-7]                                 |
| 鼠标               | /dev/input/mouse[0-15] /dev/mouse /dev/psaux |
| CDROM / DVDROM     | /dev/scd[0-1] /dev/sr[0-1] /dev/cdrom        |
| IDE硬盘            | /dev/hd[a-d]                                 |


## 磁盘分区格式

### MBR

一整块硬盘按 512 Byte 划分为一个一个的 sector　(扇区），编号从 0 开始。

0 号扇区里存储了:

- 开机管理程序(446 Byte)
- 分区表 (64Byte)，存储 4 条记录，每条记录为扇区 [开始编号，结束编号]
- 结束标志 0x55AA (2Byte)

![image-20210305213430777](http://img.codekissyoung.com/2021/03/05/95cea9fb9f2306d6b76127f74f5607ef.png)

所谓的分区，就是设置分区表。

假如硬盘文件名为 /dev/sda ，则划分后的分区名为:

```bash
/dev/sda1
/dev/sda2
/dev/sda3
/dev/sda4
```

由于分区表总大小的限制，顶多能分4个区，普通的叫做 Primary 主分区，最多能有4个。

如果希望能有更多个分区，则需要将其中一个主分区的位置让出来，设置成 Extends　拓展分区（最多只有一个）。拓展分区表里，记录了一个 512 Byte　大小空间的[开始编号，结束编号]，这个空间被称为 EBR (Extended Boot Record)。

EBR 中记录了:

- 一个逻辑分区的[开始编号，结束编号]，作为新的分区
- 下一个 EBR 的[开始编号，结束编号]

![image-20210305213025925](http://img.codekissyoung.com/2021/03/05/a99308c7bb427f57fffad7650accd2a3.png)

### GPT

GUID partition table 使用 LBA (512Byte) 来规划磁盘。

- 第一个 LBA 称为 LBA0，为了兼容MBR，不使用。
- LBA1记录了GPT表头，以及GPT备份所在位置
- LBA2到LBA33是记录表，每个LBA可以写入4条分区记录，每个记录使用64bit记录扇区位置，所以单个分区最大可达到230TB大小，总分区数可以达到128个

![image-20210305225846992](http://img.codekissyoung.com/2021/03/05/ebf20a5d998439c8784380e437f3cc15.png)

## 开机顺序

### CMOS + BIOS + MBR

1. BIOS: 开机主动执行的固件，会读取CMOS

1. MBR: 第一块，内含有 Bootstrap Code，这个代码可以载入其他的 bootloader 来引导操作系统，双系统的实现就是依靠这一点

   2.5 : 开机管理程序bootloader，在这里，可以选择进入哪个系统

1. 指定操作系统的 bootloader

1. 核心文件：操作系统功能个

![image-20210305230545100](http://img.codekissyoung.com/2021/03/05/de5e6855683732a156bc9bdd086e6c6a.png)

### UEFI + GPT

GPT 分区格式虽然优点多，但是BIOS固件只是个16位的程序，根本无法使用GPT分区。所以，人们开发出了UEFI固件，替代了BIOS.

UEFI 强大之处

- C语言开发
- 内置 TCP/IP ，不需要进入操作系统，就可以联网使用
- 图形化能力强
- 可以直接使用硬件驱动程序
- 提供类似操作系统的shell环境
- secure boot 安全机制（这个机制，会验证即将载入的操作系统，所以开启后，有些Linux系统可能无法顺利开机，所以一般建议关闭）

UEFI简直就像是一个低阶的操作系统。

## 网络硬件

### 双绞线

多用于从主机到集线器或交换机的连接

### 光纤

则主要用于交换机间的级联和交换机到路由器间的点到点链路上

### 交换机

交换机为了方便数据传输，通常会存储每个端口所对应的MAC地址，形成一张表。当交换机收到计算机发来的以太帧时，就会查看帧中的源MAC地址，并查找存储的表。如果表中存在该MAC地址，就直接转发数据。如果没有，则将该MAC地址存入该表中。当其他计算机向这个MAC地址发送数据时，可以快速决定向哪个端口发送数据。由于该表不可能是无穷大的，所以当达到一定数量时，将不会储存其他新的MAC地址。再有新的主机发来数据帧时，部分交换机将不再查找对应的端口，而是以广播的形式转发给所有的端口。
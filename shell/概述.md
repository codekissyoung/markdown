# shell可以做什么
- 管理主机的任务有查询登录文件、追踪流量、监控用户使用主机状态、主机各项硬件设备状态、主机软件更新查询
- 追踪和管理系统的重要工作
- 简单入侵检测功能
- 连续命令单一化
- 简易的数据处理
- 跨平台支持与学习历程较短
- Linux启动中，各种服务的自动开启
- 清除过期文件、机器老化、自动化测试等等的无人值守执行
- 软件开发的持续集成，提交代码后，迅速编译、打包、运行测试，给出反馈
- 各种服务器、数据库的维护、备份

# Bash 特征
- 作业控制,包括 `fg` 和 `bg` 命令,以及使用 `CRTL-Z` 停止作业 放入后台
- 大括号扩展,可以产生任意的字符串
- ~ 扩展,指代用户根目录的缩写
- 别名,让你为命令或命令行定义缩写名称
- 命令历史,让你记得以前输入的指令
- 命令行编辑,使用emacs或vi风格
- 键盘绑定,让你设置自定义编辑的键序列
- 集成编程特性,包含几个 UNIX 外部命令的功能,包括 test、expr、getopt、echo 等,使得编程任务能更简洁有效地完成
- 控制结构,特别是select结构,能简单生成菜单
- 新的选项与变量,使得你有更多的途径来定制你的环境
- 一维数组,使得引用与操作数据列表更为简单
- 动态加载built-in命令,自定义命令并加载进shell的功能。

# C 特点
1. 计算机众多语言中，C是最基础、影响面最广的语言。K&R的《The C programming Language》，就定义了新语言的第一个程序学习模式，"Hello, World"
1. 语言编写的软件中，C的贡献是最高的，没有之一。Linux Kernel、Shell，直接用C实现；C++、Python、Java、PHP、ObjectC等等，你我能想到的如今的流行语言，几乎都是C语言实现的（或实现了早期版本，后期版本，有的用C++实现）
1. C简单、易理解、复用性强、移植性高，是常规软件中算法实现的最好选择之一（如果还要更快，可以用CPU相关语言，如Intel IPP，Arm NEON；再快，用FPGA；再快，用专用芯片；再快，花钱买更强的硬件）

# SHELL 特点
- Shell是一门语言，更是一个集成平台，是开发人员工作的基础之一（也许有意无意地被忽略，我们没有意识到）。只要开发人员在，开源世界就在；只要开源世界在，Linux就在；只要Linux在，Shell就在。（练习K&R的《The C programming Language》的习题时，编辑、编译、运行，都在用Shell。
- Shell是一个更深层次的系统入口，通过她你可以进入计算机世界，去探索另一个时空的神秘微妙；其他语言主要是“为用户服务”，对此涉及较少（深入理解计算机，能为用户提供更好的服务）。
- Shell实现功能快，灵活多变，掌握她，你会多一种或若干种设计思想和编程范式，面对问题，可以从容淡定地选择适合的方案。如果是你是开发人员，对于Shell，你可以赞扬她（很显然我属于这一类），也可以贬低她，但你不可能忽略她（其实你可以忽略她，但要承担对应后果）。

# C 与 SHELL 差异
1. 文件差异
    - Shell中，经常听到的是；执行程序，查找文件，删除文件，批量改变文件名，备份文件...列出目录的文件，Shell中只需一条命令(ls)。

    - C中，经常听到的是：字符串长度，整数小数，精确度，循环边界值，执行次数...一个浮点矩阵乘法，C中几个数组、两个for循环搞定。
    
    - Shell的基本粒度在文件级别，特别适合文件系统的操作和改进；C是基本粒度在数据类型级别，特别适合算法层次的实现和应用。

1. 性能差异
    - 系统启动时的调用、文本转换、等待用户响应等，如果给用户的响应在秒级别（假设C就算比Shell快10000倍），或不要用户干巴巴坐等，用户感觉应可接受，或不在乎。
    - 影音播放、大数据传输、实时控制同步XX机器人等，最理想就是没有延迟，快1秒、毫秒、微秒、纳秒，都有它的应用场景。
    - Shell是解释性语言，性能比C低，大多应用场景已能满足要求（以人的主观角度）；对实时响应、实时控制、大数据处理等，还是要用C。
    - 一个现状是，硬件性能越来越强，对软件本身性能，是个福音（但现在应用软件也越做越庞大、越来越好看，消耗的性能也持续增加）。

1. 环境差异
    - Shell中，除了内建命令，大多是运行其他程序。这些程序各自实现一个个小目标，本身是可以独立运行的；在Shell的组织下，共同努力，集成为一个大目标。（我想起了王健林的“小目标”、美国的“联邦分权制”）
    - C中，除了关键字，主要就是调用各种库提供的接口函数。这些接口本身不会独自工作，按错误顺序调用也不工作（可能工作，但结果异常）；各种库的接口之间可能不兼容，因为她们不是按一个个独立小目标来实现的，更多是通用实现。如果使用者能正确、精确调用，效果巨大。
    - Shell中直接运行可执行程序；C中链接库，或通过system(cmd)子进程运行程序（有效获取运行程序的数据，又是一项专业技术活）
    - 从结果看，都达到了目的，没有谁好谁坏之分；从过程看，独立自主的“小目标”成就感更及时。何况，你我实现的，可能只是“小小目标，或者小小小目标”

1. 进程差异
    - Shell中，一不小心就创建了进程。在命令行中，每一次回车的成功执行一个脚本或程序，都创建了至少一个进程。进程之间的通信和数据分享，常规通过退出状态、管道、文件，使用简单，但非常实用。特别强调一下管道（Pipe），这是一个了不起的发明（至少可以和文件系统媲美），数据如水流送入管道，进程像过滤器，对管道中流过的水流进行加工，去除、加入、或转换。如果不创建进程，或进程通信、数据分享复杂，Shell脚本可能没有这么大的影响。
    - C中，创建进程相对复杂；但设计进程间通信的机制、数据共享，就更为复杂；而为什么要用多进程，又是更高层次的复杂问题了。多进程的设计，一直都是真正C程序员的一个生死考虑。实际上，- C 中更常见的是“单进程、多线程”设计，在一个进程内，划分为“多重性格”捣腾。实际中，线程的同步、临界资源、优先级等，对资深程序员往往也是一个高难度考验。
    总的来说
    - Shell中，进程是柴米油盐酱醋茶，实用品，呼之即来，挥之则去；
    - C中，进程是奢侈品，不是什么人都玩得起，多少人在她的小闺蜜“线程”前面，就死翘翘了。

1. 内存差异
    - Shell中，主要是“Shell内部”和“调用独立程序”两类地方要使用内存，Shell内部，内存由Shell解释器管理；调用的独立程序，则由独立程序内部自行管理。不论是脚本，还是程序，一旦执行完毕，内存都由操作系统回收，重新分派。进程Shell用户，不用管理内存。这是一个“使用者角度”的福音（一些编译型语言，也提供用户不管内存的“资源自动回收机制”了，如Java、Python），把内存管理风险，转移到Shell解释器和独立程序中。
    - C中，就是独立程序的一种实现，内存管理逃无可逃。内存的分派、使用，本身并不难，难的是随时都要检查异常，并做好预防。内存对程序来讲，就是空气对人一样，必需、重要、而且好获取，但是大家在陆地上生活久了，都忽略了。看看海洋中潜水员、太空中的宇航员，氧气罐是他们时刻关注，因为关乎于能否继续活着？
    内存是程序运行的必备资源，Shell中，我们把球踢出去，自己不关心；C中，内存管理，是多少英雄成功崛起的“竞技场”，也是无数豪杰殊途同归的“英雄冢”。

1. 编程差异
    - Shell中，变量全部是字符串，数值计算需要特殊语法支持；支持条件if，循环for、while、until，分支break、contine、case等，函数定义，功能和C差不多，但语法有区别；提供简单的数组（能不用不用），甚至还提供了指针用法（千万不要用）！输入输出（I/O）操作简单，“I/O重定向 + 管道”已经成为经典应用。因为经常做文件相关的查询（文件名、文件属性等），并执行后续操作，所以Shell在测试语句写法、字符串操作、文件判断等方面的操作，提供得多快好省。
    - C中，变量为基础数据类型，更多的是数值类型，字符串只是其中一种（也是很强大的一种）；条件、循环、分支、函数定义很常规，有自定义数据结构struct，还包含非常强大的数组、指针，输入输出中规中矩。特别强调是结构体、数组、指针，这是C除了数值运算，还能组织实现Linux这种超大规模代码的基础。虽然上手比较难，但对C专家来说，这些“水土火气”基本元素，就能构成多彩的代码世界。
    编程语言的语法、基本元素，是入门学习的第一步。编程语言有最基本的实现要素，理解这一点后，入门主要是适应撰写的习惯，更重要的是找到最适合的应用场景，使用最适合的工具来完成。

# Linux与Shell
- Linux系统
    1. 最神秘是Kernel，她填补了开源世界最核心的部件，之后开源软件才能自己独立玩了；
    1. 最多彩是DeviceDriver，她满足了创造的欲望，专业、业余的DIYer，都可以为开源软件添砖加瓦了；
    1. 最亲密是Shell，她提供了一个“虫洞”，我们可以通过她，进入神秘多彩的计算机时空，体验高维度生物的行为思想（现实时空，也许就是高维度生物的游戏场所）；
    1. 最暖心是各种Tools，你找到她们，她们就会给你惊喜或沉溺；你找不到，就自己苦逼或幸运吧。

- Shell简介
    1. Shell是一个命令解释器。用户通过Shell，可以使用和控制 Kernel、Device Tools 的资源。

# shell的用武之地
1. 快速实现软件原型
    - 在管理中，我们经常听到类似的话：“方向比速度更重要，选择比努力更重要”。软件工作也一样：先满足正确性，否则性能没有意义（其实快还是有意义的，能很快知道错了）。我们可以通过一个简单但实际例子来比较一下：把若干文件中固定格式的16进制数，转成10进制数另存，好方便人类查看。
    > 1. 打印出来，手工转换，用笔标注 正确性靠转换人保证（我想起一个电视中揭露的游戏“交20押金，从1写到500，全都正确给价值好几百的礼品或现金，错误则没收押金”，有人靠这个能挣钱养家糊口的）。时间基本和字节数成正比（假设转、写1秒1数）
    > 1. 使用C，写个Command程序 需要写源码，实现文件读写、内容按规则读取、字符串数字转换、数字进制转换等功能，然后编译、调试，完成程序后，在命令行调用。正确性靠人设计、通过数据来保证。时间包括写程序、调用文件、执行三部分，主要时间在“写程序”，其次在“调用文件”，“执行时间”最少
    > 1. 使用MFC，写个GUI程序（可以补充其他语言对比）和第2）种类似，只是多了GUI的设计、实现，完成程序后，可以用鼠标操作。时间也类似，只是有“命令行”和“GUI鼠标”的操作时间差异
    > 1. 使用shell，写个脚本 和第2）种相同，只是用脚本实现，不用编译。时间的差异有两点：“写程序”和“写脚本”，“编译程序的执行”和“脚本程序的执行”

    - 策略选择
    > 1. 如果只有100个数，人工方法最靠谱人工，什么写程序都是浮云。但电子信息的特点之一：信息特别多
    > 1. 如果用GUI实现，用得会很爽，鼠标指指点点搞定。开发时间则是最长的，而且一定要有人触发。如果每天都要操作，这个人会觉得枯燥，说不准忘记了。电子信息的特点之二：开发人员的数据处理，比终端用户多得多。这个进制转换的例子，其实就是开发人员的需求（终端用户，也许根本不知道16进制和10进制的区别。“我们连12点和0点都区不了”），他们在程序调用上，并不是电脑白痴，他们不喜欢当“白痴”
    > 1. 用command实现，不开发GUI（不用做GUI，开发很开心，因为美工实际是个艺术活，而不是技术活）时间少，主要时间是调试、逻辑差错时间。可以把执行命令复制下来，要处理就执行一下，方便快捷，但还是要操作。电子信息的特点三，信息随时来；软件开发特点一：调试、差错时间，比编码时间多得多
    > 1. 用脚本实现，没有GUI，代码比c少，直接运行调试。如果定点到，或数据多，可以定时执行，无人值守。完美。
    

1. 自动化使用
    - Linux启动中，各种服务的自动开启
    - 清除过期文件、机器老化、自动化测试等等的无人值守执行
    - 软件开发的持续集成，提交代码后，迅速编译、打包、运行测试，给出反馈
    - 各种服务器、数据库的维护、备份
    > 绝大多数场合，我们都是终端用户（衣食住行用），按黑盒子方式使用；偶尔一个微小的点（工作行业的产品），我们是研发生产人员。有时候，我们没有切换角色和思维，把盒子生产的要求点和标准，想得过于简单。
    
    > 相对终端用户（交互式、黑盒子方式使用，主要关注功能点、性能点、界面、操作流等），研发生产人员更要掌握（制造黑盒需要更多工具，盒子包括很多非用户需求：如快速调试、快速验证、快速发布，系统集成，运行资源监控、批量生产、异常现场信息收集、快速升级）。如果你要加强工作的自动化能力？Shell真的很不错。这是大家对Shell高手，敬仰之情如滔滔江水，连绵不绝的原因。

1. 集成实现更高级功能
    - 当今的人类世界，除了艺术品还是“单兵作战”模式，如哲学思想、绘画、书法、音乐等等（主要工作是单兵，大量的辅助还是被自动化了。像李宗盛这种，唱歌用自己做的吉他，做吉他用自己种的树，少了）；其他工艺品都切换到了“团队作战”模式，如出书、画展、演唱会、做手机、做App产品等等（还是需要单兵英雄，但是大量的工作需要支持）。
    - 而且，“团队作战”的模式，已经切换到“特种部队”这种快速响应模式，通过“少部分外部执行者（前台信息收集、决策） + 资源网络支持（后台数据处理、执行）”。这种模式能粘合、组装，利用已成熟工作的系统资源，集成实现更高级的目标（也可以叫组装、组合能力）。集成能力像胶水、螺丝、铆钉、绳子、包装袋、容器。。。
    - 软件开发中，相对硬件、其他有形产品，更容易集成（也许是“需求爆炸”的愿意之一）。Booch在《面向对象的分析与设计》中写到，软件开发团队的任务，是设计一种假象，对用户掩盖复杂性（专业术语是封装）。当然开发人员，必须承受其背后的复杂度。
    - 软件集成了硬件、固件、结构；应用程序集成了操作系统、驱动、网络；Shell，则为快速实现更高级的应用程序，提供了“特种部队”的集成能力、运行环境。


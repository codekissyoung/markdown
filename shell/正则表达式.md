# 正则表达式
- 它是包含匹配，主要用于文件内容
- 包含匹配的意思是：只要匹配到字符，这一整行都要列出来

# 基本匹配规则
- `^cat` 匹配的是以 c 作为开头第一个字符，接着是一个a,接着是一个t 的行
- `^cat$` 匹配的是以 c 作为开头第一个字符，接着是一个a,接着是一个t,然后结尾的行
- `^$` 匹配的是行开头，然后就是行尾，即空行
- `\<cat\>` 匹配的就是单词`cat`，`\<`表示匹配单词开始位置,`\>`匹配单词结束位置
- `gr[ea]y` 匹配的是 先找到一个g,接着是一个r,接着是一个e或者a,接着是y的行,字符组能且只能匹配一个字符，该字符从字符组里选
- `[0-9a-zA-Z_!.?]` 匹配了一个很大的范围，包括数字，大小写字母以及 _ ? . ！四个字符，在`[]`里面，只有 - 是特殊字符，其他都是普通字符,但是`-`放`[]`开头的话，则是普通字符
- `[^1-6]` 匹配不是 1 到 6 的任意字符
- `.` 匹配任意 单个字符
- `|` 的意思是或，`gr[ea]y`可以使用`gr(e|a)y` 或者 `grey|gray` 来代替
- `^(From|Subject|Date):` 匹配的是，行开头是From 或者Subject或者Date,接着是一个: 。区分`^From|Subject|Date:` 它后面的:只在Date分支里

# 匹配个数
- `colou?r`匹配的是，先找到c,接着是o,接着是l,接着是o,接着是 u? ,接着是r, `u?`表示的是，这里 u 可能有，也可能没有
- `4th|4` 简化为 `4(th)?`,匹配的是，先找到4,然后`(th)?`,即可能接着一个th,也可能什么都不接
- `?` 表示0次或1次匹配，`+`表示1次或多次匹配，`*`表示任意次匹配,当然它们都是量词，修饰前面的匹配字符用的
- `<hr +size *= *[0-9]+ *>` 匹配的是,依次先找到邻着的`<hr`个字符，接着是任意多个空格，再接着是`size`,再接任意个空格，再接着`=`,再接着任意个空格,再接着一个或者多个数字,再接着任意多个空格，再接着`>`
- `<hr( +size *= *[0-9]+)? *>`,使用`()?`将子表达式变成了一个可选项，用以匹配`<hr>` `<hr >`这样的情况

# 反向引用
- 正则在GNU的版本中会支持这一功能,即`()`能够记住它们子表达式匹配到的文本
- 假设这么一个问题: 在一篇文章里要匹配连续出现的两个单词比如`the the`,我们不可能把所有的单词都遍历着匹配一遍,只能采取先匹配到一个单词，然后再测试后面跟着的是不是还是这个单词,`[A-Za-z]+`这个是匹配单词的，`([A-Za-z]+) +\1` 先匹配了一个单词，子表达式记录了这个单词(假设是the),后面接着一个或者多个空格，然后是一个反向引用`\1`,这个反向引用匹配的就是这个单词(the),最后我们再给它加上单词界定符,即`\<([A-Za-z]+) +\1\>`
- `([a-z]+)([0-9]+)\1\2` ，其中`\1`就是引用的第1个子表达式， `\2`引用的就是第二个子表达式
- `egrep`命令是支持反向引用的

# 简记法
```bash
\t 制表符
\n 换行符
\r 回车符
\s 任何空白字符
\S 除 \s 外任何字符
\w 等价[0-9a-zA-Z]
\W 除 \w 外任何字符
\d 等价[0-9]
\D 除 \d 外任何字符
\b 匹配单词起始和结束
```

# 在perl中使用正则表达式
```bash
#!/usr/bin/perl -w

# 计算华氏温度
# 也可以使用 \s 来匹配所有的空白字符: 空格,制表符,换行符，回车符
print "Enter a temperature in (eg 32F , 100 C) : ";
$celsius = <STDIN>;
chomp($celsius); # 去掉末尾换行符
if ( $celsius =~ m/^([+-]?[0-9]+(\.[0-9]*)?)[\t ]*([CFcf])$/ ) {
	$temp = $1; # 使用反向引用取值，一定紧邻着使用的正则表达式
	$type = $3; # 第三个括号匹配的值，反向引用就是 $3
	# print "$1 \n"; print "$3 \n"; # 调试
	if( $type =~ m/^[Cc]$/ ){
		$celsius = $temp;
		$fahrenheit = ($celsius * 9 / 5) + 32;
		print "$celsius C is $fahrenheit F.\n";
	}

	if( $type =~ m/^f$/i ){ # i 是忽略大小写 , g 是全局匹配(而不是匹配第一次), x 表示宽松排列的表达式
		$fahrenheit = $temp;
		$celsius = ($fahrenheit - 32) * 5 / 9;
		print "$fahrenheit F is $celsius C.\n";
	}
} else {
	print "Please Enter a temperature with F or C ! \n";
}

# 用于替换
$templete = "dear =NAME= , i love you ! \n";
print "Enter your name : ";
$your_name = <STDIN>;
chomp($your_name);
$templete =~ s/Dear/Dear/i; # 实现了 将所有不论大小写的 dear ,全部转换成 Dear, /i 对于替换字符是没有影响的
$templete =~ s/=NAME=/$your_name/; # 替换匹配到的文本
print $templete;

# 再来个例子，12.3570000001 要变成 12.357 ,而 37.590830 要变成 37.59
$price = 12.3570000001;
$price2 = 37.5909023;
$price =~ s/(\.\d\d[1-9]?)\d*/$1/;
$price2 =~ s/(\.\d\d[1-9]?)\d*/$1/;
print "price : $price , price2 : $price2 \n";
```

# 直接使用perl命令执行perl文本
```bash
cky@cky-pc:~/workspace/shell/perl_script$ cat test.txt 
sysread dfasdfwerqr sysread
sfasdfff sysread
fffssdsssassss
cky@cky-pc:~/workspace/shell/perl_script$ perl -p -i -e 's/sysread/read/g' test.txt 
# -p 对目标文件的每一行进行查找和替换
# -i 将替换的结果写回到文件
# -e 接perl程序文本
# /g 保证了一行文本中可以进行多次替换
cky@cky-pc:~/workspace/shell/perl_script$ cat test.txt 
read dfasdfwerqr read
sfasdfff read
fffssdsssassss
```




























































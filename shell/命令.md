# Bash命令

- **内建命令** 都是bash自身实现的命令，它们不依靠外部的可执行文件存在只要有bash，这些命令就可以执行典型的内建命令有cd、pwd等
- **外建命令** 作为一个可执行程序放在`$PATH`所包含的目录中的bash在执行这些命令的时候，都会进行fork(),exec()并且wait()就是用标准的打开子进程的方式处理外部命令

## 终端打印

### echo

- 每次调用会在输出后面添加一个换行符
- `echo Hello world !` 输出时，没法输出 `;` 变量
- `echo 'Hello world ${var} !'` 输出时，无法解析变量
- `echo "Hello world ${var} \\!"` 可以解析变量，但是需要转义输出`!`

### printf

- 使用由空格分隔的参数，格式化打印字符串，输出不自动添加换行符,`格式替换符`与c语言一致
- `%-5s` 左对齐 宽度为5的字符串, `%-4.2f` 左对齐 宽度为4 保留2位小数的 浮点数

```bash
#!/bin/bash
printf "%-5s %-10s %-4s\n" No Name Mark
printf "%-5s %-10s %-4.2f\n" 1 code 90.33
printf "%-5s %-10s %-4.2fn" 2 kiss 23.112
printf "%-5s %-10s %-4.2f\n" 3 young 342.3
```

### 彩色输出

- 格式 `\\e[attribute code;text color code;background color codem`
  - Attribute codes: 00=none 01=bold 04=underscore 05=blink 07=reverse 08=concealed
  - Text color codes:30=black 31=red 32=green 33=yellow 34=blue 35=magenta 36=cyan 37=white
  - Background color codes:40=black 41=red 42=green 43=yellow 44=blue 45=magenta 46=cyan 47=white
- `echo` 的 `-e` 选项是必须的，表示接受双引号内的转义序列作为参数
- `\e[0m` 是关闭所有属性，每次设置属性后，可以使用它恢复默认
- 参考 [Bash: Using Colors](http://webhome.csc.uvic.ca/~sae/seng265/fall04/tips/s265s047-tips/bash-using-colors.html)

```bash
#!/bin/bash
echo -e "\e[31m 红色字 \e[0m"  
echo -e "\e[43;34m 黄底蓝字 \e[0m"  
echo -e "\e[4;31m 下划线红字 \e[0m"  
echo -e "\e[5;34m 闪烁 \e[0m"

# 打印全部颜色
for STYLE in 1 3 4 5 7 8; do
  for FG in 30 31 32 33 34 35 36 37; do
    for BG in 40 41 42 43 44 45 46 47; do
      echo -en "\e[${STYLE};${FG};${BG}m";
      echo -n " ${STYLE};${FG};${BG} ";
      echo -en "\e[0m";
    done
    echo ;
  done
done
```

## 环境变量

- `cat /proc/6438/environ | tr '\\0' '\\n'` 查看`6438`进程的环境变量, 由于返回的变量以`name=value`描述，彼此之间用`null`(`\\0`)分隔，所以这里替换下，方便查看

## 重定向

- `command > output.txt 2> error.log < input.txt` input.txt 是command的输入，正常输出output.txt, 错误输出error.log
- `command > output.txt 2>&1 < input.txt` 同上，只是错误输出重定向到了正常输出里面
- `command &> output.txt < input.txt` 上句简写版
- `command &> output.txt < input.txt &`, 最后的 `&` 让命令在后台执行
- `command 2> /dev/null` 忽略命令的错误输出
- `>` 是覆盖写入，`>>` 是追加写入
- 在写入文件的时候，再提供一份相同的数据给后续命令的`stdin` ： `command | tee -a out.txt | wc -l` , 命令输出到out.txt里，同时还复制了一份传入管道给`wc -l`用作输入, `-a` 表示追加写入 out.txt, 没有参数的话是覆盖写入
- `set` 查看当前shell所有变量

## 文件

- **文件类型及其标志** :  - 普通文件  d 目录文件  l 链接文件(软链接和硬链接)  b 块设备文件 c 字符设备文件   s 套接字文件socket   p 命名管道文件pipe

### exec

```bash
exec 3<input.txt    # 使用文件描述符 3 打开input.txt
cat <&3             # 使用文件描述符 3
exec 4>>output.txt  # 用文件描述符 4 打开文件 output.txt, 追加模式
echo "nothing" >&4  # 向文件描述符 4 指向的文件输出数据
```

### 文件权限

```bash
chmod  [-R]  777    /var/home/www           # 改变文件/目录权限 -R是递归
chown  [-R] caokaiyan   /var/home/www       # 改变文件所有者
chown  [-R] caokaiyan:admin   /var/home/www # 同时改变文件所有者和用户组
chgrp  [-R]  admin  /var/home/www           # 改变文件所有组
```

### 常用命令

- [cp 命令的各种碉堡的用法](https://linux.cn/article-2687-1.html)
- [mv命令](https://linux.cn/article-2688-1.html)

```bash
ls  -aldh  /root                  # 显示/root下所有文件
pwd                               # 显示当前目录
touch  test.c                     # 创建一个新文件test.c
mkdir -p    /var/www/advanced     # 递归创建目录
rm    -rf    /mydir               # 强制删除/mydir目录和里面的文件
cp  test.c   /root/test.c         # 复制文件
cp  -r /var/www/abc  /var/www/dcf # 复制目录 -a 是复制文件与原文件一模一样
mv  test.c  /root/test1.c         # 移动文件  (移动和复制都是有改名的效果的)
mv  /var/www/abc/  /root/def/     # 移动目录
more  Myfile                      # 分页查看文件内容，空格：下一页，enter：下一行，q：退出
tail -f debug.log                 # 动态监看日志
```

### 链接

```bash
ln source.txt  /var/source.txt            # 创建硬链接
ln -s  source.txt  /var/source_link.txt   # 创建软连接
```

### bash通配符

```bash
*                     代表任意字符串
?                     代表一个字符
[abcd]                代表从a, b, c, d选字符
[!abcd]               代表除这些字符串之外任意字符
[1-9]                 匹配1到9
[a-z]                 表示a到z
ls my_{finger,toe}s   匹配 my_fingers my_toes
```

### cat 拼接输入以及文件

```bash
cat file1 file2 file3                       # 拼接输出多个文件
echo 'text through stdin' | cat - file.txt  # 将输入stdin和file.txt拼接起来， - 是stdin文本的文件名
cat -s multi_blanks.txt                     # 压缩相邻的空行
cat -n lines.txt                            # 为每一行加上行号后输出
```

## 命令别名

### alias

- `alias`只在当前shell有效，关闭终端就失效了, 可以写在`.bashrc`里，让每次开启shell都生效
- `alias`功能在交互打开的bash中是默认开启的，但是在bash脚本中是默认关闭的; `shopt -s expand_aliases`, 在脚本里启用alias功能
- 别名的安全问题：可以通过 `\\Command` 对命令进行转义，这样可以执行原本的命令，而不是伪装成命令的函数

```bash
# 给命令取别名，`./xxx.sh`运行shell脚本,，alias别名无效，`source`和`.`方式是起有效的，因为是在当前shell运行
alias ls='ls --color=auto';
alias rm='rm() { mv $@ ~/backup;};rm' # 配合函数，使用alias命令,将危险的rm命令，替换成mv命令
```

```bash
break   # 退出for while select until
# 强制执行指定的内建命令,shell命令执行时首先从函数开始，如果自定义了一个与内建命令同名的函数，那么就执行这个函数而非真正的内建命令
builtin cd dir;

cd # 进入目录
command # command命令类似于builtin，也是为了避免调用同名的shell函数，命令包括shell内建命令和环境变量PATH中的命令
continue # for while select until 循环　进行下一次迭代
```

## 终端

### 终端命令行快捷键

```bash
[Tab] 自动补充
[Ctrl] + a 到正在输入的命令行的头部
[Ctrl] + e 到正在输入的命令行的尾部
[Ctrl] + c 终止当前进程
[Ctrl] + k 删除光标后的所有字符
```

### tput

- tput命令将通过 terminfo 数据库对您的终端会话进行初始化和操作。通过使用 tput，您可以更改几项终端功能，如移动或更改光标、更改文本属性，以及清除终端屏幕的特定区域
- UNIX 系统上的 terminfo 数据库用于定义终端和打印机的属性及功能，包括各设备（例如，终端和打印机）的行数和列数以及要发送至该设备的文本的属性。UNIX 中的几个常用程序都依赖 terminfo 数据库提供这些属性以及许多其他内容，其中包括 vi 和 emacs 编辑器以及 curses 和 man 程序

```bash
#!/bin/bash
tput clear      # 清屏
tput sc         # 保存当前光标位置
tput rc         # 恢复光标位置
tput cup 10 13  # 将光标移动到 row col
tput civis      # 光标不可见
tput cnorm      # 光标可见
tput setb 6     # 将背景颜色更改为黄色
tput setf 4     # 将前景颜色更改为红色
tput bold       # 设置文本样式为粗体
tput cols       # 获取终端行数
tput lines      # 获取终端列数
tput longname   # 获取终端名称
tput smul       # 设置下划线的开始
tput rmul       # 设置下划线的结束
tput ed         # 清除当前光标到结尾的所有字符
```

- 一个实现读秒效果的例子

```bash
#!/bin/bash
echo -n "count: "

tput sc     # 保存当前光标所在位置
tput civis  # 光标不可见

count=0
while true;
do
    if [ ${count} -lt 40 ];
    then
        let count++;
        sleep 1;
        tput rc;    # 恢复光标位置
        tput ed;    # 清除当前光标到结尾的所有字符
        echo -n $count;
    else
        exit 0;
    fi
done
```

### stty

- `stty -a` 以容易阅读的方式打印当前的所有配置

```bash
stty -echo      # 设置终端不要回显
read  passwd    # 用户输入密码
stty echo       # 终端恢复回显

stty iuclc     # 禁止大写
stty -iuclc    # 恢复

stty olcuc      # 禁止小写
stty -olcuc     # 恢复

stty size       # 打印出终端的行数和列数

stty eof "string" # 系统默认是Ctrl+D来表示文件的结束，而通过这种方法，可以改变！

stty igncr        # 忽略回车符：开启
stty -igncr       # 恢复
```

## 时间

### date

- `date +%s` 返回时间戳
- `date +%Y_%m_%d_%H_%M_%S` 返回 `年_月_日_时_分_秒`

### sleep

- `sleep 1` 脚本休眠一秒

```bash
```

## 管道与子shell

### 管道

- `ls | cat -n > out.txt` , `|` 将一个命令的输出，作为下一个命令的输入

### 子shell

```bash
#!/bin/bash
cmd_output=$(ls | cat -n)   # 启用子shell 执行 ls | cat -n , 然后将子shell的输出赋值给 cmd_output
cmd_output=`ls | cat -n`    # 等价于上句
cmd_output="$(ls | cat -n)" # " 的使用 保留了 子shell输出中的 空格与换行符
```

### xargs 将输入转化为命令行参数

- 有些命令只能以命令行参数的形式接受收据，而无法通过stdin接受数据流。在这种情况下，我们没法用管道来提供那些只有通过命令行参数才能提供的数据, xargs擅长将标准输入数据转换成命令行参数
- -d 选项，指明定界符, 默认将空格作为定界符,xargs没有指定参数时，默认能将换行符替换成空格, `-0` 将 null 作为界定符
- -n 选项，指明每行最大的参数数量
- -I 指定替换字符串
- 很多文件名中都可能会包含空格符，而xargs很可能会误认为它们是定界符(例如，hell text.txt会被xargs误认为hell和text.txt)
- xargs 不能为多组命令提供参数

#### 基础

```bash
cat xargs.txt
12 22 3 3 56
32 23 45 6

cat xargs.txt  | xargs  # 输出 12 22 3 3 56 32 23 45 6

cat xargs.txt  | xargs -n3
12 22 3
3 56 32
23 45 6

echo "splitXsplitXsplitXsplit" | xargs -d X # 输出 split split split split

echo "splitXsplitXsplitXsplit" | xargs -d X -n2
split split
split split
```

#### 高级用法

```bash
$ cat cecho.sh
#!/bin/bash
echo '处理' $*

$ cecho.sh aaa bbb ccc
处理 aaa bbb ccc

cat args.txt
aaa
bbb
ccc

$ cat args.txt | xargs -n1 cecho.sh
处理 aaa
处理 bbb
处理 ccc

# 将找到的 txt 文件删除
find . -type f -name "*.txt" | xargs -0 rm -f

$ cat args.txt | xargs -I {} cecho.sh -p {} -l
处理 -p aaa -l
处理 -p bbb -l
处理 -p ccc -l

# 将找到的 sh 文件 拷贝到 sh_dir 文件夹中
find . -name '*.sh' | xargs -I {} cp {} sh_dir

# 统计 c 代码行数
find . -type f -name "*.c" | xargs -0 wc -l

# 利用子shell, 下句等价 cat files.txt | xargs -I {} cat {}
cat files.txt | (while read arg;do cat $arg;done)
cmd0 | (cmd1;cmd2;cmd3) | cmd4
```

## 进程

```bash
ps axfu                # 显示了系统所有进程
ps axfj                # 显示了 进程/子进程 之间关系
ps axl                 # 长模式 ，显示了 PPID 谦让值 NI 进程正在等待的资源
pgrep -l ssh           # 查出带有某字符串的进程的进程号
```

## caller

- 将caller 命令放到函数中,将会在stdout 上打印出函数调用者的信息.
- caller 命令也可以返回在一个脚本中被source的另一个脚本的信息.象函数一样,这是一个， "子例程调用",你会发现这个命令在调试的时候特别有用.
- ture一个返回成功(就是返回0)退出码的命令flase一个返回失败(非0)退出码的命令

```bash
#!/bin/bash
# cky.sh
bar(){
  echo 'bar called';
  caller 0 # 显示调用者信息
}
call_function(){
  bar;
}
call_function;
```

```bash
#!/bin/bash
# cky_call.sh
. cky.sh
```

```bash
./cky_call.sh
bar called
15 call_function cky.sh
```

```bash
dirs          # 显示当前目录
disown -h %2  # 将后台作业[Ctrl + z生成的],屏蔽HUB信号
enable 启用
eval
exec 用指定命令替换shell进程
fc 从历史记录中选择一条命令
fg %2 恢复后台作业到前台
getopts
hash 内置hash表，建立到PATH路径下面的路径的直接链接
history 显示命令历史记录
jobs  查看后台作业
kill -n PID 向进程发送信号
let 计算数学表达式
local 在函数中申明一个局部变量，只能在函数中访问到
logout 退出shell登录
popd 从目录栈中删除记录
printf 格式化打印
pushd 向目录栈添加记录
readonly 声明只读变量
set 设置/显示环境变量　和 shell特性
shift 将参数位置前移一位
shopt 打开/关闭shell可选行为的变量值
suspend 暂停shell的执行，直到收到SIGCONT
times 显示累计的用户时间和系统时间
trap 如果收到了指定的系统信号，执行指定的命令
type 查看命令类型
ulimit 给用户指定的资源设置上限
umask 为新建的文件和目录设置默认权限
unalias 删除别名
unset 删除变量
wait 等待指定进程完成，并返回退出状态码
```

## 字符串操作

### tr 替换 去重 删除

```bash
# 去重复
echo aaacccddd | tr -s [a-z]                      # 指定范围去重 acd
echo aaacccddd | tr -s [abc]                      # 指定字母去重 acddd

# 删除
cat file.txt | tr -s ["\n"]                       # 删除多余的空白行
echo 'GNU is       not      UNIX' | tr -s ' '     # 删除多余的空格 GNU is not UNIX
echo "its 10:00 Now" | tr -d "[0-9][:]"           # 删除数字和冒号 its  Now
echo "hello 1 char 2 next 4" | tr -d -c '0-9 \n'  # -c 是求反 删除不在集合里的字符 即1  2  4

# 替换
echo 12345 | tr '0-9' '9876543210'                # 替换是一一对应的 87654
echo 12345 | tr '0-9' '9876543210' | tr '9876543210' '0-9' # 12345
echo "Hello world i love you " | tr [a-z] [A-Z]   # 小写换成大写 HELLO WORLD I LOVE YOU
echo "HELLO GIRL I LOVE YOU" | tr [A-Z] [a-z]     # 大写换成小写 hello girl i love you
echo "its 10:00 Now" | tr -c"[a-z][A-Z][: ]" "-"  # -c 是反转,将不在参数1里的替换成参数2 its --:-- Now-
```

## 文件查找与文件列表

```bash
find                                  # 在当前目录，寻找所有的子目录/文件
find /etc                             # 在/etc 目录，寻找所有的子目录/文件
find /etc -name "*.log"               # 通配符匹配目录名和文件名; -iname是忽略大小写
find /etc ! -name "*.txt"             # ! 取反，表示查找所有不以 .txt 结尾的文件
find /etc -path '*/linux/*'           # 拿整个路径进行匹配,使用的是通配符
find /etc -regex ".*\(\.py | \.sh\)$" # 拿整个路径进行匹配,使用正则表达式匹配, -iregex 让正则表达式忽略大小写

# 遍历深度
find /etc -maxdepth 1 -name 'f*'      # 最大遍历深度，到当前子目录，不再往下遍历
find /etc -mindepth 2 -name 'f*'      # 最小遍历深度，从子目录的子目录开始遍历

# 过滤出指定类型
find /etc -type d                     # 过滤出目录 -type f普通文件 -type l; -type c; -type s套接字 -type FIFO管道

# 过滤出时间范围
# 按天计数 : -atime 最近被访问的时间 -ctime 是最后权限变更 -mtime 是最后内容改变时间
# -amin -mmin -cmin 是以分钟计数的
find /etc -mtime -10                  # 查找10天内修改的文件; +10 就是十天前

# 过滤用户
find /etc -user cky                   # 查找指定用户的文件，-nouser 查找没有所有者的文件

# 过滤大小
find /etc -size -25k                  # 查找小于 25k 的文件; +25k 是大于; 单位 c 字节 k M G
find /etc -size +20k -a -size -50k    # -a 同 && : 找20k到50k之间到文件
find /etc -size -20k -o -size +50k    # -o 同 || : 找到小于20k 或者 大于50k的

# 其他过滤
find /etc -inum 345232                # 通过inode节点查找文件
find /etc -perm 644                   # 查出权限为644的文件

# 对查找到的文件执行操作
find . -type f -name"*.swp" -delete   # 将找到的文件全部删除

# {} 会替换成相应的文件名
find . -name '*.sh' -exec cat {} \;               # 找到 .sh 文件，然后将这些文件作为 cat 的输入
find . -name '*.sh' -exec cp {} copy.sh \;        # 将查询到的所有文件都拷贝到 copy.sh 中
find . -name '*.sh' -exec commond.sh {} \;        # 使用 commond.sh 处理每个匹配到的文件
find . -type f -user root -exec chown cky {} \;   # 将匹配的文件，修改它们用户名为 cky

# find 跳过指定的路径
find . \( -name '.git' -prune \) -o \( -type f \) -print # 跳过 .git 目录
```

## 加密 解密

### md5sum 和 sha1sum 单向散列加密

```bash
md5sum cky.sh > cky.md5 # 将校验值存入文件
md5sum -c cky.md5       # 检验文件是否完整
cky.sh: 成功
```

### md5deep

```bash
sudo apt install hashdeep # 安装
mkdir md5_dir
touch md5_dir/aaa.txt
touch md5_dir/bbb.txt
echo "asdf bb cc" > md5_dir/ccc.txt
md5deep -r1 md5_dir > md5_dir.md5

md5deep -rl md5_dir > md5_dir.md5
cat md5_dir.md5
d41d8cd98f00b204e9800998ecf8427e  md5_dir/aaa.txt
d41d8cd98f00b204e9800998ecf8427e  md5_dir/bbb.txt
ae7a125ed9b9ea27e7d299386c48e816  md5_dir/ccc.txt

md5sum -c md5_dir.md5   # 计算校验和
md5_dir/aaa.txt: 成功
md5_dir/bbb.txt: 成功
md5_dir/ccc.txt: 成功
```

### crypt 加密

```bash
crypt cky951010 < cky.sh > cky_crypt
程序“crypt”尚未安装 您可以使用以下命令安装：
sudo apt install mcrypt
sudo apt-get install mcrypt

crypt cky951010 < cky.sh > cky_crypt # 使用口令给文件内容加密，加密后的文件是密文
crypt cky951010 -d <cky_crypt >cky_crypt_coutput.txt # 解密
```

### gpg 生成签名

```bash
gpg -c cky.sh # 生成签名，采用交互式读取口令
ls |grep gpg
cky.sh.gpg

gpg cky.sh.gpg
gpg: AES 加密过的数据
gpg: 以 1 个密码加密
File 'cky.sh' exists. 是否覆盖？(y/N) y
```

### base64

```bash
base64 cky.sh > cky.sh.base64   # base64 加密
base64 -d cky.sh.base64         # base64 解密
```

## 压缩 解压

```bash
bzip2 -k cky              # 压缩cky文件为.bz2文件，-k 保留源文件
bunzip2 cky.bz2           # 解压文件

gzip cky                  # 压缩cky文件为.gz文件
gzip -d cky.gz            # 解压文件

zip -r src.zip src/       # 递归压缩 src/ 目录下的文件 为 src.zip
unzip src.zip             # 解压

tar -zcvf cky.tar.gz cky  # 归档压缩
tar -zxvf cky.tar.gz      # 解压到当前目录
```

## jobs 程序栈管理

- `[Ctrl] ＋ z` 将当前执行的命令放入后台栈中(入栈)
- `tail -f /etc/bashrc &` 直接丢进后台运行(入栈)
- `jobs` 查看后台栈中运行的程序,最前面的是它的序列号
- `fg` 将放入后台的程序切换回前台(出栈)



## 网络通信命令

`ping    + ip地址/URL`
发送数据包，看看能不能得到包的返回ping    自己机器ip地址：如果能通，说明自己的网络设置是没问题的！
`ping    127.0.0.1(回环地址)` 检测自己机器安装了tip/ip 协议 么
`ping   + 6000    www.baidu.com`
发送 6000    block 大小的一个包，来测试网络连接时延
`ifconfig -a `
查看网卡信息；eth0是第一块网卡  lo 是回环网卡；
`netstat -anp`
监控网络状态，端口号，哪个进程监听的这个端口啊，等等！
`traceroute  +域名/主机 IP `
追踪路由route -n：显示本机路由表
`dig domain`  获取domain的DNS信息
`dig -x host`  逆向查询host
`wget file`  下载file
`wget -c file`  断点续传file


## 查看硬盘分区情况

`fdisk    -l    [/dev/had]`硬盘分区情况
`df    -h`    硬盘分区的使用情况
`du    -sh   /root`    查看`/root`下所有目录大小

## linux环境配置

`Locale`    查看当前语言环境
`LANG=zh_CN.UTF-8`设置当前语言,`LANG` 是环境变量可以使用配置环境变量，而不用去修改对应的配置文件
`env`    列出所有的环境变量
`date`   显示当前时间
`cal`    显示当前日历
`env`    列出所有环境变量和值
`set`    列出所有已经生效的变量

## 挂载命令

- `mount` 直接回车 显示当前已经挂载的盘

```bash
/dev/sda3 on / type ext4 (rw)
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
devpts on /dev/pts type devpts (rw,gid=5,mode=620)
tmpfs on /dev/shm type tmpfs (rw,rootcontext="system_u:object_r:tmpfs_t:s0")
/dev/sda1 on /boot type ext4 (rw)
none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)
```

- `mount -a` 将`/etc/fstab`自动挂载设备再挂载一遍
- `mount [-t] [-o] 设备文件名 挂载点`
- -t 文件系统 ext3 ext4 iso9660
- -o 特殊选项

```bash
# 开机自动挂载
[cky@localhost ~]$ cat /etc/fstab

UUID=a9555e9b-6dbc-446b-b919-3ae2ba3a36c9 /                       ext4    defaults        1 1
UUID=1b581ee5-8dbd-4da0-8ea5-6d69e7936e58 /boot                   ext4    defaults        1 2
UUID=c56751cf-0688-4cdc-9304-749c886af943 swap                    swap    defaults        0 0
tmpfs                   /dev/shm                tmpfs   defaults        0 0
devpts                  /dev/pts                devpts  gid=5,mode=620  0 0
sysfs                   /sys                    sysfs   defaults        0 0
proc                    /proc                   proc    defaults        0 0
```

## 排序 唯一 重复

### sort 排序

- `-n` 按数字大小排序
- `-f` 忽略大小写
- `-b` 忽略排序起始处的空白
- `-g` 转换为浮点数后排序
- `-r` 反转排序方向

```bash
sort file1.txt file2.txt > sorted.txt # 将两个文件里的内容排好序，存入另一个文件
sort -t: -k3 -n /etc/passwd           # -t 以:为分隔符，-k 选择第3列作为排序依据
sort -m sorted1.txt sorted2.txt       # 合并多个已排序文件
du -sh * | sort -nr                   # 按数字大小倒叙排列
```

### wc

- `wc < /etc/passwd` 统计 行数 词数 字节数, `wc -l`统计行数

### uniq 去重

```bash
uniq uniq.txt                   # 去重 连续两条一样的行 即为重复，第二个及以后更多个重复行将被删去
uniq -u uniq.txt                # 只显示唯一的行
uniq -d uniq.txt                # 找出重复的行
uniq -c uniq.txt                # 统计出现行数
uniq -s2 -w2 -c uniq_data.txt   # -s 指定跳过两个字符，-w 指定只对比多少个字符
# -z 给每行添加 \0 终结符; 和 xargs -0 配合使用，使得每行被当做一个参数，而不是被空格隔开的好几个参数
uniq -z file.txt | xargs -0 rm
```

## cut 提取列 :基本被awk替代

- cut只擅长处理 以一个字符间隔 的文本内容

```bash
cut -c 5                # 指定切出第５个字符
who|cut -c 3-5,8        # 指定切出第3到第5个字符,第8个字符
cut -f 列数 -d 分割符 file.txt
grep "/bin/bash" /etc/passwd |grep -v "root" |cut -f 1 -t :
```

## sed 替换

```bash
sed '2d' example # 删除example文件的第二行
sed '2,$d' example # 删除example文件的第二行到末尾所有行
sed '$d' example # 删除example文件的最后一行
sed '/test/'d example # 删除example文件所有包含test的行 
sed 's/test/mytest/g' example # 在整行范围内把test替换为mytest, 如果没有g标记，则只有每行第一个匹配的test被替换成mytest
sed 's/^192.168.0.1/& localhost/' example # &符号表示替换换字符串中被找到的部份所有以192.168.0.1开头的行都会被替换成它自已加 localhost，变成192.168.0.1 localhost
sed -n 's/\(love\)able/\1rs/p' example # love被标记为1，所有loveable会被替换成lovers，而且由于 -n /p ,只有替换的行会被打印出来 
sed 's#10#100#g' example # 不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符表示把所有10替换成100
sed -n '/test/,/check/p' example # 打印两个匹配行之间的所有行
sed -n '5,/^test/p' example # 打印从第五行开始到第一个包含以test开始的行之间的所有行
sed '/test/,/check/s/$/end/' example # 对于模板test和west之间的行，每行的末尾用字符串end替换
```

# grep搜索文本
`grep pattern files`  搜索匹配pattern的内容
`grep -r pattern dir`  递归搜索dir中匹配parttern的内容
`grep -v  file.txt`  输出没匹配到文本的行
`grep -n  file.txt`  显示行号
`grep -E '219|216' data.doc` 匹配带有 219 或者 216的行
`egrep Posix_regexp file.txt` 使用POSIX拓展正则表达式
`px aux |grep ngnix` 搜索匹配到ngnix的行


### 查询某个文件的所有git提交记录详情

```bash
git log mcs_db_install.sql | grep commit | awk '{print "git show " $2}' | sh >> mcs_db_install-git-show-log
```

### 统计某个文件夹下所有.php文件中代码行数

```bash
find ./ -name "*.php"|xargs cat|grep -v ^$|wc -l
```

### 删除windows系统编辑文本产生的不可见字符`^M`

```bash
touch love_tmp.c
sed 's/^M//' $1 > love_tmp.c
mv love_tmp.c $1
```
操作符	说明	举例

`^M` 的输入方法为 `Ctrl + v` 再加上 `Ctrl + m`
`cat -v love.c` 可用来查看一个文件，特殊字符也会显示出来

# stat 查看一个文件的详细情况
```bash
shell git:(master)stat case  
  文件：case
  大小：132       	块：8          IO 块：4096   普通文件
设备：802h/2050d	Inode：17698358    硬链接：2
权限：(0755/-rwxr-xr-x)  Uid：( 1000/     cky)   Gid：( 1000/     cky)
最近访问：2017-06-15 01:36:48.609100884 +0800
最近更改：2017-06-15 01:18:06.482207360 +0800
最近改动：2017-06-15 01:36:48.597098908 +0800
创建时间：-
```

# file 查看文件类型
```bash
 file shell  可执行文本文件
shell: POSIX shell script, ASCII text executable
 file main.c 普通c文件
main.c: C source, UTF-8 Unicode text
 file cky  可执行二进制文件
cky: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=c5e8af665f1e457c8d223d41dd2cdde9a4c8cb25, not stripped
```



# tail
```bash
#  动态显示文件的倒数20行 默认是10行 用于监视日志文件挺好的
tail -n20 -f php_errors.log 
```

# mount
``` bash
shell git:(master)mount  查看系统的挂载情况
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=4005816k,nr_inodes=1001454,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=805652k,mode=755)
/dev/sda2 on / type ext4 (rw,relatime,errors=remount-ro,data=ordered)
```
- `mount -t vfat /dev/sdb1  /media/disk` , 挂载u盘`/dev/sdb1`到 `/media/disk`,并且以`vfat`文件系统格式读取
- `mount -t iso9660 -o loop  MEPIS-KDE4-LIVE-DVD_32.iso   mnt` 直接将一个iso文件挂载到`mnt`路径下面


# umount
- `umount [directory | device]` 卸载已经挂载的设备
- `lsof [directory | device]` 卸载之前看看有没有文件被进程占用，有的话要先关闭该进程


# df

```bash
 df -h # 查看磁盘使用情况
du -sh *
du -lh --max-depth=1
```

## 临时文件与目录

```bash
tempname=`mktemp` # 创建一个临时文件在 /tmp 里，这里的文件在系统重启后会被自动删除
echo $tempname
/tmp/tmp.pRnrAkX65n

tempdir=`mktemp -d` # 创建一个临时目录
echo $tempdir
/tmp/tmp.qjWG3jW1VT
```

## 将文件切成小块

```bash
split -b 2k data.file                     # 给它切成 2k 一个的大小
split -b 3k data.file -d -a 4 splite_file # 指定前缀是splite_file, 编码是 4位整数，如 splite_file0000
split -l 1000 data.file                   # 切成 1000 行的块
```

# dd
```bash
# 生成固定大小填充的文件
cky@cky-pc:~/workspace/shell/dd$ dd if=/dev/zero of=junk.data bs=1M count=1
记录了1+0 的读入
记录了1+0 的写出
1048576 bytes (1.0 MB, 1.0 MiB) copied, 0.00211968 s, 495 MB/s

cky@cky-pc:~/workspace/shell/dd$ ls -lhi
总用量 1.0M
20191053 -rw-r--r-- 1 cky cky 1.0M 7月   2 12:35 junk.data

# if 不指定，默认从stdin读入
# of 不指定，默认输出到stdout
# bs blocksize 块大小
# count 块个数
# 文件大小 = bs x count
```

# comm 比较两个文件
```bash
cky@cky-pc:~/workspace/shell/comm$ cat A.txt 
apple
gold
iron
orange
silver
steel

cky@cky-pc:~/workspace/shell/comm$ cat B.txt 
carrot
cookies
gold
orange

cky@cky-pc:~/workspace/shell/comm$ comm A.txt B.txt # 第1列为A文件 第二列为B文件 第三列为两者相同的行
apple
	carrot
	cookies
		gold
iron
		orange
silver
steel

cky@cky-pc:~/workspace/shell/comm$ comm A.txt B.txt -1 -2 # 不输出第1列，第2列
gold
orange

# 通过改变输出的列来 或取两个文件之间的 并集 ，交集，差集
cky@cky-pc:~/workspace/shell/comm$ comm A.txt B.txt | sed 's/^\t*//' #　并集
apple
carrot
cookies
gold
iron
orange
silver
steel

cky@cky-pc:~/workspace/shell/comm$ comm A.txt B.txt -1 -2 | sed 's/^\t*//' # 交集
gold
orange

cky@cky-pc:~/workspace/shell/comm$ comm A.txt B.txt -1 -3 | sed 's/^\t*//' # B - A
carrot
cookies

cky@cky-pc:~/workspace/shell/comm$ comm A.txt B.txt -2 -3 | sed 's/^\t*//' # A - B
apple
iron
silver
steel
```

# 观察内存状态 cat /proc/meminfo
```bash
blog git:(master)cat /proc/meminfo
MemTotal:        8056516 kB
MemFree:         4403196 kB
MemAvailable:    6264224 kB
Buffers:          381480 kB
Cached:          1689388 kB
SwapCached:            0 kB
Active:          2302344 kB
Inactive:         883236 kB
...
```

# ipcs 查看进程的共享内存 消息队列 信号量
```bash
blog git:(master)ipcs

--------- 消息队列 -----------
键        msqid      拥有者  权限     已用字节数 消息      

------------ 共享内存段 --------------
键        shmid      拥有者  权限     字节     连接数  状态      
0x00000000 98304      cky        600        16777216   2                       
0x00000000 4292609    cky        600        1048576    2          目标       
--------- 信号量数组 -----------
键        semid      拥有者  权限     nsems     
```

# 开启启动服务
- 标准启动运行级别 3
- 开心图形化界面的运行级别 5
- ubuntu 开机启动脚本在 /etc/rcX.d/目录下， X 是运行级别, 标准Linux 在 /etc/inittab 文件中
```bash
ls -alh /etc/rc5.d
总用量 16K
drwxr-xr-x   2 root root 4.0K 5月  28 15:38 .
drwxr-xr-x 147 root root  12K 6月  12 17:07 ..
lrwxrwxrwx   1 root root   15 1月  14 23:39 S01acpid -> ../init.d/acpid
lrwxrwxrwx   1 root root   17 1月  14 23:39 S01anacron -> ../init.d/anacron
lrwxrwxrwx   1 root root   16 1月  14 23:39 S01apport -> ../init.d/apport
lrwxrwxrwx   1 root root   22 1月  14 23:39 S01avahi-daemon -> ../init.d/avahi-daemon
...
```

# 硬件设备管理
- 字符型设备文件，调制解调器，终端
- 块设备文件,硬盘
- 网络设备文件,采用数据包发送和接受数据的设备，比如各种网卡和特殊的回环设备
```bash
cd /dev
/dev ls -alh sda* tty*
                     主设备号 次设备号
brw-rw---- 1 root disk    8,  0 6月  11 14:09 sda  块设备
brw-rw---- 1 root disk    8,  1 6月  11 14:09 sda1
brw-rw---- 1 root disk    8,  2 6月  11 14:09 sda2
brw-rw---- 1 root disk    8,  3 6月  11 14:09 sda3
crw-rw-rw- 1 root tty     5,  0 6月  14 14:24 tty 字符设备
crw--w---- 1 root tty     4,  0 6月  11 14:09 tty0
crw--w---- 1 root tty     4,  1 6月  11 14:09 tty1
...
```

# 终端模拟器
- 哑终端--->Linux控制台--->终端模拟包--->
- 字符集：将二进制字符代码转化成字符发送给显示器显示，ascii ios unicode
- 控制码: 控制光标在显示器上的显示位置，如回车 换行 水平制表符 方向键 翻页键 清空控制台
- 块模式图形:
- 矢量图形:
- 显示缓冲: 1.滚动缓冲 2.替代缓冲
- 色彩:
- 键盘: 终端模拟包需要实现键盘模拟, 中断 ，滚动锁定 ， 重复 ，返回 ， 删除 ，方向键 ，功能键
- terminfo数据库: 是一组文件，标识了各种可以用在linux系统上的终端的特性，常见路径`/usr/share/terminfo` `/etc/terminfo` `/lib/terminfo`

```bash
cd /lib/terminfo/v
v ls
vt100  vt102  vt220  vt52
v infocmp vt100  列出终端定义的功能，以及用来模拟每个功能的控制码
#	Reconstructed via infocmp from file: /lib/terminfo/v/vt100
vt100|vt100-am|dec vt100 (w/advanced video),
	am, mc5i, msgr, xenl, xon,
	cols#80, it#8, lines#24, vt#3,
	acsc=``aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,
...
```

- 查看shell会话使用哪个终端模拟设置
- 虚拟控制台: 现代Linux启动时，会自动创建几个虚拟控制台，它是Linux内存中的终端会话，`Ctrl + Alt + [F1~F8]`来切换各个虚拟控制台
- X Window 终端模拟包: Xterm Konsole Gnome-Terminal

```bash
echo $TERM
xterm-256color   说明终端类型设置为了 terminfo 数据库中的xterm条目
```

## lsof 查看进程调用的文件

```bash
lsof /sbin/init     # 查看某个文件(系统文件)被哪个进程调用
lsof -c httpd       # 查看httpd进程调用了哪些文件(系统文件)
lsof -u root        # 查看该用户的进程调用的文件(系统文件)

COMMAND     PID USER   FD      TYPE DEVICE SIZE/OFF NODE NAME
systemd       1 root  cwd   unknown                      /proc/1/cwd (readlink: Permission denied)
systemd       1 root  rtd   unknown                      /proc/1/root (readlink: Permission denied)
systemd       1 root  txt   unknown                      /proc/1/exe (readlink: Permission denied)
kthreadd      2 root  cwd   unknown                      /proc/2/cwd (readlink: Permission denied)
```

## 查看系统信息

```bash
uptime            # 查看系统平均负载 15:55:30 up  5:25,  1 user,  load average: 0.32, 0.27, 0.21
dmesg             # 内核启动自检信息
cat /proc/cpuinfo # 查看cpu详细信息
free -h           # 查看内存
vmstat 1 3        # 每隔一秒刷新一次输出 总共刷新3次
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b 交换 空闲 缓冲 缓存   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 3918024 125876 2305964    0    0    22    17   70  303  3  1 96  1  0
- in : 每秒被中断的进程次数
- cs : 每秒钟进行的事件切换次数,值越大，代表系统与接口设备的通信越繁忙
- us : 非内核进程消耗cpu运算时间的百分比
- sy : 内核进程消耗cpu运算时间的百分比
- id : 空闲cpu的百分比
- wa : 等待 I/O 所消耗的cpu百分比
- st ：被虚拟机所盗用的cpu占比
```

## yes

`yes "hscripts"`
上述命令将重复的显示hscripts直到按下热键终止它(CTRL+C)
当删除文件需要确认时，不用按键就删除文件:
`yes | rm -i *.txt`
在上述示例中，yes命令与带着rm命令管道运行 通常rm -i命令提示你删除文件, 你必须敲入y（是）或n（不）来删除文件 当与 yes 管道运行时， yes 的默认值将显示yes和所有将被自动删除的文件，因此你不需要对每个txt文件敲入y来删除它
`yes n | rm -i *.txt`
在上述示例中，当 rm -i 确认删除文件的时候，敲入n代表not不删除文件

# updatedb
- 更新内置数据库 `/var/lib/mlocate`
- `locate  host`  基于内置文件数据库查找带有host字符的文件 遵循配置文件规则
```bash
# /etc/updatedb.conf
PRUNE_BIND_MOUNTS_ = "yes" # 开启搜索限制
PRUNEFS = # 搜索时 不搜索的文件系统
PRUNENAMES = # 搜索时 不搜索的文件类型
PRUNEPATHS = # 搜索时 不搜索的文件路径
```

# which  ls
搜索系统命令,定位到`ls`命令的绝对路径；提供命令别名信息

# whereis  ls
搜索系统命令,定位到`ls`命令的绝对路径；提供帮助文档信息

# grep [参数] [正则表达式] [路径|通配符]
- `grep "size" file.txt`   在file.txt中找包含size的行 (使用正则表达式匹配)
- `grep -nr "size" ./` 递归搜索当前目录下的所有文件 ,过滤出含有 `size` 的行，并显示它们的行数
- `-i` 忽略大小写
- `-v` 显示不包含匹配文本的所有行
- `-n` 显示行
- `-r` 递归
- `-c` 只输出匹配行的计数
- `-h` 查询多文件时不显示文件名
- `-l` 查询多文件时只输出包含匹配字符的文件名
- `-s` 不显示不存在或无匹配文本的错误信息

# grep
- `grep [options] pattern [file]`
- `-v` 反向搜索,显示不匹配pattern的
- `-n` 显示行号
- `-c` 统计有多少匹配的行
- `-e` 指定多个pattern
- `-r` 递归
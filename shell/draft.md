# 零碎的知识点

## Unix的诞生

- 1970年Unix诞生
- Unix系将设备当做文件
- Unix系故意不将Shell整合进操作系统
- Unix Shell缺点: 同样的参数`-a`在不同命令程序里含义不一致; 正则表达式在不同命令里用法类似，却又不完全一致
- Posix 标准的制定规范了Shell语言和命令，Shell脚本的可移植性得到保障

## Unix软件工具原则

- 一个命令只做好一件事，比如grep就只用于在文件里搜寻符合条件的行，不会用于算术计算
- 处理文本行，不要处理二进制数据，文本行可读，在不同架构系统中无歧义，与大量Shell命令非常容易结合
- 使用正则表达式，强大的文本处理机制简化命令行，Posix 标准定义了两种: BRE基本类型正则表达式(grep支持); ERE扩展正则表达式(egrep支持)
- 在未指明文件名情况下，默认命令从stdin读入数据，数据写入到stdout,错误输出到stderr;以这样的形式来编写的程序，就是过滤器,配合管道使用

```bash
$ cat > user_num.sh         # cat 重定向到文件，由于没有输入参数，所以 stdin 作为输入了
#!/bin/sh
who > wc -l
^D                          # Ctrl + D 表示 end-of-file
$ chmod +x user_num.sh      # 给脚本赋执行权限
$ ./user_num.sh             # 直接运行脚本
```

- 避免喋喋不休，程序执行正确，不需要提醒用户
- 输出格式与可接受的输入格式保持一致，比如`netpbm`处理`BitMap`图像，读入时是PBM个数，输出时也要以PBM格式写回
- 虽然没有完全符合自己需求的Unix程序，但是尝试组合已有的Unix工具去解决 90% 的工作,剩下10%问题再单独解决，这样可以省大量时间
- 在编写一个解决问题的程序前，先想想这个问题是否是一般性问题的一个特例，如果是先解决这个一般性问题，然后再适配这个特例

## 执行一个脚本

- Shell执行一个程序时，Unix内核会为该程序启动一个新的进程
- 内核约定: 一个文件以`#!`开头时，内核会扫描其后文本，看是否存在可用来执行脚本的解释器的完整路径，此外还会扫描其后文本是否有参数传递给解释器，例如`#!/bin/csh -f`,`#!/bin/awk -f`
- 命令选项的开头是 `-` 后面接一个字母，选项是可有可无的，有可能需要加上参数，如果没有参数可以合并字母，如 `ls -al`
- 长选项 `--` 开头，如 `patch --verbose --backup -p1 < /tmp/xxx.1.2.3.patch`

## Shell识别的三种命令

- **内建命令** : Shell本身所执行的命令，由于其必要性或者为了效率才内建的，比如`cd` `read` `echo`等，这些命令在脚本里调用不会产生新的进程
- **函数** : 在Shell脚本里的函数可以直接作为命令一样使用
- **外部命令** : 在`PATH`里搜寻，不属于Shell本身，执行它们会产生新的 **shell子进程**,Shell等待子进程执行完成返回后才继续执行脚本里的下一条命令，脚本是阻塞执行的

## /dev/null 与 /dev/tty

- `/dev/null`输出到此文件的数据都会被系统丢弃掉，数据黑洞，从`/dev/null`读数据会立即返回文件结束符
- `/dev/tty`是当前会话终端或者是通过网络登录的伪终端，在程序需要读取人工输入时有用

```bash
printf "Enter New Password:"
stty -echo      # 关闭回显
read pass < /dev/tty    # 从终端读入数据到 pass
printf "Enter Again:"
read pass2 < /dev/tty   # 从终端读入数据到 pass2
stty echo       # 恢复回显
```

## shell的字符集 排序规则

- shell脚本里的排序规则(collection order),正则表达式里的 `[字符...]` 的字符范围都跟Unix系统的字符集和排序规则有关

```bash
export LANG=zh_CN.UTF-8   # 默认值
export LC_ALL=zh_CN.UTF-8 # 统一值
local                     # 查看当前字符集和排序规则
local -ck LC_TIME         # 查看当前时间格式
```
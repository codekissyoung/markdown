# linux内核设计与实现

本文是《linux内核设计与实现》一书的笔记。

## 操作系统和内核简介

内核组成

- 响应中断的中断服务程序
- 管理多个进程,分享处理器时间的调度程序
- 负责管理进程地址空间的内存管理程序
- 进程间通信等系统服务程序

内核空间

- 对于提供保护机制的现代操作系统，它的部分内存空间和访问硬件设备的所有权限是需要受到保护的，它们只允许内核访问，这部分空间称为内核空间
- 内核独立于普通的应用程序

用户空间

- 应用程序只在用户空间执行，只能使用内核允许它们使用的系统资源和系统功能，不能直接访问硬件，不能相互访问各自的由内核划分的内存范围

内核空间与用户空间关系

- 内核运行在内核空间，当执行用户程序时，又要切换成用户空间，需要使用到内核功能时，又切换回内核空间
- 应用程序通过`系统调用`来与内核通信
- 应用程序调用库函数(比如 c标准库)，而库函数的实现部分依赖系统调用
- 当一个应用程序执行一条系统调用，我们说`内核正在代其执行命令 完成操作`，也可以认为，应用程序通过`系统调用`在内核空间运行，而内核可以理解为运行于`进程上下文`中

中断机制

- 硬件的体系结构都提供了中断机制
- 当硬件设备想和系统通信时，它发出一个异步的`中断信号`去打断cpu的执行，继而打断内核的执行
- 举例:敲击键盘--->键盘控制器发送`中断信号`--->内核调用该信号对应的`中断处理程序`--->中断被处理--->通知键盘可以继续输入数据
- `中断处理程序`不在进程上下文中运行，它们在一个与所有进程都无关的，专门的中断上下文中运行。这样做的目的是为了`中断处理程序`能在第一时间响应和处理中断请求，然后快速的退出。

处理器所有状态

- 运行于用户空间,执行用户进程
- 运行于内核空间，处于进程上下文，代表某个特定的进程执行
- 运行于内核空间，处于中断上下文，与任何进程无关，处理某个特定的中断

linux内核和传统unix内核比较

- 单内核设计:内核从整体上作为一个单独的大过程来实现,运行在一个单独的地址空间上,内核以单个二进制文件的形式存放于磁盘中.因为所有内核服务都在这样一个大内核地址空间上运行，所以通信可以直接调用函数来实现。linux就是一个单内核设计。
- 微内核设计:内核的功能被划分为多个独立的过程，每个过程叫做一个服务器,所有的服务器都运行在各自独立的地址空间上,所以它们之间的通信不可能像单内核那样直接调用函数来实现，而是通过`消息传递`处理内核通信，消息传递采用的机制有`IPC`(进程间通信),因为`IPC`的开销多于函数调用，会涉及到内核空间与用户空间的上下文切换，所以`消息传递`需要一定的周期。所以在实际实现时，所有服务器都置于内核，运行在内核空间，不允许运行在用户空间，这样可以避免这一开销.Windows NT 和Mac OS X采用这样的设计

- linux单内核设计汲取了微内核设计的精华:模块化设计,动态转载内核模块,抢占式内核,支持内核线程,避免了微内核设计的缺陷,让内核的所有事情都运行在内核空间，直接调用函数，无需消息队列
- linux支持动态加载内核代码
- linux支持对称多处理机制(SMP)
- linux内核可以抢占(preemptive),在内核运行的任务，优先执行。
- linux并不区分线程和其他一般进程，对于linux内核来说，进程都一样，只不过其中的一些共享资源而已
- linux提供具有设备类的面向对象的设备模型，热插拔事件，以及用户空间的设备文件系统(sysfs)

PS: linux内核版本 `2.6.26.1` : 主版本号.从版本号.修订版本号.稳定版本号

github 获取源代码,先fork下linus的linux库，然后`git clone`

```bash
git clone git@github.com:codekissyoung/linux.git
tar xjvf linux.2.26.34.tar.bz2
tar xzvf linux.2.26.34.tar.gz
patch -p1 < ../patch.2.4.2 # 使用补丁

```

内核源码树

```bash
├── arch  // 特定体系结构源代码
├── block // 块设备I/O层
├── certs
├── COPYING // 内核许可证
├── CREDITS // 开发者列表
├── crypto // 加密API
├── Documentation // 内核源码文档
├── drivers // 设备驱动程序
├── firmware // 使用某些驱动程序而需要的设备固件
├── fs // VFS和各种文件系统
├── include // 内核头文件
├── init // 内核引导和初始化
├── ipc // 进程间通信代码
├── Kbuild
├── Kconfig
├── kernel // 像调度程序这样的核心子系统
├── lib // 通用内核函数
├── MAINTAINERS // 维护者列表
├── Makefile
├── mm // 内核管理子系统和VM
├── net // 网络子系统
├── README
├── samples // 示例，示范代码
├── scripts //　编译内核所用的脚本
├── security // linux安全模块
├── sound // 语音子系统
├── tools // 在linux开发中有用的工具
├── usr
└── virt // 虚拟化结构基础
```

配置内核

```bash
make config     # 直接配置
make defconfig  # 使用默认配置

# 使用图形界面工具配置
sudo apt-get install libglade2-dev
make gconfig
```

## 操作系统功能

划分cpu时间片，程序交替使用cpu

内存管理

- 线性地址和虚拟地址
- 内核空间　vs 用户空间
- rm -rf a.txt 运行在用户空间;实际删除文件要访问硬盘,这是内核的功能;用户空间要切换到内核空间

进程管理

- 进程：某个状态下的程序的副本,资源分配的单位,
- 进程的优先级(进程的管理)

驱动硬件

- 驱动是内核级别的,内核包含驱动

安全功能

- 保证进程间不能相互干扰

系统调用system call

- 内核提供给上层应用开发的参考,形式：函数
比如：按一定顺序组合系统调用，就能使用显示屏看视频了

库 lib

- 库是对连续的系统调用的再一次封装,形式：函数
- 静态编译　vs 动态链接库(在内存中共享)
- linux 动态链接库:glibc(提供c程序运行所需要的共用的函数库)

POSIX

- 保证Unix,linux,OSX 等程序兼容性,在unix上开发的软件拿到linux下编译下也能运行
- api : 应用程序编程接口
- abi : application binary interface 在Unix上编译好的程序,拿到linux上能直接运行

发行版

- 避免我们自己编译linux源代码(x86,amd64,powerPC平台),有些公司编译好了给你
- RHEL 5 现在最稳定的一个版本
- LFS: Linux From Scratch (linux　从零开始)　从源代码编译出一个linux

Device Mapper

- DM框架为上层应用提供了丰富的设备映射及IO策略方面的支持
- Docker储存端实现之一使用DM
- 上层通过dmsetup工具或libdevmapper库使用

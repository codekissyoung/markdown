# linux 专有的编程特性

linux 专有的编程特性的笔记。

## linux 专有的编程特性

- epoll 获取文件 I/O 事件通知的一种机制
- inotify 监控文件和目录变化的一种机制
- capabilities 为进程赋予root用户的部分权限的一种机制
- 扩展属性
- i-node标记
- clone() 系统调用
- /proc 文件系统
- 文件I/O 信号 定时器 线程 共享库 进程间通信 socket 的实现细节

## 内存管理

物理内存`(RAM)`采用虚拟内存管理机制管理, 进程与进程之间、进程与内核之间的`RAM`是彼此隔离的;每个进程只将一部分需要执行的代码和数据保留在`RAM`中;而其他数据保存在`磁盘`里，这些数据需要被访问到的时候，再替换到`RAM`中

## 磁盘管理
内核在磁盘之上提供文件系统,允许对文件的创建、获取、更新、删除

## 设备管理
对外设(鼠标、键盘、磁盘、磁盘驱动器)提供了访问它们简化版标准接口，管理多个进程对同一个设备的访问

## 联网
内核以用户进程的名义收发`数据包`，保证该数据包路由至目标系统

#### 应用程序编程接口
提供系统调用，用户程序可以通过这些调用去 **请求** 内核执行各种任务

## 内核态与用户态

- CPU 支持运行在不同的状态: **内核态** 与 **用户态** ,与之对应,**虚拟内存区域** 也划分为 **用户空间** 与 **内核空间**  用户态下,CPU只能访问 **用户空间** ，**内核态** 没有限制

## 进程视角 与 内核视角
#### 进程视角
- 对进程来说 许多事情的发生都无法预期
- 进程不知道 自己 对 CPU 的占用何时 **到期** , 也不知道何时会再次获得 CPU 的使用
- 信号的的传递 和 进程通信事件的触发都由内核负责协调，对进程来说，随时可能发生
- 进程不清楚自己的数据与代码哪部分是驻留在 **RAM** ，哪部分又保存在 **SWAP**
- 进程也不清楚自己访问的文件位于磁盘的什么地方，进程只是通过名称来引用文件而已
- 进程之间彼此也不能直接通信
- 进程本身无法创建出新进程
- 进程也无法 **自行了断**
- 进程也不能与计算机外接的输入与输出设备直接通信

#### 内核视角
- 内核维护了一个数据结构，包含了所有正在运行的进程的信息,随着进程的创建与消亡，数据结构会更新
- 内核维护的底层数据结构可以将 **文件名** 转换为磁盘对应的 **物理位置**
- 内核维护的数据结构，也记录了每个进程的 **虚拟内存** 与 `RAM` 以及 `SWAP` 之间的映射关系
- 进程间的通信也只能够通过内核提供的通信机制来完成
- 进程希望创建新的进程，也需要发送请求给内核，由内核来创建新的进程，终止某进程也是请求内核去终结的
- 内核负责与外设之间的所有直接通信，按需与用户进程交换信息

#### 某些缩略语的真实含义
- `某进程可创建另一个进程` 等价于 **某进程可以请求内核创建另一个进程**
- `某进程可创建管道` 等价于 **某进程可以请求内核开辟一条管道**
- `某进程可将数据写入文件` 等价于 **某进程可以请求内核将内容写入到某文件里去**
- `某进程调用exit() ` 等价于 **某进程向内核请求销毁自己**

## 用户和组

- 内核对每一个用户都有一个标识 **UID**
- 内核出于方便管理的目的，维护了用户组，内核对每一个用户组也有一个标识 **GID**
- 用户可以属于多个用户组
- 超级用户 **UID** 为 0 ,登录名为 `root`

## 单根目录层级 目录 链接 文件

- 略

## 文件 I/O 模型

- I/O 通用性, 同一套系统调用(open read write close) 可以用于所有的文件类型，包括设备文件，由内核将这些调用转化为相应的文件系统操作，或者设备驱动操作
- 就本质而言，内核只提供一种文件类型: 字节流序列
- 没有文件结束符的概念, 读取文件时，如果无数据返回，便会认为抵达文件末尾

#### 文件描述符

- 整数，用于指代打开的文件, `open(文件路径)`调用返回一个文件描述符
- `shell` 启动的进程会 **继承** 3个已经打开的文件描述符, **标准输入 0 ** **标准输出 1** **标准错误 2** ,这 3 个描述符在交互式shell中，一般都指代的终端

## 进程

- 执行程序时，内核将程序代码载入虚拟内存，建立内核记账 **bookkeeping** 数据结构，记录进程的各种信息，比如进程ID UID GID 终止状态等

## 进程内存布局

- Text 代码段 ：程序的指令
- Data 数据段 : 程序内静态变量
- 堆 : 供程序动态分配额外内存使用
- 栈 : 随函数调用，返回而增减的一片内存，用于为局部变量和函数调用链接信息分配存储空间

#### 创建新进程

- 进程通过`fork()`系统调用请求内核创建新进程, 内核收到请求后，复制一份父进程作为子进程的创建基础，所以子进程从父进程处继承了数据段，栈段，以及堆段等内容作为子进程自己的副本，子进程修改这些内容，不会影响到父进程。其中标记为只读的 **Text 代码段** 是父进程与子进程共享的。
- 子进程可调用 `exec()` 系列函数，去销毁从父进程继承来的 **Text 代码段** **数据段** **堆栈** ，然后重新加载一个新的程序来替换它们，从而达到运行一个新的程序的目的

#### 进程 **PID**  和 父进程 **PPID**
用以表示进程

#### 进程终止 和 终止状态
- 终止一个进程有两种方法 1. 进程调用`_exit()`系统调用，请求退出 2. 向进程传递信号, 将其 杀死
- 进程退出或者被杀死后，都会生成`终止状态(非负小整数)`，供父进程的`wait()`系统调用检测

#### 进程的用户 和 用户标识符
- **UID** **GID** : 用来标识进程所属的用户和用户组。新进程会从父进程继承 **UID** 与 **GID**
- **有效用户EUID** **有效组EGID** : 进程在访问受保护的资源的时候会通过这它们来确定访问权限
- 补充组ID : 用于标识进程所属的额外组 , 新进程会从父进程继承 ，登录shell则从系统组文件中获取其 补充组ID

#### 特权进程
`root` 的进程 ，**UID** 为 0

#### Capabilities 能力
Linux 2.2 之后，将`root`的特权分为了一组相互独立的单元，称为`Capabilities` 能力, 通过赋予进程部分能力，使得它既可以执行某些特权操作，又可以防止它执行其他越权的操作

#### init 进程
- 1 号进程, 进程程序为`/sbin/init`, 所有进程之父，不能被杀死，只有关闭系统才能终止该进程
- 它的主要任务就是创建并且监控系统运行所需的一系列进程

#### 守护进程 Daemon
- 略

#### 环境列表
- 每个进程都有一份环境列表，即在进程用户空间中维护的一组环境变量
- 子进程会继承父进程的环境列表(生成一个副本)，父进程可以通过这个机制，向子进程传递信息
- `exec()`替换新程序时，可以继承老程序的环境，也可以重新指定

#### 资源限制
- 每个进程都会消耗打开文件、内存、CPU时间等资源，可以设置消耗这类资源的一个上限
- soft limit 限制了进程可以消耗的资源总量
- hard limit 限制了soft limit 调整上线,用户进程的 hard limit 值能调低 ， 不能调高
- 系统调用 `setrlimit()`调整限制

## 内存映射

- 系统调用 `mmap()` 创建内存映射
- 1. 文件映射: 文件部分区域 映射到 进程的虚拟内存 , 这样对该虚拟内存的操作就会转化为对相应文件区域的操作, 映射页面会按需自动从文件中加载
- 2. 匿名映射: 没有文件与 进程的虚拟内存对应，映射页面的内容会被初始化为 0
- 共享内存实现 1. 两个进程对同一文件的相同部分加以映射
- 共享内存实现 2. fork() 创建的子进程 继承 父进程的映射，从而父进程与子进程共享
- 创建映射传入的标志参数: 标志为私有，则进程对映射内容的修改 对于其他进程是不可见的；标志为共享 则是可见的
- 内存映射用途: 1. 初始化文本段 2. 内存分配(内存内容填充0) 3. 文件I/O(即映射内存I/O) 4. 进程间通信(共享映射通信)


## 进程间通信 以及 同步

- 信号: 用来表示事件的发生
- 管道: 在进程间传递数据
- 套接字: 不同主机上运行的进程之间传递数据
- 文件锁定: 防止其他进程读取或者更新内容, 允许进程对文件的部分区域加以锁定
- 消息队列: 用于在进程间交换数据包
- 信号量: 用于同步进程动作
- 共享内存: 多个进程共享一块内存

## 信号

- 也称为软件中断
- 内核、其他进程、进程自身都可以向进程发送信号
- 发送信号情况: Ctrl + C 、子进程终止、进程设定的定时器到期、进程尝试访问无效的内存地址
- 收到信号的进程采取: 1. 忽略信号 2. 被信号杀死 3. 挂起，等待新信号唤醒

## 线程

- 线程之间通过全局变量来实现数据共享
- 线程共享代码段、数据段和堆，但是每个线程都有属于自己的栈
- 线程API提供条件变量和互斥机制，线程之间也可实现同步 和 互相通信
- 线程可以在多处理器硬件的并行处理中获得支持

## 进程组 和 shell 任务控制
- `ls -l |sort -ksn |less` shell 执行的每个命令都会新开一个进程处理,这些进程都处于一个进程组中，每个进程都有相同的 **进程组标识符** , 也即是进程组中某个进程(称为进程组长)的进程ID

## 会话 控制终端 和 控制进程

- 会话 Session 是多组进程组的集合，会话内所有进程都具有相同的会话标识符
- 会话首进程(Session Leader)是指创建会话的进程,它的进程ID就是会话ID
- 通常登录shell就是会话首进程
- 一个终端只能被一个会话占用,shell就是该终端的控制进程
- 关闭终端，会发送SIGHUP信号给控制进程
- 前台进程组(前台任务): 一个会话只能有一个进程组处于前台
- 后台进程组(后台任务): 会话可以有多个后台进程组, 终端输入`ctrl + z`可将前台进程组挂起成为一个后台进程组

## 日期与时间

- 真实时间: UTC 时间戳
- 进程时间: 进程起来后，占用CPU的时间总量

## B/S 架构

## 实时性

## /proc 文件系统

## 系统调用

- 进程请求内核以自己名义执行某些动作(创建新进程、I/O、通信管道)的机制
- 系统调用将`CPU`由`用户态`切换到`核心态`
- 系统调用的组成是固定的，每个调用由一个数字来标识
- 系统调用可以传入一套参数，允许`用户空间`与`内核空间`相互传递信息
- 用户进程位于用户空间，内核位于系统空间，磁盘只能被内核直接访问。程序要读取磁盘上内容，使用`read()`函数，它的代码在内核中，所以执行权会从用户代码转移到内核代码。
- 当运行内核代码时，CPU工作在超级用户模式，这对应于一些特殊的堆栈和内存环境,必须在系统调用发生时建好。系统调用结束后，CPU又要切换回用户模式，需要把堆栈和内存环境恢复成用户程序运行时状态，这种切换会消耗很多时间。

## 外壳函数

- glibc 封装`系统调用`成 c 函数，称为 wrapper(外壳)函数，外壳函数通过 **栈** 接收参数，并且将将这些参数写入内核规定的寄存器
- 所有系统调用进入内核的方式是相同的，有个特殊的寄存器`%eax`存入系统调用编号，用以区分每个系统调用
- 外壳函数 执行一条 中断指令 `int 0x80` ，将处理器由用户态切换到核心态，并执行系统中断 `0x80` 的中断矢量所指向的代码
- 响应中断 `0x80`, 内核调用 `system_call()` 例程， 
    1. 内核栈中保存寄存器的值 
    2. 检查系统调用编号的有效性 
    3. 索引服务例程的列表，调用对应例程,检查参数的有效性，执行例程任务，将结果状态返回给 system_call() 例程
- 从内核栈中恢复例程的各个寄存器值，将系统调用返回值置于栈中
- 返回至外壳函数，同时将处理器切换回用户态
- 如果系统调用出错，会返回一个负值给外壳函数，C 标准库的外壳函数对该负值 取反，并且将结果拷贝至 全局变量 `errno` , 同时 以 `-1` 作为外壳函数的返回值

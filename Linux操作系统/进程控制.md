# 基本概念

- 每个进程都有一个父进程
- 当父进程调用fork函数创建一个子进程而不调用wait函数时,一个僵尸进程就产生了
- fork这个函数的特别之处在于一次调用，两次返回，一次返回到父进程中，一次返回到子进程中

```c
为了充分的利用资源,系统还对进程区分了不同的状态.将进程分为新建,运行,阻塞,就绪和完成五个状态.
新建表示进程正在被创建
运行是进程正在运行
阻塞是进程正在等待某一个事件发生
就绪是表示系统正在等待CPU来执行命令
完成表示进程已经结束了系统正在回收资源
```

## 进程终止

- main return 等同于调用 `exit( main() )`
- 调用 exit,它会调用各种终止处理程序，然后关闭所有标准IO流
- 调用 _exit 或 _Exit，为进程提供一种无需运行终止处理程序或信号处理程序，直接终止的方法，对标准IO流是否冲洗，取决于实现
- 最后一个线程从其启动例程返回 return，该进程则以终止状态 0 返回
- 最后一个线程调用pthread_exit, 进程以终止状态 0 返回
- 异常终止
  - 调用 abort，产生`SIGABRT`信号，是下一种异常终止的一种特例
  - 接到一个 信号时，信号可由进程自身(比如调用abort函数)、其他进程或者内核产生，例如，进程引用地址空间之外的存储单元，或者除以0内核就会为该进程产生相应的信号
  - 最后一个线程对取消(cancellation)请求做出响应，默认情况下，取消以延迟方式发生，一个线程要求取消另一个线程，若干时间后，目标线程终止。

- 不管进程如何终止，最后都会执行内核中的同一段代码，这段代码为相应的进程关闭所有打开的描述符，释放它所使用的存储器

```c
#include <stdlib.h>
void exit( int status ); // 执行一些清理处理，然后返回内核
void _Exit( int status ); // 立即进入内核
#include <unistd.h>
void _exit( int status ); // 立即进入内核
```

- `exit()`总是执行一个标准IO库的清理关闭操作，对于所有打开流调用fclose函数，这造成输出缓冲中的所有数据都被冲洗到文件/终端控制台上

## 终止处理程序

```c
// 注册一个终止处理程序(函数)，在exit调用时，自动先执行终止处理程序
int atexit( void (*func)(void) );
```

![WX20181211-112904.png](https://i.loli.net/2018/12/11/5c0f2fae31dcc.png)

## 进程环境变量

```c
extern char **environ; // 全局环境变量
char *getenv( const char *name );
int putenv( char *str );
int setenv( const char *name, const char *value, int rewrite );
int unsetenv( const char *name );
```

![WX20181211-113641.png](https://i.loli.net/2018/12/11/5c0f30e16a177.png)

## 存储空间动态分配

```c
void *malloc( size_t size );
void *calloc( size_t nobj, size_t size ); // 为指定长度的对象分配存储空间
void *realloc( void *ptr, size_t new_size ); // 从新分配存储空间
void free( void *ptr ); // 释放已经分配的内存
```

## setjmp 和 longjmp

```c
#include <setjmp.h>
int setjmp( jmp_buf env ); // 在希望返回的位置使用
void longjmp( jmp_buf env, int val ); // 跳转时使用
```

- 在调用 longjmp 后，自动变量，全局变量，寄存器变量，静态变量的不同情况

## 进程资源限制

```c
int getrlimit( int resource, struct rlimit *rlptr );
int setrlimit( int resource, const struct rlimit *rlptr );
struct rlimit{
    rlim_t rlim_cur;
    rlim_t rlim_max;
}
```

## 进程ID

- 0 号进程为调度进程，也称为交换进程，是内核的一部分
- 1 号进程为init进程，在自举过程中由内核调用，读取`/etc/rc*` `/etc/inittab` `/etc/init.d`中的配置，并且将系统引导到一个状态，init进程绝不会终止，它是一个普通的用户进程(与内核中的交换进程不同),但是它以超级用户特权运行

```c
pid_t getpid(void);  // 获取当前进程 ID
pid_t getppid(void); // 获取当前进程的 父进程ID
uid_t getuid(void);  // 当前进程的 用户ID
uid_t geteuid(void); // 当前进程的 有效用户ID
gid_t getgid(void);  // 当前进程的 组ID
gid_t getegid(void); // 当前进程的 有效组ID
```

## 改变进程所有者

```c
int setuid(uid_t uid);
int seteuid(uid_t uid);
int setgid(gid_t gid);
int setegid(gid_t gid);
```

![WX20181217-155417.png](https://i.loli.net/2018/12/17/5c175671be494.png)

## 创建新进程

- 子进程与父进程只共享正文段，两者的数据空间，堆和栈是独立的，子进程拿到的是副本
- fork后，子进程先执行还是父进程先执行是不确定的，即使父进程使自己休眠 2s,让子进程先执行，但并不能保证 2s 就已经足够
- 可以使用信号使父进程与子进程同步
- 子进程与父进程的文件共享: fork时，父进程的所有打开的文件描述符都被复制到子进程中，父进程和子进程每个相同的打开描述符共享一个文件表项
- 父进程与子进程共享同一个文件偏移量

![WX20181211-193510.png](https://i.loli.net/2018/12/11/5c0fa12438993.png)

- 在网络服务器编程中，fork后，父进程与子进程各种关闭它们不需要使用的文件描述符，这样就避免了干扰对方使用的文件描述符

- 除打开文件之外，父进程的很多其他属性也由子进程继承
  - 实际用户ID 实际组ID 有效用户ID 有效组ID
  - 附属组ID 进程组ID 会话ID 控制终端 设置用户ID标志 和 设置组标志
  - 当前工作目录 根目录 文件模式创建屏蔽字
  - 信号屏蔽和安排 对任一打开文件描述符的执行时关闭(close-on-exec)标志
  - 环境 连接的共享存储段 存储映像 资源限制

- 父进程与子进程区别如下
  - fork的返回值不同
  - 进程ID不同
  - 这两个进程的父进程ID不同
  - 子进程的tms_utime tms_stime tms_cutime tms_ustime 的值设置为0
  - 子进程不继承父进程设置的文件锁
  - 子进程的未处理闹钟被清除
  - 子进程的未处理信号集设置为空集

## 打印内存地址

```c
int a;
printf("address : %p \n", &a);
```

## 普通的创建一个进程

```c
pid_t pid = fork();
if(pid < 0){
    printf("fork 出错");
} else if ( pid == 0) {
    printf("-------child porcess %d start ----------\n",getpid());
    execl("hello","a",NULL);
    printf("-------child porcess %d end ----------\n",getpid());
} else {
    printf(" 父进程 ");
    sleep(3);
}
```

## vfork

- vfork创建新进程，该新进程的目的就是exec一个新程序，vfork不将父进程的地址空间完全复制到子进程中，因此它比fork效率高
- vfork保证子进程先运行，在它调用exec或exit之后，父进程才可能被调度运行

```c
int stack = 1;
int *heap = (int *) malloc(sizeof(int));
*heap = 100;
// 进程中数据
printf("before vfork : global : %d , stack : %d , *heap : %d \n",global ,stack ,*heap);
pid_t pid = vfork();
if(pid < 0)
{
    printf("vfork error");
}
else if(pid == 0)
{
    printf("thread process %d start\n",getpid());
    global ++ ;
    stack ++;
    (*heap) ++ ;
    printf("after vfork in thread : global : %d , stack : %d , *heap : %d \n",global ,stack ,*heap);
    printf("thread process %d end\n",getpid());
    exit(0);
}
else
{
    printf("in process : global : %d , stack : %d , *heap : %d \n",global ,stack ,*heap);
}
```

## 获取子程序结束信息

- 不管进程是如何退出的，我们都希望终止进程能够通知其父进程，它是如何终止的
- 当进程终止时，内核向其父进程发送`SIGCHLD`信号，这是个异步事件
  - 父进程可以选择忽略该信号
  - 也可以设置一个处理该信号的函数
  - 或者采取系统默认动作
- 在父进程调用`wait`时
  - 如果其所有子进程都还在运行，则阻塞
  - 如果有一个子进程已终止，正等待父进程获取其终止状态，则wait取得该子进程的终止状态立即返回
  - 如果它没有任何子进程，则立即出错返回

```c
#include <sys/wait.h>
pid_t wait(int *statloc);
pid_t waitpid( pid_t pid, int *statloc, int options );
int waitid( idtype_t idtype, id_t id, siginfo_t *infop, int options );
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <sys/source.h>
pid_t wait3(int *statloc,int options,struct rusage *rusage);
pid_t wait4(pid_t pid,int *statloc,int options,struct rusage *rusage);
```

![WX20181212-111214.png](https://i.loli.net/2018/12/12/5c107cb8812fb.png)

## 僵尸进程

```c
pid_t pid = fork();
if(pid < 0)
{

}
else if(pid == 0)
{
    printf("the child process %d start \n", getpid());
    sleep(3);
    printf("the child process %d end \n", getpid());
    // 子进程退出了，父进程还在运行，并且没有调用 wait 清理子进程，则子进程就成了zombie
    exit(0);
}
else
{
    sleep(30);
    if(wait(NULL) == -1){
        perror("fail to wait");
    }
    printf("the parent process %d end \n", getpid());
    exit(0);
}
```

- 如果子进程先于父进程退出， 同时父进程又没有调用wait/waitpid，则该子进程将成为僵尸进程。

## 输出进程统计信息

- 进程统计信息都储存在rusage这个统计资源结构体内

## 调试多进程

## 设置跟踪流

```c
(gdb)set follow-fork-mode [parent|child]
(gdb)set detach-on-fork [on|off]
```

## 使用gdb的attach命令

## 在进程中运行shell命令

```c
#include <stdlib.h>
int system(const char * cmdstring);
```

# 进程
- 每个进程都有一个父进程
- 当子进程终止时，父进程会得到通知并能取得子进程的退出状态

## 进程组
- 每个进程也属于一个进程组
- 每个进程组都有一个进程组号，该号等于该进程组组长的PID号
- 一个进程只能为它自己或子进程设置进程组ID号
- Shell上的一条命令形成一个进程组
- 进程组的生命周期到组中最后一个进程终止, 或加入其他进程组为止。

## 会话期
- 一次登录形成一个会话。一个会话可包含多个进程组，但只能有一个前台进程组。
- 对话期(session)是一个或多个进程组的集合
- `setsid()` 函数可以建立一个新Session，但要求执行它进程不是一个进程组的组长，如果该进程是一个进程组的组长，此函数返回错误
1. 此进程变成该 Session 的首进程
1. 此进程变成一个 新进程组 的 组长进程
1. 此进程没有控制终端，如果在调用 setsid 前，该进程有控制终端，那么与该终端的联系被解除
1. 为了**保证执行进程不是组长**这一点，我们先调用fork()然后exit()，此时只有子进程在运行，

## 控制终端
- 会话的领头进程打开一个终端之后, 该终端就成为该会话的控制终端 (SVR4/Linux)
- 与控制终端建立连接的 会话领头进程 称为控制进程 (session leader)
- 一个会话只能有一个控制终端
- 产生在控制终端上的 输入 和 信号 将发送给 **会话的前台进程组中的所有进程**
- 终端上的连接断开时 (比如网络断开或 Modem 断开), 挂起信号将发送到控制进程(session leader)

##  内核守护进程
```bash
# ps aux
Init                        系统守护进程，他的进程ID是1，负责启动各运行层次的特定服务
Keventd                     为在内核中运行计划执行的函数提供上下文
Kswapd                      页面调出守护进程将脏页面低速写到磁盘上，从而使这写页面在需要时仍可回收使用
portmap                     端口映射守护进程
syslogd                     可由操作人员将系统信息记录到日志的任何程序使用
inetd                       侦听系统网络接口，以便取得来自网络的各种网络请求
nfsd lockd rpciod           提供网络文件系统的支持
cron                        指定的日期和时间执行指定的命令
```

![WX20181217-163152.png](https://i.loli.net/2018/12/17/5c175f05917c3.png)

## 通知内核哪一个进程组是前台进程组

```c
pid_t tcgetpgrp( int fd );
int tcsetpgrp(int fd, pid_t pgrpid);
pid_t tcgetsid(int fd);
```
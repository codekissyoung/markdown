# Linux 时间编程

- 在执行流中加入时延
- 调度一个将来要做的任务

# sleep() 原理

- 每个进程都有一个私有的闹钟 `alarm clock`, 这个闹钟是一个定时器，设置为 一定秒数后，时钟发送一个信号 `SIGALRM`到进程
- 除非为`SIGALRM`设置了处理函数`handler`, 否则信号将杀死这个进程
- `sleep()`实现 ： 1. 为`SIGALRM`设置`handler`，`handler`设置为唤醒程序 2. 调用 `alarm( seconds )`，设置一个超时调用时间 3. 调用`pause()`暂停程序
- `alarm()`用来设置信号SIGALRM在经过参数seconds指定的秒数后传送给目前的进程。如果参数seconds为0，则之前设置的闹钟会被取消，并将剩下的时间返回。要注意的是，一个进程只能有一个闹钟时间，如果在调用alarm之前已设置过闹钟时间，则任何以前的闹钟时间都被新值所代替

# 更高精度的计时器

- `usleep( n )` 将当前进程挂起 n 微秒，或者直到有一个不能忽略的信号到达。

# 三种计时器

- ITIMER_REAL : 真实系统走过的时间，就如同手表记录的时间，不管进程工作在 用户态 还是 核心态，用了多少处理器时间 它都记录，这个计时器用尽，发送`SIGALRM`信号到进程
- ITIMER_VIRTUAL : 只有进程在 用户态 运行时才计时, 计时器用尽，发送 `SIGVTALRM` 信号
- ITIMER_PROF : 这个计时器 在进程 运行于用户态 或者 由于系统调用进入核心态，两种情况都计时

- `int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);` 用来实现延时和定时的功能
- settimer工作机制是，先对it_value倒计时, 当it_value为零时触发信号，然后重置为it_interval，每间隔 it_interval 触发信号
- 假如it_value为0是不会触发信号的，所以要能触发信号，it_value得大于0；如果it_interval为零，只会延时，不会定时（也就是说只会触发一次信号)。
- old_value参数，通常用不上，设置为NULL，它是用来存储上一次setitimer调用时设置的new_value值。

```c
struct itimerval {
    struct timeval it_interval; /* next value */  
    struct timeval it_value;    /* current value */  
};  
  
struct timeval {  
    time_t      tv_sec;         /* seconds */  
    suseconds_t tv_usec;        /* microseconds */  
};  
```
```c
#include <stdio.h>
#include <sys/time.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>

void countdown( int );
int set_ticker( int );

int main( int argc, char *argv[] )
{
    signal( SIGALRM, countdown );
    if( set_ticker( 500 ) == -1 ) 
        perror("set_ticker");
    else
        while( 1 )
        {
            printf("do something else\n");
            pause();
        }
    return 0;
}

void countdown( int signum )
{
    static int num = 10;
    printf( "signal catched %d .. ", num-- );
    fflush( stdout );
    if( num < 0 )
    {
        printf( "Done!\n" );
        exit( 0 );
    }
}

int set_ticker( int n_msecs )
{
    struct itimerval new_timeset;
    long n_sec   = n_msecs / 1000;
    long n_usecs = ( n_msecs % 1000 ) * 1000L;

    new_timeset.it_interval.tv_sec  = new_timeset.it_value.tv_sec  = n_sec;
    new_timeset.it_interval.tv_usec = new_timeset.it_value.tv_usec = n_usecs;

    return setitimer( ITIMER_REAL, &new_timeset, NULL );
}
```

# 一个硬件时钟的脉冲是计算机里唯一需要的时钟

- 如何使用一个时钟实现 一个进程的私有计时器为 5s 的同时，又设置另一个进程的 私有计时器为 12s呢？
    - 答案 : 每个进程设置自己的计数时间，比如 5s , 12s, 内核在运行过每一个时间片( 比如 500us )后，为所有的计数器做递减，5s - 500us, 12s - 500us, 当 5s 被减到0时，就发送`SIGALRM`信号给这个进程，然后等到 12s 也被减为 0 时，也相应的发送信号。
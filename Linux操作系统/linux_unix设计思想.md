# Linux Unix设计思想

## Unix哲学：集思广益的智慧

- **NIH综合征(Not Invented Here)**: 人们为证明自己可以提供更好的方案，重新造轮子;表明他无兴趣去改善和维护他人提供的方案，也不想以此为基础去挑战新高度。这种做法会浪费宝贵的大量时间。可能新造出来的轮子只是稍微有些改进，没有本质区别。

- **小即是美**: 小巧的软件以独特有效的方式结合其他小事务，非常灵活高效

- **一个程序只做好一件事**

- **尽快建立原型**

- **舍弃高效率 取可移植性**

- **用纯文本来存储数据** 文本易于移植

- **充分利用软件的杠杆效应** 即要重视代码重用，可重用代码模块可以帮助我们节省时间

- **使用shell脚本** 只要有可能，编写shell脚本来替代C语言程序

- **避免强制性用户界面** 对于命令行:有些命令在运行的时候会去阻止用户去运行其他命令;对于GUI:就是模态框阻止用户去点击其他按钮

- **让每一个程序都成为过滤器** 接收stdin数据 ，程序处理数据，输出处理过的数据到output

- **允许用户定制环境** 程序只提供解决问题的机制，而不是为解决问题的方法设置标准做法

- **保持程序内核小而轻巧** 尽管对新功能的追求无止境，但是要让程序最核心的部分保持最小的规模

- **使用小写字母 保持简短**

- **保护树木** 不使用纸质文档 而是在线存储所有文字档案

- **沉默是金** 正确操作不要提示用户成功了，错误操作才提示

- **并行思考** 大任务拆分成更小的子任务，子任务可以并行运行

- **各部分之和大于整体** 小程序集合而成的大型应用程序，比单个大程序更灵活，也更为实用

- **寻找90%的解决方案** 百分百完成任何事情都是很困难的。完成90%会更有效率而且更节省成本。意思是解决方案只需要覆盖到问题的90%就行，剩余的罕见情况和问题，暂时放着

- **廉价但有效的系统和方案更有生命力**

- **层次化思考** 通过划分层次来组织事物

## 人类的一小步

- 准则1: 小即是美

- 小程序更容易理解，更易于维护

- 小程序容易与其他工具相结合

- 排查程序过大功能过多程序的基本思路
  - 传递给函数调用的参数数量过多
  - 函数的实现代码太长
  - 靠阅读注释，才能记住函数在做些什么
  - 在获取目录列表的时候，屏幕显示不下这些源文件的名称
  - 无法想起程序的给出的错误信息是在什么条件下引发的
  - 需要画图才能理清代码的思路

- 一个程序只做好一件事情
  - 这个程序需要与用户互动么？
  - 用户是否要在文件中或者命令行中给出必要的参数？
  - 这个程序需要输入特殊格式的数据么？
  - 系统上是否有能够提供该格式转换功能的程序?
  - 这个程序需要输出特殊格式的数据么？明文的ASCII文本是否就足够?
  - 有没有其他程序可以执行你想要完成的类似功能，而不需要重新编写代码?
  - `ls`命令应该就只包含列出文件列表的功能，而它的各种参数，比如格式化功能`-h`就不是核心功能，抽出这部分格式化功能编写新程序，可以精简ls的代码

## 快速建立原型的乐趣和好处

- 知识与学习曲线：医生要学习医学研究方面的最新发展；会计要学习税法的新变化；律师得研究新的法院判决案例；知识一直在增加，越往后面，对于人类来说 平均学习曲线 越来越陡峭

- 变化不可避免，项目不会遵守原有的规格说明书，营销需求会改变，关键功能的实现会与原设想完全不同

- 用户的最终期望，经过产品经理，销售团队，支持人员的传递，会被曲解

- 现实社会经验已经证明了我们不会随随便便成功，要坦然面对这个现实，在设计过程中，我们要充分考虑到未来必将发送变化，对目标了解的越充分，就越能降低对产品做重大修改的成本。

- 软件涉及到抽象概念，将只存在脑海里的想法准确描述出来是非常困难的

- 正因为世界一直在变化，需求描述不准确，甚至被曲解，所以完美解决问题的软件不存在，程序被反复修改，返工是非常正常的事情

- 尽快建立原型
  - 尽快意味着花少量时间规划这个应用程序，然后便可以创建原型，写代码！
  - 原型的建立是学习的过程，可以显示哪些想法可行，哪些想法不可行，
  - 原型可以尽早交付给客户，从而获得反馈，很多时候，这会收到大量批评，但是总比花大量时间开发出来，用户却说不是想要的好

- 三个系统理论
  - 第一个系统: 时间紧迫，没有资源，单枪匹马一小挫人开发出来的，也许没有规划，功能也不太完善，但是可以用，精简，快速，创新创造力十足
  - 第二个系统：由于第一个系统的成功，由委员会以及成千上百人从头开始设计上一个系统的功能，往往都是臃肿的
  - 第三个系统: 第三个系统是那些被第二个系统的臃肿所累的人创建的，砍掉了第二个系统中那些臃肿的功能，只包括人们实际用得着的功能，可拓展

- 传统软件开发流程
  1. 思考系统的设计
  1. 建立一个原型来测试既定目标
  1. 写详细的功能文档和设计规范
  1. 编写代码
  1. 测试软件
  1. 修复测试过程中发现的bug和设计缺陷，并随时更新文档

- Unix软件开发流程
  1. 写一份简短的功能规格文件
  1. 编写软件
  1. 使用迭代的软件测试、重新编写代码的开发过程，直至完成全部功能
  1. 如果有必要的话，在编写一份详细文档

## 可移植的优先权

- 最强大的计算机并不是那一款有着最快CPU,最大磁盘驱动器或是最强劲软件的机器。使用最频繁的那台计算机才最为强大。
- 一旦程序利用了某些特殊硬件功能的优势，它在变得高效的同时也就不可移植了
- 可移植的软件减少了用户培训需求
- 好程序永不会消失，而是会被移植到新的平台
- 可移植的代码只完成了可移植性的一部分，另外一部分在于可移植的数据，如何让数据具有可移植性呢？
- 采用纯文本来存储数据，在linux世界中，数据文件就应该只包含一组由换行字符分割的字节流
- 文本是通用的可转换格式，文本易于编辑和理解，文本数据简化了Unix文本工具的使用

## 软件的杠杆效应

- `金字塔`营销的价值，发展自己的下线，把产品以微薄的利益卖给他们，由他们来代替自己卖货
- 无论多么聪明过人，精力充沛，一个人的精力就这么多，想要取得非凡的成就，就必须放大自己对这个世界的影响力
- 不要所有事情都亲力亲为，要想办法让别人来分担一些
- 良好的程序员编写优秀代码，而优秀的程序员则借用优秀代码
- 亲自编写应用程序中的每一行代码，会花费大量时间，会显得你工作进度缓慢，效率低下;而能够迅速有效地裁剪和组合模块的开发人员会受到青睐
- 避免NIH综合征，不要瞎造轮子
- 允许他人使用你的代码来发挥软件杠杆效应
- 将一切自动化，让机器加倍努力干活
  - 是否经常使用纸张打印文件，一旦使用纸张工作，它的管理就成了手工操作，这种做法非常低效
  - 是否还在人工处理数据排序，计算个数等?
  - 你如何查找系统上的文件,是通过浏览一个接一个的目录么？
  - 是否靠肉眼在文档中搜寻目标呢?
  - 命令解释器的历史记录是否有效利用呢?
  - 有打开多个窗口工作么?
  - 剪切和粘贴工具的频率高不高？
  - 命令补全功能
- 使用Shell来提高杠杆效应和可移植性
- Shell脚本的可移植性比C程序高
- 抵制采用C语言来重写Shell脚本的愿望，人生苦短，不要浪费时间在这上面

## 交互式程序的高风险

- CUI 程序

```bash
$ mail     # 这就是CUI程序，独占Shell,退出后才能够继续使用其他命令
MAIL> dir
MAIL> exit
$ search
```

- 任何需要等待用户输入的系统，它的处理速度就是人类的操作速度
- 典型的Linux命令会努力执行自己的任务，尽量做到完全不需要人工干预，大多数程序也只是在它们即将执行一些不可逆操作时才会提示用户
- 带有CUI的程序会假定用户是人，所以它们与其他程序的交互性并不好。那些设计成能够与其他软件进行交互的软件通常比设计成与人沟通的软件更为灵活
- 图形用户界面只不过是CUI的可视化形式，所以CUI有的缺点，它全都有
- 让每一个程序都成为过滤器，即：从输入端读取数据，然后处理，然后写入数据到输出端;组合多个过滤器可以灵活地处理数据
- 程序不创建数据，只有人类才会创建数据，创造数据需要一个原始信息源，比如人在使用文字处理软件时，文字来自于他的大脑，文字处理软件只是一个工具，那些收集周围世界的实时程序也不创建数据，那些数据早已存在，程序进行了一个读取过滤而已
- 计算机将数据从一种形式转换成另一种，比如音乐是一种数据，移动手腕与手指产生的音符被捕捉，乐谱记录歌曲，打孔纸带记录，磁片记录，捕获转化为标准电子音乐格式 MIDI 文件
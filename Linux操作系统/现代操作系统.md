# 《现代操作系统》

本文是《现代操作系统》第3版的笔记。

## 第1章 引论

计算机`CPU`等硬件存在两种工作模式:

- **内核态**:能访问所有硬件、能使用所有机器指令
- **用户态**:受限制的硬件访问、只能使用部分机器指令

操作系统可以理解为人们编写的工作在内核态的唯一软件，其他所有软件都是基于操作系统提供的功能进行二次开发，工作在用户态。

计算机发展历史:

- 第一代：真空管和穿孔卡片
- 第二代：晶体管和批处理系统（多个程序写在一张磁带上，供计算机依次计算完毕）
- 第三代：集成电路芯片和多道程序设计(**分时系统**出现了，多个程序轮流执行一小段时间，直至完毕)
- 第四代: 个人计算机

计算机硬件:

![计算机硬件](https://img.codekissyoung.com/2019/07/09/bcbcd52e98f37c78c6c724eac98bb7c0.png)

![总线](https://img.codekissyoung.com/2019/07/09/81c8b1c8cc082001d747ea88dc9562d7.png)

启动计算机:

1. 计算机加电后，`BIOS`(`Basic Input Output System`)第一个运行，负责检查`RAM`个数、键盘和其他设备是否正常安装并且响应，接着扫描`ISA`与`PCI`总线并且找出连接到上面的所有设备。
1. 之后`BIOS`读取`CMOS`存储器中的启动列表(硬盘、CD-ROM、USB闪存、软盘等)，按照次序找到第一个存在的设备，从里面加载加载第一个扇区`MBR`，根据`MBR`的指示，加载存储在分区中的操作系统引导程序（比如`grub2`）
1. `grub2`负责读入操作系统
1. 操作系统询问`BIOS`索要各种设备的信息，将各种设备的驱动程序调入内核，然后初始化系统，创建各种守护进程，并启动用户登录程序或`GUI`

系统调用:

```c++
count = read( fd, buffer, nbytes )；
```

![系统调用](https://img.codekissyoung.com/2019/07/10/f3cd3440422709ea581c4a5e284295f1.png)

## 第2章 进程与线程

多道程序设计、分时系统指的是一个意思，都是CPU在一段时间内快速在多个进程间切换，轮流执行。

进程的生命周期:

- 创建`fork`
- 终止:正常退出、出错退出、严重错误、被其他进程杀死

`UNIX`中，一个进程和它的所有后代共同组成一个**进程组**，键盘产生的信号发送给与键盘关联的进程组中的所有成员，每个进程都可以捕获到这个信号。

### 进程的实现

每个进程都是独立的实体，有自己的程序计数器和内部状态。内核维护了一张进程表，每个进程占据一条记录，每条记录被称为`PCB`。它存储的信息如下:

![PCB](https://img.codekissyoung.com/2019/07/14/ffd1ede48f8689a34c4db113fb33744b.png)

进程从运行态转换到就绪态/阻塞态时，将它执行时的信息保存在`PCB`中，用于恢复运行现场，从而保证它再次进入运行态时，就像从未被中断过一样。

中断过程:

1. 硬件压入堆栈程序计数器等信息
1. 硬件从中断向量装入新的程序计数器
1. 保存寄存器值(汇编语言)
1. 设置新的堆栈(汇编语言)
1. 中断服务例程运行(C语言)，读取和缓冲输入
1. 调度程序决定下一个将运行的进程
1. 开始运行新的进程(汇编语言)

### 线程

一个进程通常只有一块内存空间，以及一个控制线程。如果希望在同一个地址空间中并行地运行多个控制线程呢？

进程中需要多线程的理由是：一个应用中同时发生着多种活动，某些活动会阻塞(比如等待用户输入、读取磁盘等)，而渲染、计算等活动则可以一直使用`CPU`，如果这个应用可以分解成可以并行运行的多个顺序线程，程序设计模型将会变得简单。

如果应用的所有线程都是计算密集型，那么多线程并不能带来性能上的增强；但是如果应用包含了大量的计算和大量的`I/O`处理，则多个线程分别处理这两种情况，则可以加快应用程序的执行。

比如`Word`程序使用的线程:

- **交互线程**:与用户交互,监控着鼠标与键盘，当用户有操作文本内容时，立刻通知格式化线程
- **格式化线程**:计算并重新排版内容
- **自动备份线程**:使用定时器，每一分钟自动保存整个文本到磁盘

再来看一个多线程的`Web`服务器:

![多线程的Web服务器](https://img.codekissyoung.com/2019/07/15/847008ca2edcdeeb77af1d2e86e1e3c3.png)

其实可以用三种方式实现`Web`服务器：

![实现Web服务器的方式](https://img.codekissyoung.com/2019/07/15/beebf5af8c0343a846b74f6e73621736.png)

**单线程进程**:

`Web`服务器的主循环获得请求，检查请求，并且在取下一个请求之前完成整个工作。这里有个问题，就是当`I/O`操作时，进程是阻塞的，`CPU`空转，并且无法处理下一个请求。所以这种实现方式，每秒钟只能处理很少的请求。

**单线程+非阻塞I/O**:

请求到来时，线程对请求进行考察:
  - 如果能够及时处理，则处理
  - 如果需要`IO`操作，则使用非阻塞`I/O`
    - 如果能直接读取到数据，则继续处理
    - 如果不能读取到数据，则直接返回`-1`，不阻塞进程，然后将这次请求以及它的状态保存下来，然后继续处理下一个请求

当某个保存的请求的`I/O`操作的数据准备好可以读取时，进程收到一个中断或者信号(由内核发送的)，打断当前的程序执行，进程保存下工作现场后，转而去处理中断信号，这时候就可以将该请求以及它状态取出，然后读取`I/O`数据，计算处理后，返回给前端。

通过这种方式，也可以每秒钟接收大量请求，保存请求以及处理中断事件，会打断程序执行流，导致理解困难，且编程实现复杂。

**多线程+阻塞I/O**

多线程使得程序执行流不会被打断，单个线程使用阻塞`I/O`被阻塞后，不会影响到其他线程(尤其时主线程)的执行，所以每秒钟(主线程)可以接收大量请求，然后分配给其他线程处理。

总结起来就是，阻塞`I/O`调用使得程序顺序执行，编程变得简单容易，但是也是由于阻塞，导致每秒钟能处理的请求不多。而多线程可以使得主线程接收请求，不处理`I/O`永远不会堵塞，然后分配工作线程去处理请求，工作线程的`IO`堵塞并不会影响到主线程，从而既可以处理大量请求，又可以使用阻塞`IO`，让编程变得简单。

**理解进程和线程**

- 进程将相关的资源集中在一起，其中包括打开的文件、子进程、即将发生的警报、信号处理程序、账号信息等。
- 线程处于进程中，共享进程的一切。
  - 但线程则拥有独立的程序计数器，用以记录接着要执行的指令
  - 拥有独立寄存器，来保存当前线程的工作变量
  - 还拥有一个栈，用于记录线程自身的局部变量。

线程是`CPU`上被调度执行的实体。现代`CPU`能直接硬件支持线程切换，在纳秒级就可完成。

![进程与线程](https://img.codekissyoung.com/2019/07/15/abb18b5827c4bbd3fdb726260f5bdb6a.png)

### POSIX 线程

![POSIX 线程](https://img.codekissyoung.com/2019/07/15/4853b867714687406da8ff0267b296f0.png)

线程库的实现一般有两种方式:a.在用户空间中 b.在内核中实现

![线程库的实现](https://img.codekissyoung.com/2019/07/15/37d65f7c12d36f1d104cc3d94b454e35.png)

### 进程间通信

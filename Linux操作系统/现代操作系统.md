# 《现代操作系统》

本文是《现代操作系统》第4版的笔记。

## 第1章 引论

`CPU`等硬件存在两种工作模式:

- **内核态**:能访问所有硬件、能使用所有机器指令
- **用户态**:受限制的硬件访问、只能使用部分机器指令

操作系统可以理解为人们编写的工作在内核态的唯一软件，其他所有软件都是基于操作系统提供的功能进行二次开发，工作在用户态。
操作系统为应用程序员提供了硬件资源的清晰抽象，并且提供管理接口。

为了使用一个`SATA`硬盘，它参考书超过450页，太复杂了，所以人们创造了**硬盘驱动 disk driver**这样一种软件来和硬件交互，它提供了读写硬盘块的接口，而不用深入了解硬件细节。但就算在这个层面，对于应用程序来说还是太底层了，所以操作系统使用驱动程序再一次抽象出**文件**这一概念。程序能够创建、读写文件，而不用处理驱动的细节。

**多路复用**：

- 在时间上多路复用，是指的是多个进程轮流使用资源
- 空间复用，是指的是把资源切分成多个部分，每个进程使用一部分，比如一块内存条划分成`4KB`大小的页，每个进程都只占用部分页。

计算机发展历史:

- 第一代：真空管和穿孔卡片
- 第二代：晶体管和批处理系统（多个程序写在一张磁带上，供计算机依次计算完毕）
- 第三代：集成电路芯片和多道程序设计(**分时系统**出现了，多个程序轮流执行一小段时间，直至完毕)
- 第四代: PC
- 第五代: Mobile

CPU:

- 指令集: `x86`指令集 与 `ARM`指令集
- 程序计数器：保存`CPU`将要执行的的下一条指令的内存地址
- 堆栈寄存器: 指向内存中当前栈的顶端。该栈包含每个执行过程的栈(输入的参数、局部变量、没保存在寄存器中的临时变量)
- 程序状态字寄存器`PSW`:保存了条件码位、CPU优先级、模式(内核态或用户态)、其他控制位

存储器:

- 寄存器 `1ns` 访问时间
- 高速缓存 `2ns`
- 主存 `10ns`
- 磁盘 `10ms`

I/O设备:

- `I/O`设备一般包含两部分，一是控制芯片，二是设备本身。控制芯片为操作系统提供了一个简单的操作接口。

启动计算机:

1. 计算机加电后，`BIOS`(`Basic Input Output System`)第一个运行，负责检查`RAM`个数、键盘和其他设备是否正常安装并且响应，接着扫描`ISA`与`PCI`总线并且找出连接到上面的所有设备。
1. 之后`BIOS`读取`CMOS`存储器中的启动列表(硬盘、CD-ROM、USB闪存、软盘等)，按照次序找到第一个存在的设备，从里面加载加载第一个扇区`MBR`，根据`MBR`的指示，加载存储在分区中的操作系统引导程序（比如`grub2`）
1. `grub2`负责读入操作系统
1. 操作系统询问`BIOS`索要各种设备的信息，将各种设备的驱动程序调入内核，然后初始化系统，创建各种守护进程，并启动用户登录程序或`GUI`

系统调用:

```c++
count = read( fd, buffer, nbytes )；
```

![系统调用](https://img.codekissyoung.com/2019/07/10/f3cd3440422709ea581c4a5e284295f1.png)

## 第2章 进程与线程

一个进程就是一个正在执行的程序的实例，包含程序计数器、寄存器和变量的当前值。每个进程可以理解为有它自己的虚拟`CPU`，当然实际情况时是CPU在一段时间内快速在多个进程间切换。这也是多道程序设计、分时系统的意思。

如下图所示，实际只有一个物理程序计数器，每个进程内部保存自己的逻辑程序计数器，每次切换到它运行时，逻辑程序计数器被装入物理程序计数器中，切换出运行态时，物理程序计数器再写回逻辑程序计数器。在任意一个给定的时刻，都只有一个进程在执行。

![进程](https://img.codekissyoung.com/2019/07/19/0eac36c06ad7238a8027bebbcc445629.png)


`UNIX`中，一个进程和它的所有后代共同组成一个**进程组**，键盘产生的信号发送给与键盘关联的进程组中的所有成员，每个进程都可以捕获到这个信号。

### 进程的状态

![进程的状态](https://img.codekissyoung.com/2019/07/19/340728209460b6c85f5345cb40d5ee9e.png)

`UNIX`系统中，一个进程从管道或者设备文件读取数据时，如果没有有效的输入存在，则进程会被自动阻塞。

### 进程的实现

每个进程都是独立的实体，有自己的程序计数器和内部状态。内核维护了一张进程表，每个进程占据一条记录，每条记录被称为`PCB　进程控制块`。它存储的信息如下:

![PCB](https://img.codekissyoung.com/2019/07/19/24c6e8b07edcfefd1e69c7e45817060a.png)

进程从运行态转换到就绪态/阻塞态时，将它执行时的信息保存在`PCB`中，用于恢复运行现场，从而保证它再次进入运行态时，就像从未被中断过一样。

中断过程:

1. 硬件压入堆栈程序计数器等信息
1. 硬件从中断向量装入新的程序计数器
1. 保存寄存器值(汇编语言)
1. 设置新的堆栈(汇编语言)
1. 中断服务例程运行(C语言)，读取和缓冲输入
1. 调度程序决定下一个将运行的进程
1. 开始运行新的进程(汇编语言)

### 线程

一个进程通常只有一块内存空间，以及一个控制线程。如果希望在同一个地址空间中并行地运行多个控制线程呢？

进程中需要多线程的理由是：一个应用中同时发生着多种活动，某些活动会阻塞(比如等待用户输入、读取磁盘等)，而渲染、计算等活动则可以一直使用`CPU`，如果这个应用可以分解成可以并行运行的多个顺序线程，程序设计模型将会变得简单。

如果应用的所有线程都是计算密集型，那么多线程并不能带来性能上的增强；但是如果应用包含了大量的计算和大量的`I/O`处理，则多个线程分别处理这两种情况，则可以加快应用程序的执行。

比如`Word`程序使用的线程:

- **交互线程**:与用户交互,监控着鼠标与键盘，当用户有操作文本内容时，立刻通知格式化线程
- **格式化线程**:计算并重新排版内容
- **自动备份线程**:使用定时器，每一分钟自动保存整个文本到磁盘

再来看一个多线程的`Web`服务器:

![多线程的Web服务器](https://img.codekissyoung.com/2019/07/15/847008ca2edcdeeb77af1d2e86e1e3c3.png)

其实可以用三种方式实现`Web`服务器：

![实现Web服务器的方式](https://img.codekissyoung.com/2019/07/15/beebf5af8c0343a846b74f6e73621736.png)

**单线程进程**:

`Web`服务器的主循环获得请求，检查请求，并且在取下一个请求之前完成整个工作。这里有个问题，就是当`I/O`操作时，进程是阻塞的，`CPU`空转，并且无法处理下一个请求。所以这种实现方式，每秒钟只能处理很少的请求。

**单线程+非阻塞I/O**:

请求到来时，线程对请求进行考察:
  - 如果能够及时处理，则处理
  - 如果需要`IO`操作，则使用非阻塞`I/O`
    - 如果能直接读取到数据，则继续处理
    - 如果不能读取到数据，则直接返回`-1`，不阻塞进程，然后将这次请求以及它的状态保存下来，然后继续处理下一个请求

当某个保存的请求的`I/O`操作的数据准备好可以读取时，进程收到一个中断或者信号(由内核发送的)，打断当前的程序执行，进程保存下工作现场后，转而去处理中断信号，这时候就可以将该请求以及它状态取出，然后读取`I/O`数据，计算处理后，返回给前端。

通过这种方式，也可以每秒钟接收大量请求，保存请求以及处理中断事件，会打断程序执行流，导致理解困难，且编程实现复杂。

**多线程+阻塞I/O**

多线程使得程序执行流不会被打断，单个线程使用阻塞`I/O`被阻塞后，不会影响到其他线程(尤其时主线程)的执行，所以每秒钟(主线程)可以接收大量请求，然后分配给其他线程处理。

总结起来就是，阻塞`I/O`调用使得程序顺序执行，编程变得简单容易，但是也是由于阻塞，导致每秒钟能处理的请求不多。而多线程可以使得主线程接收请求，不处理`I/O`永远不会堵塞，然后分配工作线程去处理请求，工作线程的`IO`堵塞并不会影响到主线程，从而既可以处理大量请求，又可以使用阻塞`IO`，让编程变得简单。

进程与线程的不同:

- 进程将相关的资源集中在一起，其中包括打开的文件、子进程、即将发生的警报、信号处理程序、账号信息等。
- 线程处于进程中，共享进程的一切。
  - 但线程则拥有独立的程序计数器，用以记录接着要执行的指令
  - 拥有独立寄存器，来保存当前线程的工作变量
  - 还拥有一个栈，用于记录线程自身的局部变量。

线程是`CPU`上被调度执行的实体。现代`CPU`能直接硬件支持线程切换，在纳秒级就可完成。

![进程与线程](https://img.codekissyoung.com/2019/07/15/abb18b5827c4bbd3fdb726260f5bdb6a.png)

`POSIX`线程规范:

![POSIX线程](https://img.codekissyoung.com/2019/07/15/4853b867714687406da8ff0267b296f0.png)

线程库的实现一般有两种方式:

- 在用户空间中，内核对线程一无所知。在内核看来，就是按单线程进程在处理这些线程。进程内部保存了它内部所有线程的记录表，当进程中的某个线程执行阻塞操作时，进程内部切换成另一个就绪状态的线程，继续运行。这样子实现的进程切换，比陷入内核态实现的线程切换，要快一个数量级。
- 在内核中实现

> 线程切换:实际操作是将进程当前的堆栈指针和程序计数器，更换为线程表中将要执行的线程的堆栈指针和程序计数器，就是切换的意思了。

![线程库的实现](https://img.codekissyoung.com/2019/07/15/37d65f7c12d36f1d104cc3d94b454e35.png)

### 进程间通信

多个进程读写某些共享数据，最后的结果取决于程序运行的次序(进程的调度运行导致运行次序不可预测)，称为**竞争条件**。如果程序存在竞争条件，则大多数情况下，测试运行结果都运行良好，但在极少数情况下，会发生一些无法解释结果的奇怪情况。

涉及到共享内存、共享文件、以及任何共享资源的情况下，都会引发不可预测的修改，导致结果不可预测。要避免这种情况，必须找到一种方法阻止多个进程同时读写共享的数据。即我们需要**互斥操作**，一个进程在操作共享内存时，其他进程不能做同样的操作。

我们把对共享内存进行访问的程序片段称为**临界区**,如果我们通过适当安排，使得两个进程不可能同时处于临界区中，就能够避免竞争条件。

![临界区](https://img.codekissyoung.com/2019/07/16/af34841638370017f412bfac0d9d2bc8.png)

## 第3章 存储管理

最开始存储器是没有抽象的，每一个程序直接访问物理地址。这种情况下，同时运行两个程序时不可能的，因为无法防止一个程序修改另一个程序的内存。

只存在操作系统和一个用户进程的情景下，内存组织方法:

![内存组织方法](https://img.codekissyoung.com/2019/07/16/ff8f5129bba41a7652f396e28d77023c.png)

这种情况，模拟同时运行多个程序的方法是，把当前进程的内存所有内容保存到磁盘文件，然后把下一个程序读入内存再运行。

### 地址空间的概念

要保证多个应用程序同时处于内存中且并不相互影响，需要解决两个问题:保护和重定位。

**地址空间**是一个进程可使用的一套内存地址集合，每个进程都有一个自己的地址空间，并且这个地址空间独立于其他进程的地址空间。

实现这个地址空间的方法:

**基址寄存器于界限寄存器**:

**交换技术**:把一个进程完整调入内存，运行一段时间后将它存回磁盘。空闲进程主要存储在磁盘上，当它们不运行时就不会占用内存。

![交换技术](https://img.codekissyoung.com/2019/07/16/84ef5214258fcb1c5982f0a9b3231d11.png)

**虚拟内存**:该策略使得程序可以在只有一部分被调入内存的情况下运行。

分页技术:虚拟内存和物理内存都划分成`4K`大小的页，内核使用`页表`将正在使用的物理内存页 与　对应的虚拟内存页 的映射记录下来。

![分页技术](https://img.codekissyoung.com/2019/07/17/2ce9c5b818653e336d6ef733bce684bd.png)

如果程序运行中，要执行一个指令，这个指令访问到了一个虚拟内存地址，而这个虚拟内存地址时没有处于映射表中的，这时内核就会发生一次**缺页中断**，促使内核从物理内存中选出一个未使用的(或者将一个已使用的物理内存页空出来，该页的内容交换到磁盘上)，将这个物理内存页映射给该指令的虚拟内存地址所在的页。然后中断返回到该进程的指令处，执行该指令。

![MMU的内部操作](https://img.codekissyoung.com/2019/07/17/0d2243eb1c6ec2bd28059d388bc1295b.png)

在分页系统的设计与实现时，需要考虑:

- 虚拟地址到物理地址的映射必须非常快
- 如果虚拟地址空间很大，那么页表也会非常大，每个进程都需要自己的页表

## 第4章 文件系统

长期存储:

- 能够存储大量信息
- 使用信息的进程终止时，信息仍旧存在
- 必须能够使多个进程并发存取有关信息

磁盘支持:

- 读取块
- 写入块

设计问题:

- 如何找到信息?
- 如何防止一个用户读取另一个用户的数据？
- 如何知道哪些块时空闲的?

文件是对磁盘的抽象，是进程创建的信息逻辑单元。

## 第5章 输入与输出

## 第6章 死锁

## 第7章 虚拟化与云

## 第8章 多处理机系统

## 第9章 安全

## 第10章 Unix、Linux和Android

## 第11章 Windows 8

## 第12章 操作系统设计

## 第13章 参考书目与文献
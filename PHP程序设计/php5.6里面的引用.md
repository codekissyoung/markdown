# 普通变量的引用
`$b = $a;`是赋值;`$b = &$a;`是引用,改变$b的值 就是 改变$a的值
# 变量赋值原理
php中对于地址的指向（类似指针）功能不是由用户自己来实现的，是由Zend核心实现的，php中引用采用的是“写时拷贝”的原理，就是除非发生写操作，指向同一个地址的变量或者对象是不会被拷贝的。
通俗的讲 如果有下面的代码 `$a="ABC"; $b=$a;`其实此时$a与$b都是指向同一内存地址　而并不是$a与$b占用不同的内存 ,如果在上面的代码基础上再加上如下代码 `$a="EFG";`由于$a与$b所指向的内存的数据要重新写一次了，此时Zend核心会自动判断　自动为$b生产一个$a的数据拷贝，重新申请一块内存进行存储
#对象的引用
对象赋值默认赋值的是引用
$a是对象,`$b = $a`等同与`$b = &$a`
# 函数传参的引用
`function test（&$test）{//按引用传递值}`
# 函数的引用返回
```
function &test()
{
    static $b=0;//申明一个静态变量
    $b = $b+1;
    echo $b;
    return $b;
}
$a=test();//这条语句会输出　$b的值　为１
$a=5;
$a=test();//这条语句会输出　$b的值　为2
$a=&test();//这条语句会输出　$b的值　为3
$a=5;
$a=test();//这条语句会输出　$b的值　为6
```
`$a = test();`只是普通的函数调用,$a接收函数的返回值,而$a做任何改变　都不会影响到函数中的$b
`$a = &test();`才是引用返回,将$a 和 函数里的static 指向同一内存,即产生了相当于这样的效果`$a=&b;`, 所以改变$a的值也同时改变了$b的值　所以在执行了 `$a=&test(); $a=5; `以后，$b的值变为了5这里是为了让大家理解函数的引用返回才使用静态变量的，其实函数的引用返回多用在对象中

# global 引用
当用 global $var 声明一个变量时实际上建立了一个到全局变量的引用。也就是说和这样做是相同的：
```
$var =& $GLOBALS["var"];
```
这意味着，例如，unset $var 不会 unset 全局变量。全局变量在函数内部不可以直接访问，要用global 声明一下才可以访问。全局变量在函数外部是可以随意访问的。

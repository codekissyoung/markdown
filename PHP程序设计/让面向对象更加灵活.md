# 组合模式 Composite
- 组合比继承提供更多的灵活性
- 将一组对象组合为单个对象
- 对于客户端代码来说，组合内部是透明的

```php
class UnitException extends Exception {

}

abstract class Unit {
	function getComposite(){
		return null;
	}
	function addUnit ( Unit $unit ) {
		throw new UnitException( get_class( $this )." is a leaf ");
	}
	function removeUnit( Unit $unit ){
		throw new UnitException( get_class( $this )." is a leaf " );
	}
	abstract function bombardStrength();
}

abstract class CompositeUnit extends Unit {
	private $units = [];

	function getComposite(){
		return $this;
	}

	protected function units(){
		return $this -> units;
	}

	function removeUnit ( Unit $unit ) {
		$this -> units = array_udiff( $this -> units , array($unit) , function ($a ,$b){ return ($a === $b)?0:1;});
	}

	function addUnit( Unit $unit ){
		if( in_array($unit ,$this -> units,true) ){
			return;
		}
		$this -> units[] = $unit;
	}
}

// 射手
class Archer extends Unit {
	function bombardStrength() {
		return 4;
	}
}

// 激光炮
class LaserCannonUnit extends Unit {
	function bombardStrength(){
		return 44;
	}
}

// 军队 : 由军队 / 射手 / 激光炮组成
class Army extends Unit {
	private $units = [];
	private $armies = [];

	function addUnit( Unit $unit ){
		if( in_array( $unit , $this -> units , true ) ){
			return;
		}
		$this -> units[] = $unit;
	}
	
	function removeUnit( Unit $unit ){
		$this -> units = array_udiff( $this -> units , [$unit] , function($a,$b){ return ($a == $b) ? 0 : 1; } );
	}

	function addArmy (Army $army){
		array_push( $this -> armies , $army );
	}

	function bombardStrength(){
		$ret = 0;
		foreach( $this -> units as $unit ){
			$ret += $unit -> bombardStrength();
		}
		foreach( $this -> armies as $army){
			$ret += $army -> bombardStrength();
		}
		return $ret;
	}
}


// army 对象
$main_army = new Army();
$main_army -> addUnit( new Archer() );
$main_army -> addUnit( new LaserCannonUnit() );

// 另一个 army对象
$sub_army = new Army();
$sub_army -> addUnit( new Archer() );
$sub_army -> addUnit( new Archer() );
$sub_army -> addUnit( new Archer() );

// 将一部分军队加入到另一部分军队中
$main_army -> addArmy( $sub_army );
print "攻击强度: {$main_army -> bombardStrength() } \n";
```

# 装饰模式 Decorator

- 通过在运行时，合并对象来拓展功能的一种灵活机制

```php
<?php
abstract class Tile {
	abstract function getWealthFactor();
}

class Plains extends Tile {

	private $wealthfactor = 2;

	function getWealthFactor(){
		return $this -> wealthfactor;
	}
}

abstract class TileDecorator extends Tile {
	protected $tile;
	function __construct( Tile $tile ){
		$this -> tile = $tile;
	}
}

class DiamondDecorator extends TileDecorator{
	function getWealthFactor() {
		return $this -> tile -> getWealthFactor() + 2;
	}
}

class PollutionDecorator extends TileDecorator{
	function getWealthFactor(){
		return $this -> tile -> getWealthFactor() - 4;
	}
}

$tile = new Plains();
print $tile -> getWealthFactor(); // 2

$tile = new DiamondDecorator( new Plains() );
print $tile -> getWealthFactor(); // 4

$tile = new PollutionDecorator( new DiamondDecorator(new Plains()) );
print $tile -> getWealthFactor(); // 0
```

- 多个装饰器，犹如管道被串联起来

```php
<?php
class RequestHelper{}

abstract class ProcessRequest {
	abstract function process( RequestHelper $req );
}

class MainProcess extends ProcessRequest {
	function process( RequestHelper $req ){
		print __CLASS__." : doing something userful with request ! \n";
	}
}

abstract class DecorateProcess extends ProcessRequest{
	protected $processrequest;
	function __construct( ProcessRequest $pr ){
		$this -> processrequest = $pr;
	}
}

class LogRequest extends DecorateProcess{
	function process ( RequestHelper $req ) {
		print __CLASS__." : logging data \n";
		$this -> processrequest -> process( $req );
	}
}

class AuthRequest extends DecorateProcess{
	
	function process ( RequestHelper $req ) {
		print __CLASS__." : authenticating data \n";
		$this -> processrequest -> process( $req );
	}
}

class StrucRequest extends DecorateProcess{
	function process ( RequestHelper $req ) {
		print __CLASS__." : struc request data \n";
		$this -> processrequest -> process( $req );
	}
}

$process = new AuthRequest( new StrucRequest( new LogRequest( new MainProcess() )) );
$process -> process( new RequestHelper() );
// AuthRequest : authenticating data 
// StrucRequest : struc request data 
// LogRequest : logging data 
// MainProcess : doing something userful with request ! 
```

## 外观模式 Facade

- 为复杂多变的系统创建一个简单的接口
- 只是为一个分层或者一个子系统创建一个单一的入口，这样会带来许多好处，比如 有助于分离项目中的不同部分，其次对于客户端开发者来说，访问代码变得非常简洁
- 另外只在一个地方调用子系统，减少了出错的可能性

```php
<?php
// 测试文件 test_facade
// 234-ladies_jumper 55
// 532-gents_hat 44

function getProductFileLines($file){
	return file($file);
}

function getProductObjectFromId($id,$productname){
	return new Product($id,$productname);
}

function getNameFromLine($line){
	if(preg_match("/.*-(.*)\s\d+/",$line,$array)){
		return str_replace('_',' ',$array[1]);
	}
	return '';
}

function getIDFromLine($line){
	if(preg_match("/^(\d{1,3})-/",$line,$array)){
		return $array[1];
	}
	return -1;
}

class Product{
	public $id;
	public $name;
	function __construct($id,$name){
		$this -> id = $id;
		$this -> name = $name;
	}
}

// 外观模式封装
class ProductFacade{
	private $products = [];
	private $file;

	function __construct($file){
		$this -> file = $file;
		$this -> compile();
	}

	private function compile(){
		$lines = getProductFileLines($this -> file);
		foreach($lines as $line){
			$id = getIDFromLine($line);
			$name = getNameFromLine($line);
			$this -> products[$id] = getProductObjectFromID($id,$name);
		}
	}

	function getProducts(){
		return $this -> products;
	}

	function getProduct($id){
		return $this -> products[$id];
	}
}

$lines = getProductFileLines('test_facade');
$objects = [];
foreach($lines as $line){
	$id = getIDFromLine($line);
	$name = getNameFromLine($line);
	$objects[$id] = getProductObjectFromID($id,$name);
}
var_dump($objects);

// 使用外观模式
$facade = new ProductFacade("test_facade");
$product = $facade -> getProduct('234');
var_dump($product);
```

